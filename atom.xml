<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kyleezhang`s Blog</title>
  
  
  <link href="http://kyleezhang.com/atom.xml" rel="self"/>
  
  <link href="http://kyleezhang.com/"/>
  <updated>2022-06-12T11:24:41.825Z</updated>
  <id>http://kyleezhang.com/</id>
  
  <author>
    <name>kyleezhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NodeJS的底层原理</title>
    <link href="http://kyleezhang.com/2021/12/28/node-principle/"/>
    <id>http://kyleezhang.com/2021/12/28/node-principle/</id>
    <published>2021-12-28T00:08:45.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<p>本文的内容主要分为两部分：</p><ul><li>NodeJS 的基础和架构</li><li>NodeJS 核心模块的实现</li></ul><h2 id="nodejs-的基础和架构"><a class="markdownIt-Anchor" href="#nodejs-的基础和架构"></a> NodeJS 的基础和架构</h2><h3 id="一-nodejs-的组成"><a class="markdownIt-Anchor" href="#一-nodejs-的组成"></a> 一、NodeJS 的组成</h3><p>Node.js 主要由 V8、Libuv 和第三方库组成。</p><a id="more"></a><h4 id="1-libuv"><a class="markdownIt-Anchor" href="#1-libuv"></a> 1、Libuv</h4><p>Libuv 是 Node.js 底层的异步 IO 库，但它提供的功能不仅仅是 IO，还包括进程、线程、信号、定时器、进程间通信等，而且 Libuv 抹平了各个操作系统之间的差异。Libuv 提供的功能大概如下：</p><ul><li>Full-featured event loop backed by epoll, kqueue, IOCP, event ports.</li><li>Asynchronous TCP and UDP sockets</li><li>Asynchronous DNS resolution</li><li>Asynchronous file and file system operations</li><li>File system events</li><li>ANSI escape code controlled TTY</li><li>IPC with socket sharing, using Unix domain sockets or named pipes (Windows)</li><li>Child processes</li><li>Thread pool</li><li>Signal handling</li><li>High resolution clock</li><li>Threading and synchronization primitives</li></ul><h4 id="2-v8"><a class="markdownIt-Anchor" href="#2-v8"></a> 2、V8</h4><p>Node.js 是基于 V8 的 JS 运行时，它利用 V8 提供的能力，极大地拓展了 JS 的能力。这种拓展不是为 JS 增加了新的语言特性，而是拓展了功能模块，比如在前端，我们可以使用 Date 这个函数，但是我们不能使用 TCP 这个函数，因为 JS 中并没有内置这个函数。而在 Node.js 中，我们可以使用 TCP，这就是 Node.js 做的事情，让用户可以使用 JS 中本来不存在的功能，比如文件、网络。Node.js 中最核心的部分是 Libuv 和 V8，V8 不仅负责执行 JS，还支持自定义的拓展，实现了 JS 调用 C++ 和 C++ 调用 JS 的能力。比如我们可以写一个 C++ 模块，然后在 JS 调用，Node.js 正是利用了这个能力，完成了功能的拓展。JS 层调用的所有 C、C++ 模块都是通过 V8 来完成的。可以说得益于 V8 支持自定义扩展这才有了 Node.js</p><h4 id="3-第三方库"><a class="markdownIt-Anchor" href="#3-第三方库"></a> 3、第三方库</h4><p>Node.js 中的第三方库主要包括异步 DNS 解析（ cares ）、HTTP 解析器（旧版使用 http_parser，新版使用 llhttp）、HTTP2 解析器（ nghttp2 ）、 解压压缩库( zlib )、加密解密库( openssl )等等。</p><h3 id="二-nodejs-代码架构"><a class="markdownIt-Anchor" href="#二-nodejs-代码架构"></a> 二、NodeJS 代码架构</h3><img src="/assets/node-principle/01.png" width="600" /><p>上图是 Node.js 的代码架构，Node.js的代码主要分为 JS、C++、C 三种。</p><ol><li>JS 是我们平时使用的那些模块(http/fs)。</li><li>C++ 代码分为三个部分，第一部分是封装了 Libuv 的功能，第二部分则是不依赖于 Libuv ( crypto 部分 API 使用了 Libuv 线程池)，比如 Buffer 模块，第三部分是 V8 的代码。</li><li>C 语言层的代码主要是封装了操作系统的功能，比如 TCP、UDP。</li></ol><p>了解了 Node.js 的组成和代码架构后，我们看看 Node.js 启动的过程都做了什么。</p><h3 id="三-nodejs-启动过程"><a class="markdownIt-Anchor" href="#三-nodejs-启动过程"></a> 三、NodeJS 启动过程</h3><p>Node.js启动的主流程图如下所示：</p><img src="/assets/node-principle/08.png" width="700" /><p>涉及到的文件也包括</p><ul><li>src/node_main.cc</li><li>src/node.cc</li><li>src/env.cc</li><li>lib/internal/bootstrap/loader.js</li><li>lib/internal/bootstrap/node.js</li></ul><p>接下来我们详细分析每个过程：</p><h4 id="1-启动"><a class="markdownIt-Anchor" href="#1-启动"></a> 1、启动</h4><p>node 的启动函数在 src/node_main.cc 文件当中，这个文件主要是根据操作系统的不同运行了对应的变量设置。然后会调用 <a href="http://node.cc">node.cc</a> 中的 <code>__Start()__</code> 函数。<a href="http://node.cc">node.cc</a> 中有三个 Start 函数现在我们依次来看看，</p><h4 id="1-注册-c-模块"><a class="markdownIt-Anchor" href="#1-注册-c-模块"></a> 1、注册 C++ 模块</h4><img src="/assets/node-principle/02.png" width="600" /><p>首先 Node.js 会调用 RegisterBuiltinModules 函数注册 C++ 模块，这个函数会调用一系列 registerxxx 的函数，我们发现在 Node.js 源码里找不到这些函数，因为这些函数是在各个 C++ 模块中，通过宏定义实现的，宏展开后就是上图黄色框的内容，每个 registerxxx 函数的作用就是往 C++ 模块的链表了插入一个节点，最后会形成一个链表。</p><p>这儿我们以 _register_tcp_wrap 函数为例详细分析一下在函数中具体做了什么，在这之前我们要先了解一下 Node.js 中表示 C++ 模块的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_module</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> nm_version;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nm_flags;  </span><br><span class="line">    <span class="keyword">void</span>* nm_dso_handle;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* nm_filename;  </span><br><span class="line">    node::addon_register_func nm_register_func;  </span><br><span class="line">    node::addon_context_register_func nm_context_register_func;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* nm_modname;  </span><br><span class="line">    <span class="keyword">void</span>* nm_priv;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">nm_link</span>;</span>  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>_register_tcp_wrap 函数调了 node_module_register，并传入一个node_module数据结构，这里我们看一下 node_module_register 的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node_module_register</span><span class="params">(<span class="keyword">void</span>* m)</span> </span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">mp</span> =</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>*&gt;</span>(m);  </span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;nm_flags &amp; NM_F_INTERNAL) &#123;  </span><br><span class="line">        mp-&gt;nm_link = modlist_internal;  </span><br><span class="line">        modlist_internal = mp;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node_is_initialized) &#123; </span><br><span class="line">        mp-&gt;nm_flags = NM_F_LINKED;  </span><br><span class="line">        mp-&gt;nm_link = modlist_linked;  </span><br><span class="line">        modlist_linked = mp;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        thread_local_modpending = mp;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>C++ 内置模块的 flag 是 NM_F_INTERNAL，所以会执行第一个 if 的逻辑，modlist_internal 类似一个头指针。if 里的逻辑就是头插法建立一个单链表。</p><p>那么 Node.js 里是如何访问这些 C++ 模块的呢？在 Node.js 中，是通过 internalBinding 访问 C++ 模块的，internalBinding 的逻辑很简单，就是根据模块名从模块队列中找到对应模块。但是这个函数只能在 Node.js 内部使用，不能在用户 JS 模块使用，用户可以通过 process.binding 访问 C++ 模块。</p><h4 id="2-创建-environment-对象并绑定到-context"><a class="markdownIt-Anchor" href="#2-创建-environment-对象并绑定到-context"></a> 2、创建 Environment 对象，并绑定到 Context</h4><p>注册完 C++ 模块后就开始创建 Environment 对象，Environment 是 Node.js 执行时的环境对象，类似一个全局变量的作用，他记录了 Node.js 在运行时的一些公共数据。创建完 Environment 后，Node.js<br />会把该对象绑定到 V8 的 Context 中，为什么要这样做呢？</p><p>主要是为了在 V8 的执行上下文里拿到 env 对象，因为 V8 中只有 Isolate、Context 这些对象，Isolate用于隔离实例间的环境，Context用于提供JS执行时的上下文，如果我们想在 V8 的执行环境中获取 Environment 对象的内容，就可以通过 Context 获取 Environment 对象。</p><img src="/assets/node-principle/03.png" width="400" /><img src="/assets/node-principle/04.png" width="500" /><p>实际上这一步骤 Node.js 主要做了如下4件工作：</p><ol><li>进入当前 Context</li><li>保存环境变量</li><li>关联 context 和 env</li><li>创建其他对象</li></ol><p>具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Environment::Environment(IsolateData* isolate_data,  </span><br><span class="line">                            Local&lt;Context&gt; context,  </span><br><span class="line">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,  </span><br><span class="line">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; exec_args,  </span><br><span class="line">                            Flags flags,  </span><br><span class="line">                            <span class="keyword">uint64_t</span> thread_id)  </span><br><span class="line">    : isolate_(context-&gt;GetIsolate()),  </span><br><span class="line">        isolate_data_(isolate_data),  </span><br><span class="line">        immediate_info_(context-&gt;GetIsolate()),  </span><br><span class="line">        tick_info_(context-&gt;GetIsolate()),  </span><br><span class="line">        timer_base_(uv_now(isolate_data-&gt;event_loop())),  </span><br><span class="line">        exec_argv_(exec_args),  </span><br><span class="line">        argv_(args),  </span><br><span class="line">        exec_path_(GetExecPath(args)),  </span><br><span class="line">        should_abort_on_uncaught_toggle_(isolate_, <span class="number">1</span>),  </span><br><span class="line">        stream_base_state_(isolate_, StreamBase::kNumStreamBaseStateFields),  </span><br><span class="line">        flags_(flags),  </span><br><span class="line">        thread_id_(thread_id == kNoThreadId ? AllocateThreadId() : thread_id),  </span><br><span class="line">        fs_stats_field_array_(isolate_, kFsStatsBufferLength),  </span><br><span class="line">        fs_stats_field_bigint_array_(isolate_, kFsStatsBufferLength),  </span><br><span class="line">        context_(context-&gt;GetIsolate(), context) &#123;  </span><br><span class="line">    <span class="comment">// 进入当前的context  </span></span><br><span class="line">    <span class="function">HandleScope <span class="title">handle_scope</span><span class="params">(isolate())</span></span>;  </span><br><span class="line">    <span class="function">Context::Scope <span class="title">context_scope</span><span class="params">(context)</span></span>;  </span><br><span class="line">    <span class="comment">// 保存环境变量  </span></span><br><span class="line">    set_env_vars(per_process::system_environment);  </span><br><span class="line">    <span class="comment">// 关联context和env  </span></span><br><span class="line">    AssignToContext(context, ContextInfo(<span class="string">&quot;&quot;</span>));  </span><br><span class="line">    <span class="comment">// 创建其它对象  </span></span><br><span class="line">    CreateProperties();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 CreateProperties 主要是用于创建诸如 process 等对象，创建之后也会保存到 Environment 对象中。</p><h4 id="3-初始化-libuv-任务"><a class="markdownIt-Anchor" href="#3-初始化-libuv-任务"></a> 3、初始化 Libuv 任务</h4><p>InitializeLibuv 函数中的逻辑是往 Libuv 中提交任务，在 InitializeLibuv 函数中会调用 uv_idle_init、uv_prepare_init、uv_async_init 等 Libuv 提供的方法向 Libuv 不同阶段插入任务节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Environment::InitializeLibuv</span><span class="params">(<span class="keyword">bool</span> start_profiler_idle_notifier)</span> </span>&#123;  </span><br><span class="line">    <span class="function">HandleScope <span class="title">handle_scope</span><span class="params">(isolate())</span></span>;  </span><br><span class="line">    <span class="function">Context::Scope <span class="title">context_scope</span><span class="params">(context())</span></span>;  </span><br><span class="line">    CHECK_EQ(<span class="number">0</span>, uv_timer_init(event_loop(), timer_handle()));  </span><br><span class="line">    uv_unref(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_handle_t</span>*&gt;(timer_handle()));  </span><br><span class="line">    uv_check_init(event_loop(), immediate_check_handle());  </span><br><span class="line">    uv_unref(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_handle_t</span>*&gt;(immediate_check_handle()));</span><br><span class="line">    uv_idle_init(event_loop(), immediate_idle_handle());  </span><br><span class="line">    uv_check_start(immediate_check_handle(), CheckImmediate);  </span><br><span class="line">    uv_prepare_init(event_loop(), &amp;idle_prepare_handle_);  </span><br><span class="line">    uv_check_init(event_loop(), &amp;idle_check_handle_);  </span><br><span class="line">    uv_async_init(  </span><br><span class="line">        event_loop(),  </span><br><span class="line">        &amp;task_queues_async_,  </span><br><span class="line">        [](<span class="keyword">uv_async_t</span>* async) &#123;  </span><br><span class="line">        Environment* env = ContainerOf(  </span><br><span class="line">            &amp;Environment::task_queues_async_, async);  </span><br><span class="line">        env-&gt;CleanupFinalizationGroups();  </span><br><span class="line">        env-&gt;RunAndClearNativeImmediates();  </span><br><span class="line">        &#125;);  </span><br><span class="line">    uv_unref(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_handle_t</span>*&gt;(&amp;idle_prepare_handle_));  </span><br><span class="line">    uv_unref(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_handle_t</span>*&gt;(&amp;idle_check_handle_));  </span><br><span class="line">    uv_unref(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_handle_t</span>*&gt;(&amp;task_queues_async_));  </span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li>timer_handle 是实现 Node.js 中定时器的数据结构，对应 Libuv 的 time 阶段</li><li>immediate_check_handle 是实现 Node.js 中setImmediate的数据结构，对应Libuv的check阶段</li><li>task_queues_async_用于子线程和主线程通信</li><li>。。。</li></ul><h4 id="3-初始化模块加载器和执行上下文"><a class="markdownIt-Anchor" href="#3-初始化模块加载器和执行上下文"></a> 3、初始化模块加载器和执行上下文</h4><p>RunBootstrapping 里调用了 BootstrapInternalLoaders 和 BootstrapNode 函数，我们一个个进行分析</p><p><strong>初始化loader</strong></p><p>BootstrapInternalLoaders 用于执行 <code>internal/bootstrap/loaders.js</code>,对应的逻辑转成 JS 如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">process, getLinkedBinding, getInternalBinding, primordials</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// internal/bootstrap/loaders.js 的代码  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">const</span> process = &#123;&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLinkedBinding</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInternalBinding</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">const</span> primordials = &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">export</span> = demo(process, getLinkedBinding, getInternalBinding, primordials);  </span><br></pre></td></tr></table></figure><p>V8 把 <code>internal/bootstrap/loaders.js</code> 用一个函数包裹起来，参数是 process, getLinkedBinding, getInternalBinding, primordials，而其将会导出一个对象。这儿我们先看一下 getLinkedBinding, getInternalBinding 这两个函数，Node.js 在 C++ 层对外暴露了 AddLinkedBinding 方法注册模块，Node.js 针对这种类型的模块，维护了一个单独的链表。getLinkedBinding 就是根据模块名从这个链表中找到对应的模块。而对于对于 C++ 内置模块，Node.js 同样维护了一个链表，getInternalBinding 就是根据模块名从这个链表中找到对应的模块。</p><p>而执行完 <code>internal/bootstrap/loaders.js</code> 将会返回三个变量给 C++ 层：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;  </span><br><span class="line">    internalBinding,  </span><br><span class="line">    NativeModule,  </span><br><span class="line">    <span class="built_in">require</span>: nativeModuleRequire  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>其中 internalBinding 的生成方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> internalBinding;  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">const</span> bindingObj = ObjectCreate(<span class="literal">null</span>);  </span><br><span class="line">    internalBinding = <span class="function"><span class="keyword">function</span> <span class="title">internalBinding</span>(<span class="params"><span class="built_in">module</span></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> mod = bindingObj[<span class="built_in">module</span>];  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> mod !== <span class="string">&#x27;object&#x27;</span>) &#123;  </span><br><span class="line">        mod = bindingObj[<span class="built_in">module</span>] = getInternalBinding(<span class="built_in">module</span>);</span><br><span class="line">        moduleLoadList.push(<span class="string">`Internal Binding <span class="subst">$&#123;<span class="built_in">module</span>&#125;</span>`</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> mod;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这儿 Node.js 在 JS 对 getInternalBinding 进行了一个封装，主要是加了缓存处理。</p><p>然后我们再看 NativeModule，Node.js 中除了 C++ 模块还有原生 JS 模块，对于加载原生 JS 模块的处理。Node.js 专门定义了一个 NativeModule 类负责原生 JS 模块的加载，还定义了一个变量保存了原生JS模块的名称列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(moduleIds.map(<span class="function">(<span class="params">id</span>) =&gt;</span> [id, <span class="keyword">new</span> NativeModule(id)]));  </span><br></pre></td></tr></table></figure><p>NativeModule主要的逻辑如下</p><ol><li>原生 JS 模块的代码是转成字符存在 node_javascript.cc 文件的，NativeModule 负责原生 JS 模块的加载，即编译和执行。</li><li>提供一个 require 函数，加载原生 JS 模块，对于文件路径以 internal 开头的模块，是不能被用户 require 使用的。</li></ol><p>而这些原生 JS 模块内部往往还需要调用 C++ 模块进行处理，因此 <code>internal/bootstrap/loaders.js</code> 中还封装了 process.binding 方法来方便 JS 层根据模块名查找对应的 C++ 模块，其具体的实现方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> internalBindingWhitelist = <span class="keyword">new</span> SafeSet([,  </span><br><span class="line">    <span class="string">&#x27;tcp_wrap&#x27;</span>,  </span><br><span class="line">    <span class="comment">// 一系列C++内置模块名  </span></span><br><span class="line">]);  </span><br><span class="line">    </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">const</span> bindingObj = ObjectCreate(<span class="literal">null</span>);  </span><br><span class="line">    process.binding = <span class="function"><span class="keyword">function</span> <span class="title">binding</span>(<span class="params"><span class="built_in">module</span></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">module</span> = <span class="built_in">String</span>(<span class="built_in">module</span>);  </span><br><span class="line">        <span class="keyword">if</span> (internalBindingWhitelist.has(<span class="built_in">module</span>)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> internalBinding(<span class="built_in">module</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`No such module: <span class="subst">$&#123;<span class="built_in">module</span>&#125;</span>`</span>);  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><code>internal/bootstrap/loaders.js</code> 在返回后 C++ 层会保存其中两个函数，分别用于加载内置 C++ 模块和原生 JS 模块的函数。</p><p><strong>初始化执行上下文</strong></p><ol><li>Node.js 首先传入 C++ 模块加载器，执行 loader.js，loader.js 主要是封装了 C++ 模块加载器和原生 JS 模块加载器，并保存到 env 对象中。</li><li>接着传入 C++ 和原生 JS 模块加载器，执行 run_main_module.js。</li><li>在 run_main_module.js 中传入普通 JS 和原生 JS 模块加载器，执行用户的 JS。</li></ol><p>假设用户 JS 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./myModule&#x27;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>)</span><br></pre></td></tr></table></figure><p>代码中分别加载了一个用户模块和原生 JS 模块，我们看看加载过程，执行 require 的时候。</p><ol><li>Node.js 首先会判断是否是原生 JS 模块，如果不是则直接加载用户模块，否则，会使用原生模块加载器加载原生 JS 模块。</li><li>加载原生 JS 模块的时候，如果用到了 C++ 模块，则使用 internalBinding 去加载。</li></ol><img src="/assets/node-principle/05.png"  /><h4 id="4-执行用户-js-代码然后进入-libuv-事件循环"><a class="markdownIt-Anchor" href="#4-执行用户-js-代码然后进入-libuv-事件循环"></a> 4、执行用户 JS 代码，然后进入 Libuv 事件循环</h4><p>接着 Node.js 就会执行用户的 JS，通常用户的 JS 会给事件循环生产任务，然后就进入了事件循环系统，比如我们 listen 一个服务器的时候，就会在事件循环中新建一个 TCP handle。Node.js 就会在这个事件<br />循环中一直运行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.createServer(<span class="function">() =&gt;</span> &#123;&#125;).listen(<span class="number">80</span>)</span><br></pre></td></tr></table></figure><img src="/assets/node-principle/06.png"  /><h3 id="四-事件循环"><a class="markdownIt-Anchor" href="#四-事件循环"></a> 四、事件循环</h3><p>下面我们看一下事件循环的实现。事件循环主要分为 7 个阶段，timer 阶段主要是处理定时器相关的任务，pending 阶段主要是处理 Poll IO 阶段回调里产生的回调，check、prepare、idle 阶段是自定义的阶段，这三个阶段的任务每次<br />事件序循环都会被执行，Poll IO 阶段主要是处理网络 IO、信号、线程池等等任务，closing 阶段主要是处理关闭的 handle，比如关闭服务器。</p><img src="/assets/node-principle/07.png" width="500" /><ol><li>timer 阶段: 用二叉堆实现，最快过期的在根节点。</li><li>pending 阶段：处理 Poll IO 阶段回调里产生的回调</li><li>check、prepare、idle 阶段：每次事件循环都会被执行。</li><li>Poll IO 阶段：处理文件描述符相关事件。</li><li>closing 阶段：执行调用 uv_close 函数时传入的回调。</li></ol><p>下面我们详细看一下每个阶段的实现。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/375276722">Node.js的底层原理</a></p><p><a href="https://github.com/theanarkh/understand-nodejs">通过源码分析nodejs原理</a></p><p><a href="http://localhost:4000/2021/12/28/node-principle/">[NodeJS源码探秘]之启动全流程</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文的内容主要分为两部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NodeJS 的基础和架构&lt;/li&gt;
&lt;li&gt;NodeJS 核心模块的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;nodejs-的基础和架构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#nodejs-的基础和架构&quot;&gt;&lt;/a&gt; NodeJS 的基础和架构&lt;/h2&gt;
&lt;h3 id=&quot;一-nodejs-的组成&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-nodejs-的组成&quot;&gt;&lt;/a&gt; 一、NodeJS 的组成&lt;/h3&gt;
&lt;p&gt;Node.js 主要由 V8、Libuv 和第三方库组成。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="http://kyleezhang.com/categories/Node/"/>
    
    
    <category term="Node" scheme="http://kyleezhang.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL原理浅析</title>
    <link href="http://kyleezhang.com/2021/09/13/graphql-01/"/>
    <id>http://kyleezhang.com/2021/09/13/graphql-01/</id>
    <published>2021-09-13T23:10:16.000Z</published>
    <updated>2022-06-12T11:24:41.821Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先会从GraphQL规范讲起，先了解GraphQL语言本身，为什么会有这门语言，以及GraphQL规范中核心定义，然后再去了解GraphQL实现，graphql-js是如何解析，校验，执行GraphQL的。</p><h2 id="graphql-规范"><a class="markdownIt-Anchor" href="#graphql-规范"></a> GraphQL 规范</h2><blockquote><p>GraphQL规范是对GraphQL语法的抽象，规范中详细的定义了GraphQL语言的规则，以及GraphQL校验，执行等流程，不同语言的实现都应遵守GraphQL的规范。<a href="https://graphql.github.io/graphql-spec/">https://graphql.github.io/graphql-spec/</a></p></blockquote><a id="more"></a><p>要想了解GraphQL的原理，阅读规范是必不可少的。我们需要了解的所有细节，都定义在GraphQL规范中。规范就像英语的语法，虽然不会影响我们使用这门语言，但当我们需要细致的研究英语文章时，语法总会是一道跨不过去的坎。</p><p>GraphQL规范是会随着发布版本而变化的，就像EcmaScript规范一样，有ES2017，ES2018等，不同的实现可能实现了不同的版本。但GraphQL的实现相对统一，对于JS来说只有graphql-js这一种实现，大家在使用的时候注意一下graphql-js的版本就可以了，可能一些新的特性在旧版本中并没有实现。</p><p>GraphQL规范中主要包含6个部分:</p><ul><li>Language: 语言层，定义了GraphQL查询语法，以及GraphQL的词法单元(Source Text)。</li><li>Type System: 类型系统，定义了GraphQL的基本类型的定义，以及描述查询文档类型的Schema</li><li>Introspection: 内省系统，定义了如何通过特定的类型，获取GraphQL内部的定义(Schema的定义)</li><li>Validation: 校验，定义了GraphQL语法的校验规则</li><li>Execution: 执行，定义了GraphQL是如何执行GraphQL请求文档的</li><li>Response: 响应，定义了GraphQL执行结果返回的数据格式</li></ul><h3 id="一-起源与历史"><a class="markdownIt-Anchor" href="#一-起源与历史"></a> 一、起源与历史</h3><img src="/assets/graphql-01/01.png"><p>在2012年进入了移动网络时代后，Facebook也开始从Web网站转移到Native App，然而旧有的部分接口并不适用于Native的数据展示(接口会直接返回HTML)，以及为了应对快速发展的移动端业务，Facebook的工程师开始重构API接口。在重新设计接口的过程中，他们提出了Client优先的设计思想，以通过思考客户端如何展示数据的角度来设计接口。IOS工程师希望能以对象模型的形式返回数据，并可以将接口返回的JSON映射Naitve的模型当中。为了满足客户端的需求，渐渐提出了具有类型和层次结构的接口语言，也就是GraphQL的雏形。</p><p>GraphQL最开始只有Query和类型系统等功能，但在工程师上线News Feed的接口并获得成功后，引来了Facebook其他团队的围观，并对GraphQL提出了各种各样的讨论。在不同的讨论之间，GraphQL的Mutation, Subscription, Code Generation, Persistent Query等功能诞生了，在之后还产生了Relay等GraphQL的框架。直到2015年，Facebook的工程师第一次React的会议上公开了GraphQL，但这时GraphQL还只是Facebook内部使用的技术方案，并没有对外发布的计划。但在GraphQL公开以后，社区的呼声很高，都在呼吁能发布公开版本让大家使用。于是Facebook的工程师开始对GraphQL重构，并从内部的业务逻辑中抽离出来，直到发布第一个Preview版本。在发布Preview版本的过程中，还发布了GraphQL语言的实现graphql-js并开源，以及GraphQL的调试工具Graphical。在发布Preview版本后，又对反馈做了些优化和修改，最终于2016年正式发布。</p><h3 id="二-设计理念"><a class="markdownIt-Anchor" href="#二-设计理念"></a> 二、设计理念</h3><p>在了解完GraphQL的历史后，我们在来看GraphQL的设计理念。设计理念直接决定了GraphQL是为了哪些场景而诞生的，以及可以解决什么样的问题。</p><p><strong>Hierarchical 分层</strong> 现在大部分产品开发都涉及到操作视图的分层。为了满足应用结构的层次性，GraphQL查询也是分层构建的，每个查询和其返回使用了相同的形状，这样的方式在描述数据需求上更为直观。<br /><strong>Product‐centric 产品为中心</strong> GraphQL是一种视图需求驱动的语言，因为主要是前端工程师书写它。GraphQL本身从前端工程师的思想和需求出发，再开发了语言和运行时库以满足这些需求。<br /><strong>Strong‐typing 强类型</strong> 每个GraphQL服务器都会构建一个针对应用的类型系统，查询语句就在这个类型系统上下文中执行。对于一个查询语句，GraphQL工具可以在执行以前通过类型系统检查这个查询语句的语法正确性和查询有效性，譬如在开发期，服务器就能保证返回值的形状和特性。<br /><strong>Client‐specified queries</strong> 客户端定制 通过类型系统，GraphQL向客户端通告了自己那些可以被消费的能力。而客户端则专注于如何消费这些能力，其查询语句的粒度是字段级的。在大多数没有GraphQL的CS模型应用中，不同的服务端用不同的脚本和入口决定了返回的数据。而GraphQL查询则会返回客户端要求的数据，不多不少。<br /><strong>Introspective 内省</strong> GraphQL是内省的，一个GraphQL服务器的类型系统必须能用GraphQL语言自身来查询。GraphQL的内省特性使之能成为建造通用工具和客户端库的强大平台。</p><h3 id="三-graphql文档"><a class="markdownIt-Anchor" href="#三-graphql文档"></a> 三、GraphQL文档</h3><p>GraphQL文档描述了客户端发送的查询语句或GraphQL服务可以操作的完整文件(Schema)。GraphQL文档包含了可执行定义和类型定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Document:</span><br><span class="line">    Definition[list]</span><br><span class="line">Defintion:</span><br><span class="line">    ExecutableDefinition</span><br><span class="line">    TypeSystemDefinition</span><br><span class="line">    TypeSystemExtension</span><br><span class="line">ExecutableDefinition:</span><br><span class="line">    OperationDefinition</span><br><span class="line">    FragmentDefinition</span><br></pre></td></tr></table></figure><p>无论是GraphQL请求种的查询文档还是服务端定义的Schema都是GraphQL文档的一种，但对于GraphQL服务来说，只有包含OperationDefinition的文档才是可执行的。所以前端所定义的查询语句也是必须包含OperationDefinition的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OperationDefinition:</span><br><span class="line">    OperationType Name[opt] VariableDefinitions[opt] Directives[opt] SelectionSet</span><br><span class="line">OperationType:</span><br><span class="line">    query | mutation | subscription</span><br></pre></td></tr></table></figure><h3 id="四-graphql类型"><a class="markdownIt-Anchor" href="#四-graphql类型"></a> 四、GraphQL类型</h3><p>GraphQL包含6种基本类型和2种包装类型 (NonNullType, ListType)。包装类型顾名思义是对其他类型的包装，无法单独使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TypeDefinition:</span><br><span class="line">    ScalarTypeDefinition</span><br><span class="line">    ObjectTypeDefinition</span><br><span class="line">    InterfaceTypeDefinition</span><br><span class="line">    UnionTypeDefinition</span><br><span class="line">    EnumTypeDefinition</span><br><span class="line">    InputObjectTypeDefinition</span><br></pre></td></tr></table></figure><ul><li>ScalarType(标量类型)和EnumType(枚举类型)是类型定义中的叶子节点。</li><li>ObjectType(对象类型)是所有类型定义的中间节点。</li><li>UnionType(联合类型)和InterfaceType(接口类型)是抽象类型，会拥有其他类型的子类型</li></ul><h2 id="graphql-实现"><a class="markdownIt-Anchor" href="#graphql-实现"></a> GraphQL 实现</h2><p>GraphQL实现在不同的语言有不同版本的实现，但所有的实现都要遵守GraphQL规范。不同实现中可能的差异在于GraphQL标量类型的转换与校验规则。下面与graphql-js为例，介绍下GraphQL的实现。</p><img src="/assets/graphql-01/02.png"><p>graphql-js主要包含以上7个模块，其中最主要的模块是languange, validation, execution这三个模块，这三个模块是对GraphQL规范的核心实现。</p><h3 id="一-language-语法"><a class="markdownIt-Anchor" href="#一-language-语法"></a> 一、Language 语法</h3><p>语法层包含GraphQL规范中定义的语法实现，其主要工作是将GraphQL文档解析成AST语法树，便于之后的校验与执行。我们以下面的查询语句为例，来介绍解析的整个流程。首先我们会调用graphql-js的parse方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; parse &#125; <span class="keyword">from</span> <span class="string">&#x27;graphql&#x27;</span></span><br><span class="line"><span class="keyword">const</span> queryString = <span class="string">`</span></span><br><span class="line"><span class="string">    query ($needPhone: Boolean!) &#123;</span></span><br><span class="line"><span class="string">      me &#123;</span></span><br><span class="line"><span class="string">        name: nickname </span></span><br><span class="line"><span class="string">        phone @include(if: $needPhone)</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> ast = parse(queryString);</span><br></pre></td></tr></table></figure><p>parse会初始化Parser类，并将字符串转换为Source类型的数据结构，Source数据结构只是对源字符串简单的封装，提供了以字符串中莫个offset开始解析的能力，默认offset是1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;query ($needPhone: Boolean!) &#123;\n  me &#123;\n    name: nickname\n    phone @include(if: $needPhone)\n  &#125;\n&#125;\n&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;GraphQL request&quot;</span>,</span><br><span class="line">  <span class="string">&quot;locationOffset&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;line&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;column&quot;</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化Parser类的同时会调用createLexer创建一个词法分析器，lexer是词法分析的单元，通过匹配特征字符串TokenKind，将源字符串分解成不同的token。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TokenKind = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">  SOF: <span class="string">&#x27;&lt;SOF&gt;&#x27;</span>,</span><br><span class="line">  EOF: <span class="string">&#x27;&lt;EOF&gt;&#x27;</span>,</span><br><span class="line">  BANG: <span class="string">&#x27;!&#x27;</span>,</span><br><span class="line">  DOLLAR: <span class="string">&#x27;$&#x27;</span>,</span><br><span class="line">  AMP: <span class="string">&#x27;&amp;&#x27;</span>,</span><br><span class="line">  PAREN_L: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">  PAREN_R: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">  SPREAD: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  COLON: <span class="string">&#x27;:&#x27;</span>,</span><br><span class="line">  EQUALS: <span class="string">&#x27;=&#x27;</span>,</span><br><span class="line">  AT: <span class="string">&#x27;@&#x27;</span>,</span><br><span class="line">  BRACKET_L: <span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">  BRACKET_R: <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">  BRACE_L: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">  PIPE: <span class="string">&#x27;|&#x27;</span>,</span><br><span class="line">  BRACE_R: <span class="string">&#x27;&#125;&#x27;</span>,</span><br><span class="line">  NAME: <span class="string">&#x27;Name&#x27;</span>,</span><br><span class="line">  INT: <span class="string">&#x27;Int&#x27;</span>,</span><br><span class="line">  FLOAT: <span class="string">&#x27;Float&#x27;</span>,</span><br><span class="line">  STRING: <span class="string">&#x27;String&#x27;</span>,</span><br><span class="line">  BLOCK_STRING: <span class="string">&#x27;BlockString&#x27;</span>,</span><br><span class="line">  COMMENT: <span class="string">&#x27;Comment&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>这些Token单元都是GraphQL规范中定义的，有兴趣的同学可以阅读规范中的对应章节。<a href="https://graphql.github.io/graphql-spec/draft/#sec-Source-Text">https://graphql.github.io/graphql-spec/draft/#sec-Source-Text</a></p></blockquote><img src="/assets/graphql-01/03.png"><blockquote><p>在词法分析的过程中，会跳过GraphQL规范中定义空白符。同时除了上图中的三种分词判断还有STRING，BLOCK_STRING，COMMENT等类型。</p></blockquote><p>Parser会从开始先从lexer去获取第一个token，然后token的类型递归的调用不同的parser方法去解析并在不同的parser方法中不断的调用lexer获取token，直到获取到最后一个token，返回解析后的AST对象。</p><img src="/assets/graphql-01/04.png"><blockquote><p>上面的流程图并没有画完，因为parser解析的分支非常多，要对每个可能出现的语法都要做处理。</p></blockquote><p>对于我们上面所举例的查询语句，会有如下的解析流程。</p><ol><li>获取到第一个NAME类型的token，</li><li>调用parseDefinition，判断token的值为Query</li><li>调用parseOperationDefinition，获取下一个token</li><li>判断token为&quot;(&quot;，调用parseVaribaleDefinitions</li><li>获取下一个token为&quot;$&quot;，调用parseVariable</li><li>…</li></ol><p>最后会生成如下的AST对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Document&quot;</span>,</span><br><span class="line">  <span class="string">&quot;definitions&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;OperationDefinition&quot;</span>,</span><br><span class="line">      <span class="string">&quot;operation&quot;</span>: <span class="string">&quot;query&quot;</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Name&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;getUser&quot;</span>,</span><br><span class="line">        <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">11</span>, <span class="string">&quot;end&quot;</span>: <span class="number">18</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;variableDefinitions&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;VariableDefinition&quot;</span>,</span><br><span class="line">          <span class="string">&quot;variable&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Variable&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Name&quot;</span>,</span><br><span class="line">              <span class="string">&quot;value&quot;</span>: <span class="string">&quot;needPhone&quot;</span>,</span><br><span class="line">              <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">21</span>, <span class="string">&quot;end&quot;</span>: <span class="number">30</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">20</span>, <span class="string">&quot;end&quot;</span>: <span class="number">30</span> &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;NonNullType&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;NamedType&quot;</span>,</span><br><span class="line">              <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Name&quot;</span>,</span><br><span class="line">                <span class="string">&quot;value&quot;</span>: <span class="string">&quot;Boolean&quot;</span>,</span><br><span class="line">                <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">32</span>, <span class="string">&quot;end&quot;</span>: <span class="number">39</span> &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">32</span>, <span class="string">&quot;end&quot;</span>: <span class="number">39</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">32</span>, <span class="string">&quot;end&quot;</span>: <span class="number">40</span> &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;directives&quot;</span>: [],</span><br><span class="line">          <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">20</span>, <span class="string">&quot;end&quot;</span>: <span class="number">40</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;directives&quot;</span>: [],</span><br><span class="line">      <span class="string">&quot;selectionSet&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;SelectionSet&quot;</span>,</span><br><span class="line">        <span class="string">&quot;selections&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Field&quot;</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Name&quot;</span>,</span><br><span class="line">              <span class="string">&quot;value&quot;</span>: <span class="string">&quot;me&quot;</span>,</span><br><span class="line">              <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">52</span>, <span class="string">&quot;end&quot;</span>: <span class="number">54</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;arguments&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;directives&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;selectionSet&quot;</span>: &#123;</span><br><span class="line">              <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;SelectionSet&quot;</span>,</span><br><span class="line">              <span class="string">&quot;selections&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Field&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;alias&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Name&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">69</span>, <span class="string">&quot;end&quot;</span>: <span class="number">73</span> &#125;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Name&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;nickname&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">75</span>, <span class="string">&quot;end&quot;</span>: <span class="number">83</span> &#125;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="string">&quot;arguments&quot;</span>: [],</span><br><span class="line">                  <span class="string">&quot;directives&quot;</span>: [],</span><br><span class="line">                  <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">69</span>, <span class="string">&quot;end&quot;</span>: <span class="number">83</span> &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Field&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Name&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;value&quot;</span>: <span class="string">&quot;phone&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">96</span>, <span class="string">&quot;end&quot;</span>: <span class="number">101</span> &#125;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  <span class="string">&quot;arguments&quot;</span>: [],</span><br><span class="line">                  <span class="string">&quot;directives&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Directive&quot;</span>,</span><br><span class="line">                      <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Name&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;include&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">103</span>, <span class="string">&quot;end&quot;</span>: <span class="number">110</span> &#125;</span><br><span class="line">                      &#125;,</span><br><span class="line">                      <span class="string">&quot;arguments&quot;</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Argument&quot;</span>,</span><br><span class="line">                          <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Name&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;value&quot;</span>: <span class="string">&quot;if&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">111</span>, <span class="string">&quot;end&quot;</span>: <span class="number">113</span> &#125;</span><br><span class="line">                          &#125;,</span><br><span class="line">                          <span class="string">&quot;value&quot;</span>: &#123;</span><br><span class="line">                            <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Variable&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">                              <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;Name&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;value&quot;</span>: <span class="string">&quot;needPhone&quot;</span>,</span><br><span class="line">                              <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">116</span>, <span class="string">&quot;end&quot;</span>: <span class="number">125</span> &#125;</span><br><span class="line">                            &#125;,</span><br><span class="line">                            <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">115</span>, <span class="string">&quot;end&quot;</span>: <span class="number">125</span> &#125;</span><br><span class="line">                          &#125;,</span><br><span class="line">                          <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">111</span>, <span class="string">&quot;end&quot;</span>: <span class="number">125</span> &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      ],</span><br><span class="line">                      <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">102</span>, <span class="string">&quot;end&quot;</span>: <span class="number">126</span> &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  ],</span><br><span class="line">                  <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">96</span>, <span class="string">&quot;end&quot;</span>: <span class="number">126</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ],</span><br><span class="line">              <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">55</span>, <span class="string">&quot;end&quot;</span>: <span class="number">136</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">52</span>, <span class="string">&quot;end&quot;</span>: <span class="number">136</span> &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">42</span>, <span class="string">&quot;end&quot;</span>: <span class="number">142</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">5</span>, <span class="string">&quot;end&quot;</span>: <span class="number">142</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;loc&quot;</span>: &#123; <span class="string">&quot;start&quot;</span>: <span class="number">0</span>, <span class="string">&quot;end&quot;</span>: <span class="number">143</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-validate-验证"><a class="markdownIt-Anchor" href="#二-validate-验证"></a> 二、Validate 验证</h3><p>GraphQL验证是对解析后的AST进行规则检查的过程，验证不仅会检测语法上的错误，也会检查查询文档，在GraphQL Schema的上下文中是否有歧义或错误。验证需要客户端请求的文档以及GraphQL Schema两个参数，通过深度优先遍历Document的AST对象，对规则中指定的每一个类型进行校验。</p><blockquote><p>graphql-js默认会执行GraphQL规范中定义的所有检测，相关规则可以阅读规范https://graphql.github.io/graphql-spec/draft/#sec-Validation，规范中对与每个检验规则都给出了详细示例。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> specifiedRules = <span class="built_in">Object</span>.freeze([</span><br><span class="line">  ExecutableDefinitions,</span><br><span class="line">  UniqueOperationNames,</span><br><span class="line">  LoneAnonymousOperation,</span><br><span class="line">  SingleFieldSubscriptions,</span><br><span class="line">  ......</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>其中每个规则都实现了ASTVisitor函数，在深度优先遍历的时候每个节点若实现了对应的方法，将会被执行，如果有错误会保存在透传给所有规则检验函数的context中，当遍历完所有节点后，会返回一个error数组。</p><img src="/assets/graphql-01/04.png"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> editedAST = visit(ast, &#123;</span><br><span class="line">  <span class="function"><span class="title">enter</span>(<span class="params">node, key, parent, path, ancestors</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// @return</span></span><br><span class="line">    <span class="comment">//   undefined: no action</span></span><br><span class="line">    <span class="comment">//   false: skip visiting this node</span></span><br><span class="line">    <span class="comment">//   visitor.BREAK: stop visiting altogether</span></span><br><span class="line">    <span class="comment">//   null: delete this node</span></span><br><span class="line">    <span class="comment">//   any value: replace this node with the returned value</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">leave</span>(<span class="params">node, key, parent, path, ancestors</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// @return</span></span><br><span class="line">    <span class="comment">//   undefined: no action</span></span><br><span class="line">    <span class="comment">//   false: no action</span></span><br><span class="line">    <span class="comment">//   visitor.BREAK: stop visiting altogether</span></span><br><span class="line">    <span class="comment">//   null: delete this node</span></span><br><span class="line">    <span class="comment">//   any value: replace this node with the returned value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所有的规则都通过visit方法去校验AST的每个节点，visit方法还可以指定对某一个AST节点类型进行遍历，只有遍历到某个AST节点时才会触发enter方法和leave方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; visit &#125; = <span class="built_in">require</span>(<span class="string">&quot;graphql/language/visitor&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; parse &#125; = <span class="built_in">require</span>(<span class="string">&quot;graphql/language&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> query = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">    viewer &#123;</span></span><br><span class="line"><span class="string">      username @skip(if: true)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"> &#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indent = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> visitor = &#123;</span><br><span class="line">    <span class="function"><span class="title">enter</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`visitor      - <span class="subst">$&#123;indent&#125;</span>Enter <span class="subst">$&#123;node.kind&#125;</span>`</span>);</span><br><span class="line">        indent = indent + <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">leave</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">        indent = indent.substring(<span class="number">0</span>, indent.length - <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`visitor      - <span class="subst">$&#123;indent&#125;</span>Leave <span class="subst">$&#123;node.kind&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    Field: &#123;</span><br><span class="line">        <span class="function"><span class="title">enter</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`visitorField - <span class="subst">$&#123;indent&#125;</span>Enter <span class="subst">$&#123;node.kind&#125;</span>`</span>);</span><br><span class="line">            indent = indent + <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">leave</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">            indent = indent.substring(<span class="number">0</span>, indent.length - <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`visitorField - <span class="subst">$&#123;indent&#125;</span>Leave <span class="subst">$&#123;node.kind&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">visit(parse(query), visitor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// visitor      - Enter Document</span></span><br><span class="line"><span class="comment">// visitor      -   Enter OperationDefinition</span></span><br><span class="line"><span class="comment">// visitor      -     Enter SelectionSet</span></span><br><span class="line"><span class="comment">// visitorField -       Enter Field</span></span><br><span class="line"><span class="comment">// visitor      -         Enter Name</span></span><br><span class="line"><span class="comment">// visitor      -         Leave Name</span></span><br><span class="line"><span class="comment">// visitor      -         Enter SelectionSet</span></span><br><span class="line"><span class="comment">// visitorField -           Enter Field</span></span><br><span class="line"><span class="comment">// visitor      -             Enter Name</span></span><br><span class="line"><span class="comment">// visitor      -             Leave Name</span></span><br><span class="line"><span class="comment">// visitor      -             Enter Directive</span></span><br><span class="line"><span class="comment">// visitor      -               Enter Name</span></span><br><span class="line"><span class="comment">// visitor      -               Leave Name</span></span><br><span class="line"><span class="comment">// visitor      -               Enter Argument</span></span><br><span class="line"><span class="comment">// visitor      -                 Enter Name</span></span><br><span class="line"><span class="comment">// visitor      -                 Leave Name</span></span><br><span class="line"><span class="comment">// visitor      -                 Enter BooleanValue</span></span><br><span class="line"><span class="comment">// visitor      -                 Leave BooleanValue</span></span><br><span class="line"><span class="comment">// visitor      -               Leave Argument</span></span><br><span class="line"><span class="comment">// visitor      -             Leave Directive</span></span><br><span class="line"><span class="comment">// visitorField -           Leave Field</span></span><br><span class="line"><span class="comment">// visitor      -         Leave SelectionSet</span></span><br><span class="line"><span class="comment">// visitorField -       Leave Field</span></span><br><span class="line"><span class="comment">// visitor      -     Leave SelectionSet</span></span><br><span class="line"><span class="comment">// visitor      -   Leave OperationDefinition</span></span><br><span class="line"><span class="comment">// visitor      - Leave Document</span></span><br></pre></td></tr></table></figure><h3 id="三-execution-执行"><a class="markdownIt-Anchor" href="#三-execution-执行"></a> 三、Execution 执行</h3><p>GraphQL通过执行来从请求生成响应。要执行请求，执行器必须接收两个参数，解析过的Document文档，以及GraphQL Schema。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;parse, buildASTSchema, execute&#125; = <span class="built_in">require</span>(<span class="string">&quot;graphql&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="string">`type Query &#123;</span></span><br><span class="line"><span class="string">    name: String</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> query = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">    name</span></span><br><span class="line"><span class="string">&#125;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> typeDocument = buildASTSchema(parse(schema));</span><br><span class="line"><span class="comment">// 增加resolver</span></span><br><span class="line">typeDocument.getType(<span class="string">&#x27;Query&#x27;</span>).getFields().name.resolve = resolve</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = execute(typeDocument, parse(query));</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// &#123; data: &#123; name: &#x27;Hello World&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>GraphQL执行的过程其实就是执行resolver的过程，Document请求的所有field的resolver都会被执行。如果field没有设置resolver，那将会执行默认的resolver，整个执行流程如下。</p><img src="/assets/graphql-01/06.png"><ol><li>GraphQL执行首先会生成执行Context，执行Context包含传给execute的原始参数，以及默认的fieldResolver。在整个执行过程中，共用一份Context。</li><li>判断Operation的类型，如果是Mutation则顺序执行resolveField，否则并行执行resolveField。对于Mutation的顺序执行，保证了请求的幂等性。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    first: <span class="function"><span class="title">changeTheNumber</span>(<span class="params">newNumber: <span class="number">1</span></span>)</span> &#123; </span><br><span class="line">       theNumber </span><br><span class="line">    &#125;  </span><br><span class="line">    second: <span class="function"><span class="title">changeTheNumber</span>(<span class="params">newNumber: <span class="number">3</span></span>)</span> &#123;  </span><br><span class="line">       theNumber </span><br><span class="line">    &#125;  </span><br><span class="line">    third: <span class="function"><span class="title">changeTheNumber</span>(<span class="params">newNumber: <span class="number">2</span></span>)</span> &#123;   </span><br><span class="line">       theNumber  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>对当前节点的field执行resolveField，如果存在field.resolver执行resolver，否则执行默认resolver。</li><li>调用completeValue，对当前field的返回类型进行判断，</li><li>如果返回值是null或undefined，直接返回，不再执行resolver</li><li>如果是叶子节点类型(Scalar | Enum)，调用Scalar的serialize方法进行序列化，并返回结果</li><li>如果是List类型，遍历返回值中的每个元素，并递归执行completeValue</li><li>如果是Object类型，对Object的所有子选择集执行resolveField</li><li>如果是抽象类型(Union | Interface)，确定运行时类型，并执行该类型</li><li>最后调用buildResponse，返回结果</li></ol><h2 id="graphql-schema"><a class="markdownIt-Anchor" href="#graphql-schema"></a> GraphQL Schema</h2><p>定义一个GraphQL服务首先要生成GraphQL的Schema，Schema描述了GraphQL服务可以提供哪些接口，以及哪些查询参数。目前有两种方式去定义Schema。 第一种是通过SDL的形式来定义，通常被成为SDL-First或者Schema-First，这种定义方式是以字符串的形式来定义Schema的，可以是graphql的文件，或者直接是代码中定义的字符串。这种的好处就是清晰直观，有很强的可读性和可维护性，但缺少一定的灵活性。因为在Schema定义中没有像查询语句的Fragment，对于类型的复用有些困难，同时Resolver的定义和Schema的定义可能是分离的，我们需要手动连接连接Resolver(虽然有现成的工具帮我们做好了)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// graphql/shema.graphql</span></span><br><span class="line">type User &#123;</span><br><span class="line">    name: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">    users: [User!]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// graphql/resolver.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    Query: <span class="function">(<span class="params">_, args, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.db.findUsers()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// graphql/index.js</span></span><br><span class="line"><span class="keyword">const</span> makeExecutableSchema = <span class="built_in">require</span>(<span class="string">&#x27;graphql-tools&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> schema = fs.readFileSync(<span class="string">&#x27;./schema.graphql&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> resolvers = <span class="built_in">require</span>(<span class="string">&#x27;./resolver&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GraphQLSchema = makeExecutableSchema(&#123;<span class="attr">typeDef</span>: schema, resolvers&#125;)</span><br></pre></td></tr></table></figure><p>第二种是通过代码的形式来定义，通常被称为Code-First或者Resolver-First，这种方式直接用graphql-js的对应函数去生成Schema，优势是灵活性很高，Resolver也直接定义在Schema中，但缺点也很明显，代码量多，逻辑不清晰直观。通常只有在需要高度定制，或者动态生成某些类型的时候才使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">schema.js</span><br><span class="line"><span class="keyword">const</span> UserType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">&#x27;User&#x27;</span>,</span><br><span class="line">    fileds: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        name: &#123;<span class="attr">type</span>: GraphQLString&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> QueryType = <span class="keyword">new</span> GraphQLObjectType(&#123;</span><br><span class="line">    name: <span class="string">&#x27;Query&#x27;</span>,</span><br><span class="line">    fileds: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        users: &#123;</span><br><span class="line">            type: <span class="keyword">new</span> GraphQLList(<span class="keyword">new</span> GraphQLNonNull(UserType))</span><br><span class="line">            resolve: <span class="function">(<span class="params">_, args, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ctx.db.findUsers()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GraphQLSchema = <span class="keyword">new</span> GraphQLSchema(&#123;<span class="attr">query</span>: QueryType&#125;);</span><br></pre></td></tr></table></figure><p>使用代码生成的Schema其实就是GraphQL校验，执行中用到的Schema。使用SDL定义的Schema最终也要生成GraphQLSchema这个函数的实例。最近TS开始流行，其实除了这两种定义的方式，还有了第三种方式，就是使用TypeGraphQL，这种方式结合了SDL和代码定义的优势，不仅有较好可读性，也提供了一定的灵活性。而且提供了TS类型，这是目前通过SDL或者代码都很难做到的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@ObjectType()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    @Field()</span><br><span class="line">    name: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Resolver(User)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserResolver</span> </span>&#123;</span><br><span class="line">    @Query(<span class="function"><span class="params">returns</span> =&gt;</span> [User])</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">users</span>(<span class="params">@Ctx() ctx: Context</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.db.findUsers()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">await</span> buildSchema(&#123;  <span class="attr">resolvers</span>: [UserResolver]&#125;);</span><br></pre></td></tr></table></figure><h2 id="graphql-请求"><a class="markdownIt-Anchor" href="#graphql-请求"></a> GraphQL 请求</h2><p>我们都知道GraphQL请求要定义查询语句，只有包含查询语句的请求才是GraphQL请求，但实际上GraphQL规范中并没有明确定义Client端发出的请求是什么样的，可以POST请求，可以GET请求，请求的参数也可以是任意的，我们来看几个生产环境中使用GraphQL的例子。</p><h3 id="一-instagram-的-graphql-接口"><a class="markdownIt-Anchor" href="#一-instagram-的-graphql-接口"></a> 一、Instagram 的 GraphQL 接口</h3><img src="/assets/graphql-01/07.png"><h3 id="二-facebook-的-graphql-接口"><a class="markdownIt-Anchor" href="#二-facebook-的-graphql-接口"></a> 二、Facebook 的 GraphQL 接口</h3><img src="/assets/graphql-01/08.png"><h3 id="三-特效开发平台的graphql接口"><a class="markdownIt-Anchor" href="#三-特效开发平台的graphql接口"></a> 三、特效开发平台的GraphQL接口</h3><img src="/assets/graphql-01/09.png"><p>我们看到只有第3个请求是我们常见的GraphQL请求，这也是Apollo Client默认发出的请求格式。但实际上这种格式在生产环境是有一定风险的，对于网络请求我们应该尽量使用不透明的参数。将整个查询语句完全暴露给客户端就相当于公开出了我们的schema，那攻击者就可能猜测出查询语句的字段，如果服务端没有对相应字段做鉴权，那就可能返回不应该返回的数据。所以像Facebook等公司在生产环境都使用了一个不透明的hashKey来代替查询语句。服务端应当只接收可控的hashKey来返回请求。</p><p>使用hashKey的另一个好处就是可以减少请求体的长度，众所周知GraphQL的查询语句非常长，如果是复杂的查询，那将极大的增加请求体的大小，而且查询语句一般是要打在前端的bundle中，也会增加bundle的大小，使用hashkey来代替查询语句可以增加请求的性能。在Apollo Server中提供了persisted queries的功能，来支持将查询语句转换为hashKey。Apollo Server中默认的GraphQL请求都是POST请求，但POST请求不利于CDN缓存，persisted queries的另一个功能是支持GET请求，在GET请求中只传递hashKey和variable，以便于做CDN缓存。</p><img src="/assets/graphql-01/10.png">]]></content>
    
    
    <summary type="html">&lt;p&gt;本文首先会从GraphQL规范讲起，先了解GraphQL语言本身，为什么会有这门语言，以及GraphQL规范中核心定义，然后再去了解GraphQL实现，graphql-js是如何解析，校验，执行GraphQL的。&lt;/p&gt;
&lt;h2 id=&quot;graphql-规范&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#graphql-规范&quot;&gt;&lt;/a&gt; GraphQL 规范&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;GraphQL规范是对GraphQL语法的抽象，规范中详细的定义了GraphQL语言的规则，以及GraphQL校验，执行等流程，不同语言的实现都应遵守GraphQL的规范。&lt;a href=&quot;https://graphql.github.io/graphql-spec/&quot;&gt;https://graphql.github.io/graphql-spec/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Node" scheme="http://kyleezhang.com/categories/Node/"/>
    
    
    <category term="Node" scheme="http://kyleezhang.com/tags/Node/"/>
    
    <category term="GraphQL" scheme="http://kyleezhang.com/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出NodeJS》读书笔记（二）</title>
    <link href="http://kyleezhang.com/2021/09/10/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS-02/"/>
    <id>http://kyleezhang.com/2021/09/10/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS-02/</id>
    <published>2021-09-10T08:13:07.000Z</published>
    <updated>2022-06-12T11:24:41.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="七-网络编程"><a class="markdownIt-Anchor" href="#七-网络编程"></a> 七、网络编程</h2><h3 id="1-构建-tcp-服务"><a class="markdownIt-Anchor" href="#1-构建-tcp-服务"></a> 1、构建 TCP 服务</h3><p>TCP 全名传输控制协议，在 OSI 模型中属于传输层协议。具体如下图所示：</p><img src="/assets/深入浅出NodeJS/12.png"><p>TCP 是面向连接的协议，其显著的特征是在传输之前需要 3 次握手形成会话，只有会话形成后，服务端和客户端之间才能互相发送数据。在创建会话的过程中，服务器端和客户端分别提供一个套接字，这两个套接字共同形成一个连接。服务器端与客户端则通过套接字实现两者之间的连接操作。</p><h4 id="1创建-tcp-服务器端"><a class="markdownIt-Anchor" href="#1创建-tcp-服务器端"></a> (1)创建 TCP 服务器端</h4><p>我们可以通过 net.createServer(listener) 即可创建一个 TCP 服务器，listener 是连接事件 connection 的侦听器，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">    socket.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        socket.write(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;连接断开&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.write(<span class="string">&quot;欢迎光临《深入浅出NodeJS》&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8124</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;server bound&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们可以利用 Telnet 工具作为客户端与服务器进行会话交流:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telent 127.0.0.1 8124</span><br></pre></td></tr></table></figure><p>除了端口外我们也可以对 Domain Socket 进行监听：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.listen(<span class="string">&#x27;tmp/echo.sock&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Domain Socket 我们可以通过 nc 工具进行会话测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -U /tem/echo.sock</span><br></pre></td></tr></table></figure><p>除了使用上述工具外我们还可以自己创建客户端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = net.connect(&#123; <span class="attr">port</span>: <span class="number">8124</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;client connected&#x27;</span>);</span><br><span class="line">    client.write(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">    client.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;client disconnected&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行上述客户端代码文件与使用 Telnet 和 nc 的会话结果别无差别，如果是 Domain Socket 在填写选项时，填写 path 即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = net.connect(&#123; <span class="attr">path</span>: <span class="string">&#x27;/tmp/echo.sock&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><h4 id="2tcp-服务的事件"><a class="markdownIt-Anchor" href="#2tcp-服务的事件"></a> (2)TCP 服务的事件</h4><p><strong>服务器事件</strong></p><p>对于通过 net.createServer() 创建的服务器而言，它是一个 EventEmitter 实例，它的自定义事件有如下几种。</p><ul><li>listening：在调用 server.listen() 绑定端口或者 Domain Socket 后触发，简洁的写法为 server.listen(port, listeningListener)，通过 listen 方法的第二个参数传入。</li><li>connection：每个客户端套接字连接到服务器端时触发，简洁的写法为通过 net.createServer()，最后一个参数传递。</li><li>close：当服务器关闭时触发，在调用 server.close() 后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后会触发该事件。</li><li>error：当服务器发生异常时，将会触发该事件。</li></ul><p><strong>连接事件</strong></p><p>服务器可以同时与多个客户端保持连接，每个连接都是典型的可写可读的 Stream 对象，它具有如下自定义事件：</p><ul><li>data：当一端调用 write() 发送数据时，另一端会触发 data 事件，事件传递的数据即是 write() 发送的数据。</li><li>end：当连接中的任意一端发送了 FIN 数据时将会触发该事件。</li><li>connect：该事件用于客户端，当套接字与服务器端连接成功时会触发该事件。</li><li>drain：当任意一段调用 write() 发送数据时，当前这端会触发该事件。</li><li>error：当异常发生时，触发该事件。</li><li>close： 当套接字完全关闭时，触发该事件。</li><li>timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知该用户连接已经被闲置了。</li></ul><h3 id="2-构建-udp-服务"><a class="markdownIt-Anchor" href="#2-构建-udp-服务"></a> 2、构建 UDP 服务</h3><p>UDP 又称用户数据包协议，提供面向事务的简单不可靠信息传输服务，与 TCP 一样同属于网络传输层。其与 TCP 最大的不同在于 UDP 不是面向连接的。TCP 中连接一旦建立所有的会话都基于连接完成，客户端如果要与另一个服务端通信必须新建一个套接字来完成连接。但在 UDP 中一个套接字可以与多个 UDP 服务通信。</p><h4 id="1创建-udp-服务器端"><a class="markdownIt-Anchor" href="#1创建-udp-服务器端"></a> (1)创建 UDP 服务器端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = dgram.createSocket(<span class="string">&quot;udp4&quot;</span>)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg, rinfo</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;server got:&quot;</span> + msg + <span class="string">&quot;from&quot;</span> + rinfo.address + <span class="string">&quot;:&quot;</span> + rinfo.port)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;lessoning&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> address = server.address</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;server listening&quot;</span> + <span class="string">&quot;:&quot;</span> + address.port)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.bind(<span class="number">41234</span>)</span><br></pre></td></tr></table></figure><p>如上述示例所示，创建 UDP 服务端的核心在于创建 UDP 套接字，UDP 套接字一旦创建既可以作为客户端发送数据，也可以作为服务器端接收数据。想要让 UDP 套接字接收网络信息只需要调用 <code>dgram.bind(port, [address])</code> 方法对网卡和端口进行绑定即可。</p><h4 id="2创建-udp-客户端"><a class="markdownIt-Anchor" href="#2创建-udp-客户端"></a> (2)创建 UDP 客户端</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">&quot;dgram&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> Buffer(<span class="string">&quot;深入浅出NodeJS&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> client = dgram.createSocket(<span class="string">&quot;udp4&quot;</span>)</span><br><span class="line">client.send(message, <span class="number">0</span>, message.length, <span class="number">41234</span>, <span class="string">&quot;localhost&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, bytes</span>) </span>&#123;</span><br><span class="line">    client.close()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当使用套接字作为客户端时可以调用 send 方法发送消息到网络中，send 方法的参数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.send(buf, offset, length, port, address, [callback])</span><br></pre></td></tr></table></figure><p>与 TCP 连接的 write 方法相比 send 方法的参数列表要复杂的多，但是它更灵活的地方在于可以随意发送数据到网络中的服务器端。</p><h4 id="3udp套接字事件"><a class="markdownIt-Anchor" href="#3udp套接字事件"></a> (3)UDP套接字事件</h4><p>UDP 的套接字与 TCP 的不同，它只是 EventEmitter 实例，而非 Stream 实例，它具备如下自定义事件：</p><ul><li>message: 当 UDP 套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的事件为消息 Buffer 对象和一个远程地址信息。</li><li>listening: 当 UDP 套接字开始侦听时触发该事件。</li><li>close: 调用 close 方法时触发该事件，并不再触发 message 事件，如需再次触发 message 事件重新绑定即可。</li><li>error: 当异常发生时触发该事件，如果不侦听异常抛出，使进程退出。</li></ul><h3 id="3-构建-http-服务"><a class="markdownIt-Anchor" href="#3-构建-http-服务"></a> 3、构建 HTTP 服务</h3><p>HTTP 的全称是超文本传输协议，HTTP 构建于 TCP 之上，属于应用层协议。从协议的角度来说现在的应用如浏览器，其实是一个 HTTP 的代理，用户的行为将会转化为 HTTP 报文发送给服务器端。服务器端在处理请求后，发送响应报文给代理，因此 HTTP 服务只做两件事：处理 HTTP 请求和发送 HTTP 响应。</p><h4 id="1http-模块"><a class="markdownIt-Anchor" href="#1http-模块"></a> (1)http 模块</h4><p>Node 的 http 模块包含了对于 HTTP 处理的封装。在 Node 中 HTTP 服务继承自 TCP 服务器（net 模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP 服务与 TCP 服务有区别的地方在于，在开启了 keep-alive 之后，一个 TCP 会话可以用于多次请求和响应。TCP 以 connection 为单位进行服务，HTTP 服务以 request 为单位进行服务，http 模块是将 connection 到 request 的过程进行了封装。</p><p>除此之外，http 模块将连接所用的套接字读写抽象为 ServerRequest 和 ServerResponse 对象，它们分别对应请求和响应操作。在请求产生的过程中，http 模块拿到连接中传来的数据，调用二进制模块 http_parser 进行解析，在解析完请求报文的报头后，触发 request 事件，调用用户的业务逻辑，流程如下图所示：</p><img src="/assets/深入浅出NodeJS/13.png"><p><strong>http 请求</strong></p><p>对于 TCP 连接的读操作，http 模块将其封装为 ServerRequest 对象。请求报文通过 http_parser 进行解析，报文头被解析为如下部分：</p><ul><li>req.method 属性: 标识请求方法，常见的请求方法有 GET、POST、DELETE等。</li><li>req.url 属性: 请求 url 路径</li><li>req.httpVersion属性: 请求的 http 版本，通常为 1.1</li><li>其余报头被解析为很规律的 <code>Key: Value</code> 格式，被解析后放置在 req.headers属性上</li></ul><p>报文体部分则被抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能进行操作，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buffers = [];</span><br><span class="line">    req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">trunk</span>) </span>&#123;</span><br><span class="line">        buffers.push(trunk)</span><br><span class="line">    &#125;).on (<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> buf = Buffer.concat(buffers);</span><br><span class="line">        res.end(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>http 响应</strong></p><p>HTTP 响应相对简单一些，它封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部信息的 API 为 res.setHeader() 和 res.writeHeader()。可以调用 setHeader 进行多次设置，但只有调用了 writeHeader 后，报头才会写入到连接中，除此之外，http 模块会自动帮你设置一些头信息，如Date、Connection 等。</p><p>报文体部分则是调用 res.write() 和 res.end() 方法实现，后者与前者的区别在于 res.end() 会先调用 write() 发送数据，然后发送信号告知服务器这次响应结束。</p><p><strong>http 服务的事件</strong></p><p>HTTP 服务器也是 EventEmitter 的实例，实现的自定义事件列表如下所示：</p><ul><li>connection 事件: 在开始 HTTP 请求和响应前，客户端与服务端需要建立底层的 TCP 连接，这个连接可能因为开启了 keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次 conection 事件。</li><li>request 事件: 建立 TCP 连接后，http 模块底层将在数据流中抽象出 HTTP 请求和 HTTP 响应，当请求数据发送到服务器端，在解析出 HTTP 请求头后，将会触发该事件；在 res.end() 后，TCP 连接可能将用于下次请求响应。</li><li>data 事件: 与 TCP 服务器的行为一致，调用 server.close() 方法停止接受新的连接，当已有的连接都断开时触发该事件。</li><li>checkContinue 事件: 某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部为带 <code>Except：100-continue</code> 的请求到服务器，服务器将会触发 checkContinue 事件；如果没有为服务监听这个事件，服务器将会自动响应客户端 100 Continue 状态码，表示接受数据上传；如果不接受较多的数据时，响应客户端 400 Bad Request 拒绝客户端继续发送数据即可。需要注意的是，当该事件发生时不会触发 request 事件，两个事件之间互斥。当客户端收到 100 Continue 后重新发起请求时，才会触发 request 事件。</li><li>connect事件: 当客户端发起 CONNECT 请求时触发，而发起 CONNECT 请求通常在 HTTP 代理时出现；如果不监听该事件，发起该请求的连接将会关闭。</li><li>upgrade 事件: 当客户端要求升级连接的协议时，需要和服务器协商，客户端会在请求头中带上 Upgrade 字段，服务器端会在接收到这样的请求时触发该事件，如果不监听该事件，发起请求的连接将会关闭。</li><li>clientError 事件: 连接的客户端触发 error 事件时，这个错误会传递到服务器端，此时触发该事件。</li></ul><h4 id="2http-客户端"><a class="markdownIt-Anchor" href="#2http-客户端"></a> (2)http 客户端</h4><p>http 模块提供了一个底层 API：<code>http.request(options, connect)</code> 用于构造 HTTP 客户端，其中 options 参数决定了这个 HTTP 请求头中的内容，它的选项有如下这些：</p><ul><li>host: 服务器的域名或 IP 地址，默认 localhost。</li><li>hostname: 服务器名称。</li><li>port: 服务器端口，默认 80。</li><li>localAddress: 建立网络连接的本地网卡</li><li>socketPath: Domain 套接字路径。</li><li>method: HTTP请求方法。默认 GET。</li><li>path: 请求路径，默认为 /。</li><li>headers: 请求头对象。</li><li>auth: Basic 认证，这个值被计算成请求头中的 Authorization 部分。</li></ul><p>报文体的内容由请求对象的 write() 方法和 end() 方法实现：通过 write() 方法向连接中写入数据，通过 end() 方法告知报文结束。它与浏览器中的 Ajax 调用几近相同，Ajax 的实质就是一个异步的网络 HTTP 请求。</p><p><strong>http 响应</strong></p><p>HTTP 客户端的响应对象与服务器端较为类似，在 ClientRequest 对象中，它的事件叫做 response。ClientRequest 在解析响应报文时，一解析完响应头就触发 response 事件，同时传递一个响应对象以供操作 ClientResponse。后续响应报文体以只读流的方式提供。</p><p><strong>http 代理</strong></p><p>如同服务器端的实现一般，http 提供的 ClientRequest 对象也是基于 TCP 层实现的，在 keep-alive 的情况下，一个底层会话连接可以多次用于请求。为了重用 TCP 连接，http 模块包含一个默认的客户端代理对象 http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过 ClientRequest 对象对同一个服务器端发起的 HTTP 请求最多可以创建 5 个连接，其实质上就是一个连接池。</p><p>我们也可以通过自行构造代理对象来对限制数量进行修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> agent = <span class="keyword">new</span> http.agent(&#123;</span><br><span class="line">    maxSockets: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    hostname: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    port: <span class="number">1234</span>,</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    agent: agent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外还可以设置 agent 选项为 false 来脱离连接池的管理，使请求不受并发的限制。</p><p>Agent 对象的 sockets 和 requests 属性分别表示当前连接池中使用中的连接数和处于等待状态的请求数，在业务中监视这两个值有助于发现业务状态的繁忙程度。</p><p><strong>http 客户端事件</strong></p><ul><li>response: 与服务器端的 request 事件对应的客户端在请求发出后得到服务端响应时，会触发该事件。</li><li>socket: 当底层连接池中建立的连接分配给当前请求对象时，触发该事件。</li><li>connect: 当客户端向服务器端发起 Upgrate 请求时，如果服务器端响应了 101 Switching Protocal 状态，客户端将会触发该事件。</li><li>continue: 客户端向服务器端发起 <code>Expect: 100-continue</code> 头信息，以试图发送较大数据量，如果服务器端响应 100 Continue 状态，客户端将触发该事件。</li></ul><h3 id="4-构建-websocket-服务"><a class="markdownIt-Anchor" href="#4-构建-websocket-服务"></a> 4、构建 WebSocket 服务</h3><p>WebSocket 协议与 Node 之间的配合堪称完美，主要有两点：</p><ul><li>WebSocket 客户端基于事件的编程模型与 Node 中自定义事件相差无几。</li><li>WebSocket 实现了客户端与服务器端之间的长连接，而 Node 事件驱动的方式十分擅长与大量客户端保持高并发连接。</li></ul><p>除此之外 WebSocket 相较于 HTTP 还有如下好处：</p><ul><li>客户端与服务器端只建立一个 TCP 连接，可以使用更少的连接。</li><li>WebSocket 服务器端可以推送数据到客户端，这远比 HTTP 请求响应模式更灵活、更高效。</li><li>有更轻量级的协议头，减少数据传送量。</li></ul><p>相比于 HTTP，WebSocket 更接近于传输层协议，它并没有在 HTTP 的基础上模拟服务器端的推送，而是在 TCP 上定义独立的协议，HTTP 协议只是完成了其握手部分。</p><h4 id="1websocket-握手"><a class="markdownIt-Anchor" href="#1websocket-握手"></a> (1)WebSocket 握手</h4><p>客户端建立连接时，通过 HTTP 发起请求报文，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrate: websocket</span><br><span class="line">Connection: Upgrate</span><br><span class="line">Set-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;</span><br><span class="line">Sec-WebScoket-Protocal: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13 </span><br></pre></td></tr></table></figure><p>与普通的 HTTP 请求协议略有区别的部分在于如下协议头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrate: websocket</span><br><span class="line">Connection: Upgrate</span><br></pre></td></tr></table></figure><p>上述字段表示请求服务器端升级协议为 WebSocket。</p><p>Set-WebSocket-Key 的值是随机生成的 Base64 编码的字符串，主要用于安全校验，服务器端接收到之后将其与字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 相连形成字符串 “GhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后通过 sha1 安全散列算法计算出结果后，再进行 Base64 编码，最后返回客户端。</p><p>而 Sec-WebScoket-Protocal 和 Sec-WebSocket-Version 字段主要用于指定子协议和版本号。</p><p>服务端在处理完请求后响应报文如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrate: websocket</span><br><span class="line">Connection: Upgrate</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocal: chat</span><br></pre></td></tr></table></figure><p>上面的报文告知客户端正在更换协议，更新应用层协议为 WebSocket 协议，并在当前的套接字连接上应用新协议。剩余的字段分别表示服务器端基于 Sec-WebSocket-Key 生成的字符串和选中的子协议。客户端将会校验 Sec-WebSocket-Accept 的值，如果成功将开始接下来的传输。</p><p>我们以如下代码进行演示：</p><p>浏览器端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> WebSocket = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 伪代码，解析 ws://127.0.0.1/updates，用于请求</span></span><br><span class="line">    <span class="built_in">this</span>.options = parseUrl(url)</span><br><span class="line">    <span class="built_in">this</span>.connect()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">WebSocket.prototype.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line">WebSocket.prototype.setSocket = <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.socket = socket</span><br><span class="line">&#125;</span><br><span class="line">WebSocket.prototype.connect = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="keyword">new</span> Buffer(<span class="built_in">this</span>.options.protocalVersion + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">Date</span>.now()).toString(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> shasum = crypto.createHash(<span class="string">&#x27;sha1&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> expected = shasum.update(key + <span class="string">&#x27;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#x27;</span>).digest(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">        port: <span class="built_in">this</span>.options.port, <span class="comment">// 12010</span></span><br><span class="line">        host: <span class="built_in">this</span>.options.hostname, <span class="comment">// 127.0.0.1</span></span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;Upgrade&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade&#x27;</span>: <span class="string">&#x27;websocket&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-WebSocket-Version&#x27;</span>: <span class="built_in">this</span>.options.protocalVersion,</span><br><span class="line">            <span class="string">&#x27;Sec-Websocket-Key&#x27;</span>: key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> req = http.request(options);</span><br><span class="line">    req.end();</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">&#x27;upgrade&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res, socket, upgradeHead</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 连接成功</span></span><br><span class="line">        that.setSocket(socket)</span><br><span class="line">        <span class="comment">// 触发 open 事件</span></span><br><span class="line">        <span class="built_in">this</span>.onopen()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;tet/plain&#x27;</span> &#125;);</span><br><span class="line">    res.end(<span class="string">&#x27;Hello World\n&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">12010</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在收到 upgrade 请求后，告知客户端允许切换协议</span></span><br><span class="line">server.on(<span class="string">&#x27;upgrade&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, socket, upgradeHead</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="keyword">new</span> Buffer(upgradeHead.length)</span><br><span class="line">    upgradeHead.copy(head)</span><br><span class="line">    <span class="keyword">var</span> key = req.headers[<span class="string">&#x27;sec-websocket-key&#x27;</span>]</span><br><span class="line">    <span class="keyword">var</span> shasum = crypto.createHash(<span class="string">&#x27;sha1&#x27;</span>)</span><br><span class="line">    key = shasum.update(key + <span class="string">&#x27;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#x27;</span>).digest(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> headers = [</span><br><span class="line">        <span class="string">&#x27;HTTP/1.1 101 Switching Protocols&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Upgrade: websocket&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Connection: Upgrade&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Sec-WebSocket-Accept: &#x27;</span> + key,</span><br><span class="line">        <span class="string">&#x27;Sec-WebSocket-Protocol: &#x27;</span> + protocol</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// 让数据立即发送</span></span><br><span class="line">    socket.setNoDelay(<span class="literal">true</span>)</span><br><span class="line">    socket.write(headers.concat(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>).join(<span class="string">&#x27;\r\n&#x27;</span>));</span><br><span class="line">    <span class="comment">// 建立服务器端 WebSocket 连接</span></span><br><span class="line">    <span class="keyword">var</span> websocket = <span class="keyword">new</span> WebSocket()</span><br><span class="line">    websocket.setSocket(socket)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2数据传输"><a class="markdownIt-Anchor" href="#2数据传输"></a> (2)数据传输</h4><p>在 WebSocket 协议中,数据传输阶段使用 frame（数据帧）进行通信，frame 分不同的类型，主要有：文本数据，二进制数据。出于安全考虑和避免网络截获，客户端发送的数据帧必须进行掩码处理后才能发送到服务器，不论是否是在 TLS 安全协议上都要进行掩码处理。服务器如果没有收到掩码处理的数据帧时应该关闭连接，发送一个 1002 的状态码。服务器不能将发送到客户端的数据进行掩码处理，如果客户端收到掩码处理的数据帧必须关闭连接。</p><p>那我们服务器端接收到的数据帧是怎样的呢？</p><img src="/assets/深入浅出NodeJS/14.png"><p><strong>数据帧</strong></p><p>WebSocket 的数据传输是要遵循特定的数据格式-数据帧（frame）</p><img src="/assets/深入浅出NodeJS/15.png"><p>每一列代表一个字节，一个字节8位，每一位又代表一个二进制数。</p><ul><li>fin: 标识这一帧数据是否是该分块的最后一帧。<ul><li>1 为最后一帧</li><li>0 不是最后一帧。需要分为多个帧传输</li></ul></li><li>rsv1-3: 默认为0，接收协商扩展定义为非0设定。</li><li>opcode： 操作码，也就是定义了该数据是什么，如果不为定义内的值则连接中断。占四个位，可以表示0~15的十进制，或者一个十六进制。<ul><li>%x0 表示一个继续帧</li><li>%x1 表示一个文本帧</li><li>%x2 表示一个二进制帧</li><li>%x3-7 为以后的非控制帧保留</li><li>%x8 表示一个连接关闭</li><li>%x9 表示一个ping</li><li>%x10 表示一个pong</li><li>%x11-15 为以后的控制帧保留</li></ul></li><li>masked： 占第二个字节的一位，定义了masking-key是否存在。并且使用masking-key掩码解析Payload data。<ul><li>1 客户端发送数据到服务端</li><li>0 服务端发送数据到客户端</li></ul></li><li>payload length： 表示Payload data的总长度。占7位，或者7+2个字节、或者7+8个字节。<ul><li>0-125，则是payload的真实长度</li><li>126，则后面2个字节形成的16位无符号整型数的值是payload的真实长度，125&lt;数据长度&lt;65535</li><li>127，则后面8个字节形成的64位无符号整型数的值是payload的真实长度，数据长度&gt;65535</li></ul></li><li>masking key： 0或4字节，当masked为1的时候才存在，为4个字节，否则为0，用于对我们需要的数据进行解密</li><li>payload data： 我们需要的数据，如果masked为1，该数据会被加密，要通过masking key进行异或运算解密才能获取到真实数据。</li></ul><p><strong>关于数据帧</strong></p><p>因为 WebSocket 服务端接收到的数据有可能是连续的数据帧，一个 message 可能分为多个帧发送。但如果使用 fin 来做消息边界是有问题的。</p><p>我发送了一个 27378 个字节的字符串，服务器端共接收到 2 帧，两帧的 fin 都为 1，而且根据规范计算出来的两帧的 payload data 的长度为 27372 少了 6 个字节。这缺少的 6 个字节其实刚好等于 2 个固有字节加上 maskingKey 的4个字节，也就是说第二帧就是一个纯粹的数据帧。这又是怎么回事呢？？</p><p>从结果推测实现，我们接收到的第 2 帧的数据格式不是帧格式，说明数据没有先分帧（分片）后再发送的。而是将一帧分包后发送的。</p><blockquote><p>分片<br />分片的主要目的是允许当消息开始但不必缓冲该消息时发送一个未知大小的消息。如果消息不能被分片，那么端点将不得不缓冲整个消息以便在首字节发生之前统计出它的长度。对于分片，服务器或中间件可以选择一个合适大小的缓冲，当缓冲满时，写一个片段到网络。</p></blockquote><p>我们 27378 个字节的消息明显是知道 message 长度，那么就算这个 message 很大，根据规范 1 帧的数据长度理论上是 0 &lt; 数据长度 &lt; 65535 的，这种情况下应该 1 帧搞定，他也只是当做一帧来发送，但是由于传输限制，所以这一个帧（我们收到的像是好几帧一样）会被拆分成几块发送，除了第一块是带有 fin、opcode、masked 等标识符，之后收到的块都是纯粹的数据（也就是第一块的 payload data 的后续部分），这个就是 socket 的将 WebSocket 分好的一帧数据进行了分包发送。那么这种一帧被 socket 分包发送，导致像是分帧（分片）发送的情况（服务器端本应该只就收一帧），在服务器端我暂时还没有想到怎样获取状态来处理。</p><p>总结，客户端发送数据，在实现时还是需要手动进行分帧（分片）,不然就按照一帧发送，小数据量无所谓；如果是大数据量，就会被 socket 自动分包发送。这个与 WebSocket 协议规范所标榜的自动分帧（分片），存在的差异应该是各个浏览器在对 WebSocket 协议规范的实现上偷工减料所造成的。所以我们看见 <a href="http://socket.io">socket.io</a> 等插件会有一个客户端接口，应该就是为了重新是实现 WebSocket 协议规范。从原理出发，我们接下来还是以小数据量（单帧）数据传输为例了。</p><p><strong>解析数据帧</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dataHandler.js</span></span><br><span class="line"><span class="comment">// 收集本次message的所有数据</span></span><br><span class="line"><span class="function"><span class="title">getData</span>(<span class="params">data, callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getState(data);</span><br><span class="line">    <span class="comment">// 如果状态码为8说明要关闭连接</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.state.opcode == <span class="number">8</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.OPEN = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.closeSocket();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是心跳pong,回一个ping</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.state.opcode == <span class="number">10</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.OPEN = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.pingTimes = <span class="number">0</span>;<span class="comment">// 回了pong就将次数清零</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集本次数据流数据</span></span><br><span class="line">    <span class="built_in">this</span>.dataList.push(<span class="built_in">this</span>.state.payloadData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度为0，说明当前帧位最后一帧。</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.state.remains == <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> buf = Buffer.concat(<span class="built_in">this</span>.dataList, <span class="built_in">this</span>.state.payloadLength);</span><br><span class="line">        <span class="comment">//使用掩码maskingKey解析所有数据</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="built_in">this</span>.parseData(buf);</span><br><span class="line">        <span class="comment">// 数据接收完成后回调回业务函数</span></span><br><span class="line">        callback(<span class="built_in">this</span>.socket, result);</span><br><span class="line">        <span class="comment">//重置状态，表示当前message已经解析完成了</span></span><br><span class="line">        <span class="built_in">this</span>.resetState();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.state.index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 收集本次message的所有数据</span></span><br><span class="line"><span class="function"><span class="title">getData</span>(<span class="params">data, callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getState(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集本次数据流数据</span></span><br><span class="line">    <span class="built_in">this</span>.dataList.push(<span class="built_in">this</span>.state.payloadData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度为0，说明当前帧位最后一帧。</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params"><span class="built_in">this</span>.state.remains == <span class="number">0</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> buf = Buffer.concat(<span class="built_in">this</span>.dataList, <span class="built_in">this</span>.state.payloadLength);</span><br><span class="line">    <span class="comment">//使用掩码maskingKey解析所有数据</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="built_in">this</span>.parseData(buf);</span><br><span class="line">    <span class="comment">// 数据接收完成后回调回业务函数</span></span><br><span class="line">        callback(<span class="built_in">this</span>.socket, result);</span><br><span class="line">    <span class="comment">//重置状态，表示当前message已经解析完成了</span></span><br><span class="line">        <span class="built_in">this</span>.resetState();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.state.index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析本次message所有数据</span></span><br><span class="line"><span class="function"><span class="title">parseData</span>(<span class="params">allData, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = allData.length,</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params">; i &lt; len; i++</span>)</span>&#123;</span><br><span class="line">        allData[i] = allData[i] ^ <span class="built_in">this</span>.state.maskingKey[ i % <span class="number">4</span> ];<span class="comment">// 异或运算，使用maskingKey四个字节轮流进行计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断数据类型，如果为文本类型</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.state.opcode == <span class="number">1</span>) allData = allData.toString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组装需要发送的数据帧</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组装数据帧，发送是不需要掩码加密</span></span><br><span class="line"><span class="function"><span class="title">createData</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dataType = Buffer.isBuffer(data);<span class="comment">// 数据类型</span></span><br><span class="line">    <span class="keyword">let</span> dataBuf, <span class="comment">// 需要发送的二进制数据</span></span><br><span class="line">        dataLength,<span class="comment">// 数据真实长度</span></span><br><span class="line">        dataIndex = <span class="number">2</span>; <span class="comment">// 数据的起始长度</span></span><br><span class="line">    <span class="keyword">let</span> frame; <span class="comment">// 数据帧</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dataType) dataBuf = data;</span><br><span class="line">    <span class="keyword">else</span> dataBuf = Buffer.from(data); <span class="comment">// 也可以不做类型判断，直接Buffer.form(data)</span></span><br><span class="line">    dataLength = dataBuf.byteLength; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算payload data在frame中的起始位置</span></span><br><span class="line">    dataIndex = dataIndex + (dataLength &gt; <span class="number">65535</span> ? <span class="number">8</span> : (dataLength &gt; <span class="number">125</span> ? <span class="number">2</span> : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    frame = <span class="keyword">new</span> Buffer.alloc(dataIndex + dataLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个字节,fin = 1,opcode = 1</span></span><br><span class="line">    frame[<span class="number">0</span>] = <span class="built_in">parseInt</span>(<span class="number">10000001</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长度超过65535的则由8个字节表示，因为4个字节能表达的长度为4294967295，已经完全够用，因此直接将前面4个字节置0</span></span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">dataLength &gt; <span class="number">65535</span></span>)</span>&#123;</span><br><span class="line">        frame[<span class="number">1</span>] = <span class="number">127</span>; <span class="comment">//第二个字节</span></span><br><span class="line">        frame.writeUInt32BE(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        frame.writeUInt32BE(dataLength, <span class="number">6</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">dataLength &gt; <span class="number">125</span></span>)</span>&#123;</span><br><span class="line">        frame[<span class="number">1</span>] = <span class="number">126</span>;</span><br><span class="line">        frame.writeUInt16BE(dataLength, <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        frame[<span class="number">1</span>] = dataLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端发送到客户端的数据</span></span><br><span class="line">    frame.write(dataBuf.toString(), dataIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>心跳检测</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 心跳检查</span></span><br><span class="line"><span class="function"><span class="title">sendCheckPing</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="keyword">if</span> (_this.pingTimes &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            _this.closeSocket();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录心跳次数</span></span><br><span class="line">        _this.pingTimes++;</span><br><span class="line">        <span class="keyword">if</span>(_this.pingTimes == <span class="number">100000</span>) _this.pingTimes = <span class="number">0</span>;</span><br><span class="line">        _this.sendCheckPing();</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送心跳ping</span></span><br><span class="line"><span class="function"><span class="title">sendPing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ping = Buffer.alloc(<span class="number">2</span>);</span><br><span class="line">    ping[<span class="number">0</span>] = <span class="built_in">parseInt</span>(<span class="number">10001001</span>, <span class="number">2</span>);</span><br><span class="line">    ping[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.writeData(ping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关闭连接</strong></p><p>客户端直接调用close方法，服务器端可以使用socket.end方法。</p><h2 id="八-构建-web应用"><a class="markdownIt-Anchor" href="#八-构建-web应用"></a> 八、构建 Web应用</h2><h3 id="1-基础功能"><a class="markdownIt-Anchor" href="#1-基础功能"></a> 1、基础功能</h3><h4 id="1请求方法"><a class="markdownIt-Anchor" href="#1请求方法"></a> (1)请求方法</h4><p>HTTP_Parser 在解析请求报文时会将报文头中的请求方法抽取出来设置为 req.method。</p><h4 id="2路径解析"><a class="markdownIt-Anchor" href="#2路径解析"></a> (2)路径解析</h4><p>HTTP_Parser 将其解析为 req.url。一般而言，完整的 URL 地址是如下这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;user:pass@host.com:8080&#x2F;p&#x2F;a&#x2F;t&#x2F;h?query&#x3D;string#hash</span><br></pre></td></tr></table></figure><p>但是客户端代理（浏览器）会将这个地址解析成报文，将路径和查询报文放在报文第一行，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;p&#x2F;a&#x2F;t&#x2F;h?query&#x3D;string HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure><p>因此最终得到的 req.url 的值为 ‘/p/a/t/h?query=string’。</p><h4 id="3查询字符串"><a class="markdownIt-Anchor" href="#3查询字符串"></a> (3)查询字符串</h4><p>查询字符串位于路径之后，形成请求报文首行的第二部分，Node 提供了 querystring 模块用于处理这部分数据。</p><h4 id="4cookie"><a class="markdownIt-Anchor" href="#4cookie"></a> (4)Cookie</h4><p>HTTP 是一个无状态的协议，但现实中的业务却是需要一定的状态的，这就催生了 Cookie 的诞生，客户端发送的 Cookie 在请求报文的 Cookie 字段中，HtTP_Parser 会将所有的报文字段解析到 req.headers 上，Cookie 是 req.headers.cookie。具体内容格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;csrftoken&#x3D;HpZuyoYbH_hOQWHUv-0bbb9H; Hm_lvt_f1621cb3fb0792bb294fce1b938d5eef&#x3D;1632186900; Hm_lpvt_f1621cb3fb0792bb294fce1b938d5eef&#x3D;1633872461&#39;</span><br></pre></td></tr></table></figure><p>除此之外我们还可以在服务端通过 Set-Cookie 字段设置客户端 Cookie，除了 name=value 是必须包含的部分还有如下几个主要参数配置项：</p><ul><li>path：表示这个 Cookie 影响到的路径。</li><li>Expires 和 Max-Age 是用来告诉浏览器这个 Cookie 何时过期的，如果不设置这个该选项在关闭浏览器时会丢失掉这个 Cookie，如果设置了浏览器会把 Cookie 内容写入磁盘中并保存。</li><li>HttpOnly：告知浏览器不允许通过脚本 document.cookie 来更改 cookie</li><li>Secure：当 Secure 值为 true 时，在 HTTP 中是无效的，在 HTTPS 中才有效。</li></ul><h4 id="5session"><a class="markdownIt-Anchor" href="#5session"></a> (5)Session</h4><p>Session 的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次被传递，但是还需要将每个客户和服务器中的数据一一对应起来，这里主要有常见的两种实现方式：</p><ul><li>基于 Cookie 来实现用户和数据映射。</li><li>通过查询字符串来实现浏览器端和服务器端数据的对应。</li></ul><p>两种方法实现的思路主要是通过 Cookie 携带 Session 的口令或通过请求中的查询字符串来携带。</p><p>除此之外我们还需要注意如下亮点：</p><ul><li>Session 与内存：如果将 Session 数据存放在内存中一方面 Node 有内存大小限制，并且 Node 的进程与进程之间也无法共享内存，因此常用的方案是将 Session 集中化，转移到集中的数据存储中，常用的工具是 Redis、Memcached。</li><li>Session 与安全：Session 的口令依然保存在客户端，因此会存在口令被盗用的情况，有一种做法是将这个口令通过私钥加密进行签名，这样即使攻击者知道口令也无法伪造签名信息，但是如果攻击者通过某种方式获取了一个真实的口令和签名他就能实现身份的伪装。因此另一种方案是将客户端的某些独有信息与口令作为原值进行签名，这样攻击者一旦不在原始的客户端访问就会导致签名失败。</li></ul><h4 id="6缓存"><a class="markdownIt-Anchor" href="#6缓存"></a> (6)缓存</h4><p>HTTP 支持的缓存策略主要分为 “强制缓存” 和 “协商缓存”。“强制缓存“ 主要通过 Expires 和 Cache-Control 字段，而 “协商缓存” 主要通过 Last-Modified 和 If-Modified-Since、ETag 和 If-None-Match，更多详情可查看我的博客<a href="https://kyleezhang.github.io/2021/03/16/client-cache/">浏览器缓存</a>。</p><p>除了设置缓存之外我们还需要服务端意外更新后通过客户端及时更新的能力，这使得我们在使用缓存时也要为其设定版本号，所幸浏览器是根据 URL 进行缓存，那么一旦内容有更新时，我们就让浏览器发起新的 URL 请求，使得新内容能够被客户端更新。一般的更新机制有如下两种：</p><ul><li>每次发布路径中跟随 Web 应用的版本号。</li><li>每次发布路径中跟随文件内容的 hash 值。</li></ul><h4 id="7basic-认证"><a class="markdownIt-Anchor" href="#7basic-认证"></a> (7)Basic 认证</h4><p>Basic 认证是当客户端与服务端进行请求时，允许通过用户名和密码实现的一种身份认证方式。如果一个页面需要 Basic 认证，它会检查请求报文头中的 Authorization 字段的内容，该字段的值由认证方式和加密值构成，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dXNlcjpwYXNz</span><br></pre></td></tr></table></figure><p>在 Basic 认证中，它会将用户和密码部分组合：username + “:” + password 。然后进行 base64 编码。</p><p>Basic 认证虽然经过 Base64 加密后在网络传送，但是这近乎明文十分危险，一般只有在 HTTPS 的情况下才会使用，不过 Basic 认证的支持范围十分广泛，几乎所有的浏览器都支持它。</p><h3 id="2-数据上传"><a class="markdownIt-Anchor" href="#2-数据上传"></a> 2、数据上传</h3><p>Node 的 http 模块只对 HTTP 报文的头部进行了解析，然后触发了 request 事件。如果请求中还带有内容部分，内容部分需要用户自行接收和解析。</p><p>我们可以通过报头中的 Transfer-Encoding 或 Content-Length 字段判断请求中是否带有内容。</p><p>在 HTTP_Parser 解析报头结束后，报文内容部分会通过 data 事件触发，我们只需要以流的方式处理即可，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasBody = <span class="function">(<span class="params">req</span>) =&gt;</span> <span class="string">&#x27;transfer-encoding&#x27;</span> <span class="keyword">in</span> req.headers || <span class="string">&#x27;content-length&#x27;</span> <span class="keyword">in</span> req.headers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBody(req)) &#123;</span><br><span class="line">        <span class="keyword">var</span> buffers = []</span><br><span class="line">        req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">            buffers.push(chunk)</span><br><span class="line">        &#125;)</span><br><span class="line">        req.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            req.rawBody = Buffer.concat(buffers).toString()</span><br><span class="line">            handle(req, res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handle(req, res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1表单数据"><a class="markdownIt-Anchor" href="#1表单数据"></a> (1)表单数据</h4><p>通过 form 标签默认的表单提交请求头中的 Content-Type 字段值为 application/x-www-form-urlencoded，而它的报文体内容与查询字符串相同：<code>foo=bar&amp;baz=val</code>，因此它的解析非常容易：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handle = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.header[<span class="string">&#x27;content-type&#x27;</span>] === <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>) &#123;</span><br><span class="line">        req.body = querystring.parse(req.rawBody)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2其他格式"><a class="markdownIt-Anchor" href="#2其他格式"></a> (2)其他格式</h4><p>除了表单数据外常见的提交还有 JSON 和 XML 文件等，判断它们的方式也是通过 Content-Type 字段，值分别为 application/json 和 application/xml。</p><p>json 文件的解析是非常简单的，我们可以直接通过 JSON.parse 方法进行解析，XML 文件的解析稍微复杂一些但我们也可以采用 XML 文件到 JSON 对象转换的库，例如 xml2js 模块。</p><h4 id="3附件上传"><a class="markdownIt-Anchor" href="#3附件上传"></a> (3)附件上传</h4><p>通常的表单，其内容可以通过 urlencoded 的方式编码内容形成报文体，再发送给服务器端，但是业务场景往往需要用户直接提交文件。在前端 HTML 代码中，特殊表单与普通表单的差异在于该表单中可以含有 file 类型的控件，以及需要指定表单属性 enctype 为 multipart/form-data，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器在遇到 multipart/form-data 表单提交时，构造的请求报文与普通报文完全不同。首先它的报头中最为特殊的如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;AaB03x</span><br><span class="line">Content-Length: 18231</span><br></pre></td></tr></table></figure><p>它代表本次提交的内容是由多部分构成的，其中 boundary=AaB03x 是随机生成的一段字符串，制定每部分内容的分界符。报文的内容将通过在它前面添加 ‘–’ 进行分割，报文结束在它前后都加 ‘–’ 表示结束。另外 Content-Length 的值必须确保是报文体的长度。</p><p>在知晓了报问题是如何构成之后解析就变得非常容易，但是对于未知大小的数据量进行处理时依然需要小心，我们也可以采用一些第三方库比如 formidable 来协助我们处理。</p><h4 id="4数据上传与安全"><a class="markdownIt-Anchor" href="#4数据上传与安全"></a> (4)数据上传与安全</h4><p><strong>内存限制</strong></p><p>在我们通过 Node 解析表单、JSON 和 XML 部分时我们采取的策略往往是先保存用户提交的所有数据，然后再解析处理，最后再传递给业务逻辑。这种策略潜在的问题是它仅仅适合数据量小的提交请求，一旦数据量过大将发生内存被占光的情景。</p><p>要解决这个问题主要有两种方案：</p><ul><li>限制上传内容的大小，一旦超过限制，停止接受数据，并响应 400 状态码</li><li>通过流式解析，将数据流导向磁盘中，Node 只保留文件路径等小数据</li></ul><p><strong>CSRF</strong></p><p>服务器端与客户端通常通过 Cookie 来标识和认证用户，但是部分情况下会出现通过引诱用户点击恶意网站的链接来冒充用户的信息，除了通过配置 Cookie 的相关属性外我们还可以通过添加随机值的方式来解决。也就是说为每个请求的用户，在 Session 中赋予一个随机值，由于该值是一个随机值，攻击者构造出相同随机值的难度相当大，我们只需要在接收端做一次校验就能轻易地识别出该请求是否为伪造的。</p><h3 id="3-路由解析"><a class="markdownIt-Anchor" href="#3-路由解析"></a> 3、路由解析</h3><p>对于不同的业务我们希望有不同的处理方式，这就带来了路由的选择问题。</p><h4 id="1文件路径型"><a class="markdownIt-Anchor" href="#1文件路径型"></a> (1)文件路径型</h4><p><strong>静态文件</strong></p><p>这种路由的处理方式十分简单，将请求路径对应的文件发送到客户端即可。</p><p><strong>动态文件</strong></p><p>这种方式的实现原理是 Web 服务器根据 URL 路径找到对应的文件，如 index.asp。Web 服务器根据文件名的后缀去寻找脚本的解析器，并传入 HTTP 请求的上下文。</p><p>现今大多数服务器都能很智能地根据后缀同时服务动态文件和静态文件。但这种方式在 Node 中不太常见，主要原因是文件的后缀都是 js，分不清是后端脚本还是前端脚本。而且 Node 中 Web 服务器与应用业务脚本是一体的，也无须按照这种方式实现。</p><h4 id="2mvc"><a class="markdownIt-Anchor" href="#2mvc"></a> (2)MVC</h4><p>MVC 模型的主要思想是将业务逻辑按职责分离，主要分为以下几种：</p><ul><li>控制器 Controller，一组行为的集合</li><li>模型 Model，数据相关的操作和封装</li><li>视图 View，视图的渲染</li></ul><p>这是目前最经典的封层模式，其工作模式如下：</p><ul><li>路由解析，根据 URL 寻找到对应的控制器和行为。</li><li>行为调用相关的模型，进行数据操作。</li><li>数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。</li></ul><p>这里如何根据 URL 做路由映射主要有两种方法实现，一种是通过手工关联映射，一种是自然关联映射。前者会有一个对应的路由文件来将 URL 映射到对应的控制器，后者没有这样的文件。</p><p>手工映射主要是通过一个路由文件来将 URL 映射到对应的控制器，其对 URL 的要求十分灵活。不过这种映射关系的解析需要两大基本能力：正则匹配与参数解析，用于对 URL 中的携带参数进行提取与处理。</p><p>相较于手工关联，自然关联采用了按照一种约定的方式自然而然地实现路由而无须去维护路由映射文件的手段，例如我们可以对；路径进行如下的划分处理：</p><p><code>/controller/action/pararm1/param2/param3</code></p><p>以 ‘/user/setting/12/1987’ 为例，它会按照约定去找 controllers 目录下的 user 文件，将其 require 出来后，调用这个模块的 setting() 方法，而其余的值作为参数直接传递给这个方法。</p><p>总而言之，手工映射对 URL 的处理十分灵活，不过需要我们维护一份路由关系映射文件，而且依赖于正则匹配与参数解析的核心能力。而自然映射的设计十分简洁，但是如果 URL 变动，它的文件也需要发生变动，手工映射只需要改动路由映射即可。</p><h4 id="3restful"><a class="markdownIt-Anchor" href="#3restful"></a> (3)RESTful</h4><p>REST 的全称是 Representational State Transfer，中文含义是表现层状态转化。符合 REST 规范的设计，我们称为 RESTful 的设计。它的设计哲学主要是将服务端提供的内容实体看作是一个资源，并表现在 URL 上，然后通过请求方法定义资源的操作，通过 Accept 决定资源的表现形式。</p><p>RESTful 与 MVC 的设计并不冲突，而且是更好的改进。相比 MVC，RESTful 只是将 HTTP 请求方法也加入了路由的过程，以及在 URL 的路径上体现得更资源化。</p><h3 id="4-中间件"><a class="markdownIt-Anchor" href="#4-中间件"></a> 4、中间件</h3><p>中间件的主要用于简化和隔离基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。</p><p>Node 的 http 模块提供了应用层协议网络的封装，对具体业务并没有支持，因此通过中间件搭建开发框架对业务提供强力支撑是很有必要的。</p><p>中间件的编写需要注意如下两个点：</p><ul><li>编写高效的中间件</li><li>合理利用路由，避免不必要的中间件执行</li></ul><h4 id="1编写高效的中间件"><a class="markdownIt-Anchor" href="#1编写高效的中间件"></a> (1)编写高效的中间件</h4><p>编写高效的中间件其实就是提升单个单元的处理速度，以尽早调用 next() 执行后续逻辑。由于中间件一旦被匹配，那么每个请求都会使该中间件执行一次，哪怕它只浪费1毫秒的执行时间，都会让我们的 QPS 显著下降。常见的优化方法主要有：</p><ul><li>使用高效的方法，必要时通过 <a href="http://jsperf.com">jsperf.com</a> 测试基准性能。</li><li>缓存需要重复计算的结果</li><li>避免不必要的计算</li></ul><h4 id="2合理使用路由"><a class="markdownIt-Anchor" href="#2合理使用路由"></a> (2)合理使用路由</h4><p>在拥有了一堆高效的中间件后我们还需要对每个中间件的合理使用做出判断，避免中间件参与不必要的请求处理处理过程。</p><h3 id="5-页面渲染"><a class="markdownIt-Anchor" href="#5-页面渲染"></a> 5、页面渲染</h3><h4 id="1内容响应"><a class="markdownIt-Anchor" href="#1内容响应"></a> (1)内容响应</h4><p>服务端的响应从一定程度上决定或指示了客户端该如何处理响应的内容。因此响应包头中的 Content-* 字段十分重要。</p><p><strong>MIME</strong></p><p>不同的文件类型有不同的 MIME 值，响应在在 Content-Type 字段中返回以便客户端进行对应的处理。</p><p>除了 MIME 值外，Content-Type 还可以包括一些参数，比如字符集。</p><p><strong>附件下载</strong></p><p>Content-Disposition 字段决定了客户端将相应报文数据当作即时浏览的内容，还是可下载的附件。当数据可以存为附件时，它的值为 attachemnt，如果只需即时查看时它的值为 inline。</p><p>除此之外 Content-Disposition 字段还能通过参数指定保存时应该使用的文件名。例如：</p><p><code>Content-Disposition: attachment; filename=&quot;filename.ext&quot;</code></p><p><strong>响应JSON</strong></p><p>我们可以通过指定 Content-Type 字段为 ‘application/json’ 快捷响应 JSON。</p><p><strong>响应跳转</strong></p><p>我们可以返回 302 状态码同时响应头添加 Location 字段来将用户跳转到别的 URL。</p><h4 id="2视图渲染"><a class="markdownIt-Anchor" href="#2视图渲染"></a> (2)视图渲染</h4><p>Web 应用最终呈现出来的内容都是通过一系列的视图渲染呈现出来的，在动态页面技术中，最终视图是由模板和数据共同生成出来的。</p><p>模板是带有特殊标签的 HTML 字段，通过与数据的渲染，将数据填充到这些特殊的标签中，最后生成普通的带数据的 HTML 片段。</p><h4 id="3模板"><a class="markdownIt-Anchor" href="#3模板"></a> (3)模板</h4><p>模板技术的实质上就是将模板文件和数据通过模版引擎生成最终的 HTML 代码，形成模板技术主要包括如下四个要素：</p><ul><li>模板语言</li><li>包含模板语言的模板文件</li><li>拥有动态数据的数据对象</li><li>模板引擎</li></ul><h5 id="模板引擎"><a class="markdownIt-Anchor" href="#模板引擎"></a> 模板引擎</h5><p>模板引擎的实现主要分为如下几个步骤：</p><ul><li>语法分解。提取出普通字符串和表达式，这个过程通常用正则表达式匹配出来。</li><li>处理表达式，将标签表达式转换成普通的语言表达式。</li><li>生成待执行的语句。</li><li>与数据一起执行，生成最终的字符串。</li></ul><p><strong>模板编译</strong></p><p>为了能够最终与数据一起执行生成字符串，我们需要将原始的模板字符串转换成一个函数对象，这个过程称为模板编译。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compile = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#x27; + obj.&quot;</span> + code + <span class="string">&quot;+ &#x27;&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    tpl = <span class="string">&quot;var tpl = &#x27;&quot;</span> + tpl + <span class="string">&quot;&#x27;\nreturn tpl;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;obj&#x27;</span>, tpl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compiled = compile(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">compiled, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compiled(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="with的应用"><a class="markdownIt-Anchor" href="#with的应用"></a> with的应用</h5><p>为了让模板引擎更加灵活，字符串能继续表达为字符串，变量能够自动寻找属于它的对象，我们需要引入关键字 with。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compile = <span class="function"><span class="keyword">function</span> (<span class="params">str, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#x27; + &quot;</span> + code + <span class="string">&quot; + &#x27;&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    tpl = <span class="string">&quot;tpl = &#x27;&quot;</span> + tpl + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    tpl = <span class="string">&#x27;var tpl = &quot;&quot;;\nwith (obj) &#123;&#x27;</span> + tpl + <span class="string">&#x27;&#125;\nreturn tpl&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;obj&#x27;</span>, tpl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板安全</strong></p><p>实际上 XSS 漏洞的产生大多数跟模板有关，如果数据传入的值为恶意字符串比如 <code>&lt;script&gt;slert(&quot;I am XSS&quot;)&lt;/script&gt;</code> 那么页面就会执行这个脚本。因此为了安全性，大多数模板都提供了转义的功能。转义就是将能形成 HTML 标签的字符转换成安全的字符，转义函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> excape = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(html)</span><br><span class="line">        .replace(<span class="regexp">/&amp;(?!\w+;)/g</span>, <span class="string">&#x27;&amp;amp&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quot;&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#039;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让转义与非转义表现得更方便，我们可以使用不同的标签来表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">str, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tpl = str</span><br><span class="line">        .replace(<span class="regexp">/\n/g</span>, <span class="string">&#x27;\\n&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 转义</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#x27; + escope(&quot;</span> + code + <span class="string">&quot;) + &#x27;&quot;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .replace(<span class="regexp">/&lt;%-([\s\S]+?)%/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 正常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#x27; + &quot;</span> + code + <span class="string">&quot; + &#x27;&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    tpl = <span class="string">&quot;tpl = &#x27;&quot;</span> + tpl + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    tpl = <span class="string">&#x27;var tpl = &quot;&quot;;\nwith(obj) &#123;&#x27;</span> + tpl + <span class="string">&#x27;&#125;\nreturn tpl;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;obj&#x27;</span>, <span class="string">&#x27;escape&#x27;</span>, tpl);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h5 id="模板逻辑"><a class="markdownIt-Anchor" href="#模板逻辑"></a> 模板逻辑</h5><p>为了让模板更强大一些我们为它添加逻辑代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compile = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tpl = str</span><br><span class="line">        .replace(<span class="regexp">/\n/g</span>, <span class="string">&#x27;\\n&#x27;</span>) <span class="comment">// 将换行符替换</span></span><br><span class="line">        .replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 转义</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#x27; + escope(&quot;</span> + code + <span class="string">&quot;)+ &#x27;&quot;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .replace(<span class="regexp">/&lt;%-([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 正常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#x27; + &quot;</span> + code + <span class="string">&quot; + &#x27;&quot;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .replace(<span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#x27;;\n&quot;</span> + code + <span class="string">&quot;\ntpl += &#x27;&quot;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .replace(<span class="regexp">/\&#x27;\n/g</span>, <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">        .replace(<span class="regexp">/\n\&#x27;/gm</span>, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    tpl = <span class="string">&quot;tpl = &#x27;&quot;</span> + tpl + <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换空行</span></span><br><span class="line">    tpl = tpl.replace(<span class="regexp">/&#x27;&#x27;/g</span>, <span class="string">&#x27;\&#x27;\\n\&#x27;&#x27;</span>);</span><br><span class="line">    tpl = <span class="string">&#x27;var tpl = &quot;&quot;;\nwith( obj || &#123;&#125;) &#123;\n&#x27;</span> + tpl + <span class="string">&#x27;\n&#125;\nreturn tpl;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;obj&#x27;</span>, <span class="string">&#x27;escape&#x27;</span>, tpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="集成文件系统"><a class="markdownIt-Anchor" href="#集成文件系统"></a> 集成文件系统</h5><p>结合我们之前实现的 compile() 与 render() 方法我们已经能够实现将输入的模板字符串进行编译替换的功能，但是通过模板编译生成的中间函数只与模板字符串相关，与具体的数据无关，因此我们可以采用模板预编译的方法，预编译缓存模板编译后的结果，以此实现一次编译多次执行。这里我们再集成文件系统：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> VIEW_FOLDER = <span class="string">&#x27;/path/to/wwwroot/views&#x27;</span>;</span><br><span class="line"></span><br><span class="line">res.render = <span class="function"><span class="keyword">function</span> (<span class="params">viewname, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache[viewname]) &#123;</span><br><span class="line">        <span class="keyword">var</span> text;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            text = fs.readFileSync(path.join(VIEW_FOLDER, viewname), <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            res.writeHead(<span class="number">500</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">            res.end(<span class="string">&#x27;模板文件错误&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[viewname] = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> compiled = cache[viewname];</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">    <span class="keyword">var</span> html = compiled(data);</span><br><span class="line">    res.end(html);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与文件系统集成后再引入缓存就可以很好的解决性能问题，接口也得到大大简化。</p><h5 id="子模板"><a class="markdownIt-Anchor" href="#子模板"></a> 子模板</h5><p>有的时候模板太大太过复杂，会增加维护上的困难，这就导致了子模板的诞生，子模板可以嵌套在别的模板中，多个模板可以嵌入同一个子模板中。我们可以采用 include 关键字实现模板的嵌套：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> files = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> preCompile() = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> replaced = str.replace(<span class="regexp">/&lt;%\s+(include.*)\s+%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> partial = code.split(<span class="regexp">/\s/</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!files[partial]) &#123;</span><br><span class="line">            files[partial] = fs.readFileSync(path.join(VIEW_FOLDER, partial), <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> files[partial]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多层嵌套，继续替换</span></span><br><span class="line">    <span class="keyword">if</span> (str.match(<span class="regexp">/&lt;%\s+(include.*)\s+%&gt;/</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> preCompile(replaced);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> replaced</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 compile() 方法对字符串解析前先调用 preCompile 方法对数据进行预编译即可实现对子模板的支持。</p><h4 id="4bigpipe"><a class="markdownIt-Anchor" href="#4bigpipe"></a> (4)Bigpipe</h4><p>Bigpipe 是一个需要前后端配合实现的优化技术，它的主要思路是将页面分割成多个部分，先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，并最终渲染填充框架，完成整个网页的渲染，这个过程中需要前端 JavaScript 的参与，它负责将后续输出的数据渲染到页面上。</p><p>它比较重要的有如下几个点：</p><ul><li>页面布局框架</li><li>后端持续性数据输出</li><li>前端渲染</li></ul><h2 id="九-玩转进程"><a class="markdownIt-Anchor" href="#九-玩转进程"></a> 九、玩转进程</h2><h3 id="1-服务模型的变迁"><a class="markdownIt-Anchor" href="#1-服务模型的变迁"></a> 1、服务模型的变迁</h3><img src="/assets/深入浅出NodeJS/16.jpg" /><h3 id="2-多进程架构"><a class="markdownIt-Anchor" href="#2-多进程架构"></a> 2、多进程架构</h3><p>Node 的多进程采用了著名的 Master-Worker 模式，即主从模式，主从模式是典型的分布式架构中用于并行处理业务的模式具备较好的可伸缩性和稳定性。主进程不负责具体的业务逻辑，而是负责调度或管理工作进程，工作进程负责具体的业务处理。</p><h4 id="1-创建子进程"><a class="markdownIt-Anchor" href="#1-创建子进程"></a> (1) 创建子进程</h4><p>child_process 模块给予了 Node 创建子进程的能力，它提供了 4 个方法用于创建子进程：</p><ul><li>spawn()：启动一个子进程来执行命令</li><li>exec()：启动一个子进程来执行命令，与 spawn() 不同的是其接口不同，它有一个回调函数获知子进程的状况</li><li>execFile()：启动一个子进程来执行可执行文件</li><li>fork()：与 spawn() 类似，不同点在于它创建 Node 的子进程只需要指定要执行的 JavaScript 文件模块即可</li></ul><p>注：</p><ol><li>spawn() 与 exec()、esecFile() 不同的是后两者创建时可以指定 timeout 属性设置超时时间，一旦创建的进程超过设定的时间将会被杀死。</li><li>exec() 与 execFile() 不同的是，exec() 适合执行已有的命令，execFile() 适合执行文件。</li></ol><p>举个🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line">cp.spawn(<span class="string">&#x27;node&#x27;</span>, [<span class="string">&#x27;worker.js&#x27;</span>])</span><br><span class="line">cp.exec(<span class="string">&#x27;node worker.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stdout, stderr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;)</span><br><span class="line">cp.execFile(<span class="string">&#x27;worker.js&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stdout, stderr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;)</span><br><span class="line">cp.fork(<span class="string">&#x27;./worker.js&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="/assets/深入浅出NodeJS/17.jpeg" /><h4 id="2-进程间通信"><a class="markdownIt-Anchor" href="#2-进程间通信"></a> (2) 进程间通信</h4><p>在主从模式中要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信，进程间通信简称 IPC（Inter-Process Communication），其主要目的是为了让不同的进程能够相互的访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node 中实现 IPC 通道的方式如下所示：</p><img src="/assets/深入浅出NodeJS/18.jpeg" width="500" /><p>Node 中 IPC 通道的具体细节实现由 libuv 提供，在 Windows 下由命名管道实现 (named pipe) 实现，*nix 系统则采用 Unix Domain Socket 实现。表现在应用层上的进程间通信只有简单的 message 事件和 send 方法，接口十分简洁和消息化。举个🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_precess&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> n = cp.fork(__dirname + <span class="string">&#x27;/sub.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line">n.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;PARENT got message:&#x27;</span>, m)</span><br><span class="line">&#125;)</span><br><span class="line">n.send(&#123; <span class="attr">hello</span>: <span class="string">&#x27;world!&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub.js</span></span><br><span class="line">process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;CHILD got message:&#x27;</span>, m)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.send(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><p>那么 Node 创建 IPC 通道的具体实现是怎么样的呢？</p><p>父进程在实际创建子进程之前会创建 IPC 通道（在 Node 中 IPC 通道被抽象为 Stream 对象）并<strong>监听</strong>它，然后才真正创建出子进程，并通过环境变量 (Node_CHANNEL_FD) 告诉子进程这个 IPC 通道的文件描述符。子进程在启动的过程中，<strong>根据文件描述符去连接</strong>这个已存在的 IPC 通道，从而完成父子进程之间的连接。</p><p>注：只有启动的子进程是 Node 进程时，子进程才会根据环境变量去连接 IPC 通道，对于其他类型的子进程则无法实现进程间通信，除非其他进程也按约定去连接这个创建好的 IPC 通道。</p><h4 id="3-句柄传递"><a class="markdownIt-Anchor" href="#3-句柄传递"></a> (3) 句柄传递</h4><p>为了解决多个工作进程一个端口的问题通常的做法是<strong>代理模式</strong>，即主进程监听主端口、对外接收所有的网络请求，再将这些请求分别代理到不同的端口的进程上。其优点在于避免了端口不能重复监听的问题，而且我们可以在代理进程上做适当的负载均衡，但是由于<strong>进程每接收到一个连接将会用掉一个文件描述符</strong>，因此这种代理模式需要浪费一倍数量的文件描述符，这极大的影响了系统的扩展能力。</p><p>为了解决这个问题 Node 在版本 v0.5.9 引入了进程间发送句柄的功能。首先什么是句柄？</p><p><strong>句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符</strong>，因此句柄可以用来标识一个服务器端 socket 对象、一个客户端 socket 对象、一个套接字等。</p><p>接下来我们通过发送句柄来实现多进程监听同端口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> child1 = cp.fork(<span class="string">&#x27;child.js&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> child2 = cp.fork(<span class="string">&#x27;child.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>).createServer();</span><br><span class="line">server.listen(<span class="number">1337</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    child1.send(<span class="string">&#x27;server&#x27;</span>, server)</span><br><span class="line">    child2.send(<span class="string">&#x27;server&#x27;</span>, server)</span><br><span class="line">    server.close()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// child.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;)</span><br><span class="line">    res.end(<span class="string">&#x27;handed by child, pid is &#x27;</span> + process.pid + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m, tcp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="string">&#x27;server&#x27;</span>) &#123;</span><br><span class="line">        tcp.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">            server.emit(<span class="string">&#x27;connection&#x27;</span>, socket)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么我们为什么可以通过发送句柄来实现多进程监听同一端口呢？句柄发送的具体过程是什么样的呢？</p><p>目前子进程对象 send() 方法可以发送的句柄类型包括如下几种：</p><ul><li>net.Socket: TCP 套接字</li><li>net.Server: TCP 服务器</li><li>net.Native: C++ 层面的 TCP 套接字或 IPC 管道</li><li>dgram.Socket: UDP 套接字</li><li>dgram.Native: C++ 层面的 UDP 套接字</li></ul><p>send() 方法在将消息发送到 IPC 管道前，将消息组装成两个对象，一个参数是 handle，另一个是 message。message 的参数如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    cmd: <span class="string">&#x27;NODE_HANDLE&#x27;</span>,</span><br><span class="line">    type: <span class="string">&#x27;net.Server&#x27;</span>,</span><br><span class="line">    msg: messsage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿的文件描述符 handle 实际上是一个整数值，而这个 message 对象在写入到 IPC 通道时也会通过 JSON.stringify() 进行序列化。所以最终发送到 IPC 通道中的信息都是字符串，<strong>send() 方法能发送消息和句柄并不意味着它能发送任意对象</strong>。</p><p><strong>连接了 IPC 通道的子进程可以读取到父进程发送的消息，将字符串通过 JSON.parse() 解析还原为对象后，才触发 message 事件将消息传递给应用层使用。在这个过程中消息对象还要被进行过滤处理，message.cmd 的值如果以 NODE_ 为前缀，它将响应一个内部事件 internalMessage。如果 message.cmd 的值为 NODE_HANDLE，它将取出 message.type 值和得到的文件描述符一起还原出一个对应的对象</strong>，以 TCP 服务器句柄为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">message, handle, emit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> server = <span class="keyword">new</span> net.Server()</span><br><span class="line">    server.listen(handle, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        emit(server)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中，子进程根据 message.type 创建对应 TCP 服务器对象，然后监听到文件描述符上。</p><p>我们独立启动的进程中 TCP 服务器端 socket 套接字的文件描述符并不相同，这也是导致监听相同端口时抛出异常的主要原因，但是对于 send() 发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引起异常。</p><h3 id="3-集群稳定之路"><a class="markdownIt-Anchor" href="#3-集群稳定之路"></a> 3、集群稳定之路</h3><h4 id="1-进程事件"><a class="markdownIt-Anchor" href="#1-进程事件"></a> (1) 进程事件</h4><img src="/assets/深入浅出NodeJS/19.jpg"><h4 id="2-自动重启"><a class="markdownIt-Anchor" href="#2-自动重启"></a> (2) 自动重启</h4><p>在有了父子进程之间的相关事件之后，我们就可以在这些关系之间创建出需要的机制了，比如我们可以当监听到子进程退出后重新启动一个工作进程来继续服务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).fork</span><br><span class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).cpus()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>).createServer()</span><br><span class="line">server.listen(<span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> worker = fork(__dirname + <span class="string">&#x27;/worker.js&#x27;</span>)</span><br><span class="line">    worker.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Worker &#x27;</span> + worker.pid + <span class="string">&#x27; exited.&#x27;</span>)</span><br><span class="line">        <span class="keyword">delete</span> workers[worker.pid]</span><br><span class="line">        createWorker()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 句柄转发</span></span><br><span class="line">    worker.send(<span class="string">&#x27;server&#x27;</span>, server)</span><br><span class="line">    workers[worker.pid] = worker</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Create worker. pid: &#x27;</span> + worker.pid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i++) &#123;</span><br><span class="line">    createWorker()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> pid <span class="keyword">in</span> workers) &#123;</span><br><span class="line">        workers[pid].kill()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;)</span><br><span class="line">    res.end(<span class="string">&#x27;handled by child, pid is &#x27;</span> + process.pid + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker;</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">m, tcp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="string">&#x27;server&#x27;</span>) &#123;</span><br><span class="line">        worker = tcp</span><br><span class="line">        tcp.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">            server.emit(<span class="string">&#x27;connection&#x27;</span>, socket)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">process.on(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 停止接收新的连接</span></span><br><span class="line">    worker.close(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 所有连接断开后退出进程</span></span><br><span class="line">        process.exit(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>自杀信号</strong></p><p>上述代码的问题是要等到已有的所有连接断开后进程才退出，在极端的情况下，所有工作进程都停止接收新的连接，所有工作进程都停止接收新的连接，全处在等待退出的状态，但在等到进程完全退出才重启的过程中，所有新来的请求可能存在没有工作进程为新用户服务的情景，因此一个重要的优化手段就是<strong>自杀信号</strong>。</p><p>自杀信号的具体实现是工作进程在得知要退出时向主进程发送一个自杀信号，然后才停止接收新的连接，当所有连接断开后才退出。主进程在接收到自杀信号后，立即创建新的工作进程服务。这样可以大大提高应用的稳定性和健壮性。</p><p>除此之外我们的连接很有可能是长连接而不是 HTTP 服务的这种短连接，等待长连接断开可能需要较久的时间，因此为退出设置一个超时时间是有必要的，至此最终优化代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line">...</span><br><span class="line">process.on(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 记录日志</span></span><br><span class="line">    logger.error(err)</span><br><span class="line">    <span class="comment">// 发送自杀信号</span></span><br><span class="line">    process.send(&#123; <span class="attr">act</span>: <span class="string">&#x27;suicide&#x27;</span> &#125;)</span><br><span class="line">    <span class="comment">// 停止接收新的连接</span></span><br><span class="line">    worker.close(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        process.exit(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 设置超时时间 5 s，超过强制退出</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        process.exit(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// master.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> worker = fork(__dirname + <span class="string">&#x27;/worker.js&#x27;</span>)</span><br><span class="line">    worker.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message.act === <span class="string">&#x27;suicide&#x27;</span>) &#123;</span><br><span class="line">            createWorker()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    worker.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Worker &#x27;</span> + worker.pid + <span class="string">&#x27; exited.&#x27;</span>)</span><br><span class="line">        <span class="keyword">delete</span> workers[worker.pid]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 句柄转发</span></span><br><span class="line">    worker.send(<span class="string">&#x27;server&#x27;</span>, server)</span><br><span class="line">    workers[worker.pid] = worker</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Create worker. pid: &#x27;</span> + worker.pid)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>限量重启</strong></p><p>在通过自杀信号告知主进程可以使得新连接总是有进程服务，但是工作进程不能无限制地被重启，因为这种无意义的重启已经不符合预期的设置，极有可能是程序编写的错误。因此更好的解决方案是<strong>限量重启</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重启次数</span></span><br><span class="line"><span class="keyword">var</span> limit = <span class="number">10</span></span><br><span class="line"><span class="comment">// 时间单位</span></span><br><span class="line"><span class="keyword">var</span> during = <span class="number">6000</span></span><br><span class="line"><span class="keyword">var</span> restart = []</span><br><span class="line"><span class="keyword">var</span> isTooFrequently = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录重启时间</span></span><br><span class="line">    <span class="keyword">var</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">var</span> length = restart.push(time)</span><br><span class="line">    <span class="keyword">if</span> (length &gt; limit) &#123;</span><br><span class="line">        <span class="comment">// 取出最后10个记录</span></span><br><span class="line">        restart = restart.slice(limit * -<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一次重启到前10次重启之间的时间间隔</span></span><br><span class="line">    <span class="keyword">return</span> restart.length &gt;= limit &amp;&amp; restart[restart.length - <span class="number">1</span>] - restart[<span class="number">0</span>] &lt; during</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> createWorker = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否太过频繁</span></span><br><span class="line">    <span class="keyword">if</span> (isTooFrequently()) &#123;</span><br><span class="line">        <span class="comment">// 触发giveup事件后，不再重启</span></span><br><span class="line">        process.emit(<span class="string">&#x27;giveup&#x27;</span>, length, during)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> worker = fork(__dirname + <span class="string">&#x27;/worker.js&#x27;</span>)</span><br><span class="line">    worker.on(<span class="string">&#x27;exit&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Worker &#x27;</span> + worker.pid + <span class="string">&#x27; existed.&#x27;</span>)</span><br><span class="line">        <span class="keyword">delete</span> workers[worker.pid]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 重新启动新的进程</span></span><br><span class="line">    worker.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message.act === <span class="string">&#x27;suicide&#x27;</span>) &#123;</span><br><span class="line">            createWorker()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 句柄转发</span></span><br><span class="line">    worker.send(<span class="string">&#x27;server&#x27;</span>, server)</span><br><span class="line">    workers[worker.pid] = worker</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Create worker. pid：&#x27;</span> + worker.pid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>giveup 事件是比 uncaughtException 更严重的异常事件。uncaughtException 只代表集群中某个工作进程退出，在整体保证下，不会出现用户得不到服务的情况，但是这个 giveup 事件则表示集群中没有任何进程服务了，十分危险。</p><h4 id="3-负载均衡"><a class="markdownIt-Anchor" href="#3-负载均衡"></a> (3) 负载均衡</h4><img src="/assets/深入浅出NodeJS/20.jpg"><h4 id="4-状态共享"><a class="markdownIt-Anchor" href="#4-状态共享"></a> (4) 状态共享</h4><p>Node 进程中不宜存放过多数据，会加重垃圾回收的负担，同时 Node 也不允许在多个进程之间共享数据，解决数据共享问题最直接、简单的方式就是通过第三方来存储，比如数据库、磁盘文件、缓存服务等，所有工作进程启动时将其读取进内存中。但是这种方式还需要一种机制在数据一旦改变时通知到各个子进程使得他们的内部状态也得到更新。</p><p>实现这种同步机制的方式主要有两种：</p><ul><li>各个子进程向第三方进行定时轮询，但是这种方式如果轮训时间过短会形成并发处理，但如果轮训时间过长，数据发生改变时不能及时更新到子进程中，会有一定的延迟。</li><li>主动通知，我们可以通过通知进程来专门用来发送通知和查询状态，不处理任何业务逻辑，当数据发生变更时通知其他工作进程。</li></ul><h3 id="4-cluster-模块"><a class="markdownIt-Anchor" href="#4-cluster-模块"></a> 4、Cluster 模块</h3><img src="/assets/深入浅出NodeJS/21.jpg"><h2 id="十-测试"><a class="markdownIt-Anchor" href="#十-测试"></a> 十、测试</h2><img src="/assets/深入浅出NodeJS/22.jpg"><h2 id="十一-产品化"><a class="markdownIt-Anchor" href="#十一-产品化"></a> 十一、 产品化</h2><img src="/assets/深入浅出NodeJS/23.jpg">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;七-网络编程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#七-网络编程&quot;&gt;&lt;/a&gt; 七、网络编程&lt;/h2&gt;
&lt;h3 id=&quot;1-构建-tcp-服务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-构建-t</summary>
      
    
    
    
    <category term="Node" scheme="http://kyleezhang.com/categories/Node/"/>
    
    
    <category term="Node" scheme="http://kyleezhang.com/tags/Node/"/>
    
    <category term="读书笔记" scheme="http://kyleezhang.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Node中的网络编程</title>
    <link href="http://kyleezhang.com/2021/08/31/node-network/"/>
    <id>http://kyleezhang.com/2021/08/31/node-network/</id>
    <published>2021-08-31T10:52:38.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<p>网络编程的概念是&quot;使用套接字来达到进程间通信的目的&quot;。通常情况下，我们要使用网络提供的功能，可以有以下几种方式：</p><ul><li>使用应用软件提供的网络通信功能来获取网络服务，最著名的就是浏览器，它在应用层上使用 http 协议，在传输层基于 TCP 协议；</li><li>在命令行方式下使用 shell 命令获取系统提供的网络服务，如 telnet、ftp 等；</li><li>使用编程的方式通过系统调用获取操作系统提供给我们的网络服务。</li></ul><a id="more"></a><p>网络编程涉及到一个套接字（socket）的概念，所谓套接字，实际上是两个不同进程间进行通信的端口（这里的端口有别于IP地址中常用的端口），它是对网络层次模型中网络层及其下面各层操作的一个封装，为了让开发者能够使用各种语言调用操作系统提供的网络服务，在不同服务端语言中都使用了套接字这个概念，开发者只要获得一个套接字（socket），就可以使用套接字（socket）中各种方法来创建不同进程之间的连接进而达到通信目的。</p><p>Socket 源于 Unix，而 Unix 的基本哲学是『一些皆文件』，都可以用『打开open ==&gt; 读/写(read/write) ==&gt; 关闭(close)』模式来操作，Socket 也可以采用这种方法进行理解。关于 Socket，可以总结如下几点:</p><ul><li>可以实现底层通信，几乎所有的应用层都是通过 socket 进行通信的，因此『一切且socket』</li><li>对 TCP/IP 协议进行封装，便于应用层协议调用，属于二者之间的中间抽象层</li><li>各个语言都有相关实现，例如 C、C++、node</li><li>TCP/IP 协议族中，传输层存在两种通用协议: TCP、UDP，两种协议不同，因此 Socket 的参数不同，实现过程也不一样</li></ul><img src="/assets/node-network/01.jpeg" /><h2 id="node-中网络通信的架构实现"><a class="markdownIt-Anchor" href="#node-中网络通信的架构实现"></a> Node 中网络通信的架构实现</h2><p>Node 中的模块，从两种语言实现角度来说，存在 javscript、c++ 两部分，通过 process.binding 来建立关系。具体分析如下:</p><ul><li>标准的 Node 模块有 net、udp、dns、http、tls、https 等</li><li>V8 是 Chrome 的内核，提供了 JavaScript 解释运行功能，里面包含 tcp_wrap.h、udp_wrap.h、tls_wrap.h 等</li><li>OpenSSL 是基本的密码库，包括了 MD5、SHA1、RSA 等加密算法，构成了 Node 标准模块中的 crypto</li><li>cares 模块用于 DNS 的解析</li><li>libuv 实现了跨平台的异步编程</li><li>http_parser 用于 http 的解析</li></ul><img src="/assets/node-network/02.png" /><h2 id="net-模块"><a class="markdownIt-Anchor" href="#net-模块"></a> net 模块</h2><p>net 模块是基于 TCP 协议的 socket 网路编程模块，http 模块就是建立在该模块的基础上实现的，先来看看基本使用方法:</p><h3 id="1-创建-tcp-服务端"><a class="markdownIt-Anchor" href="#1-创建-tcp-服务端"></a> 1、创建 TCP 服务端</h3><p>创建一个TCP服务器，可以通过使用构造函数 <code>new net.Server</code> 或者使用工厂方法 <code>net.createServer</code>，这两个方法都会返回一个 net.Server 类，可接收两个可选参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line">server.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  socket.pipe(process.stdout);</span><br><span class="line">  socket.write(<span class="string">&#x27;data from server&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`server is on <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(server.address())&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者也可以采用另一种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net=<span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server=net.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;客户端和服务端建立连接&#x27;</span>);</span><br><span class="line">  server.getConnections(<span class="function"><span class="keyword">function</span>(<span class="params">err,count</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;当前连接数为%d&quot;</span>,count);</span><br><span class="line">  &#125;);</span><br><span class="line">  server.maxConnections=<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;tcp最大连接数为%d&#x27;</span>,server.maxConnections);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&#x27;error&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">e.code==<span class="string">&#x27;EADDRINUSE&#x27;</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;地址和端口被占用&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="string">&#x27;localhost&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//console.log(&#x27;服务器端开始监听...&#x27;);</span></span><br><span class="line">  <span class="keyword">var</span> address=server.address();</span><br><span class="line">  <span class="built_in">console</span>.log(address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在终端使用tenlent 0.0.0.0 3000 即可与之通信。</p><p>示例中我们使用 <code>const server = net.createServer();</code> 创建了 server 对象，那 server 对象有哪些特点:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net.js</span></span><br><span class="line"><span class="built_in">exports</span>.createServer = <span class="function"><span class="keyword">function</span>(<span class="params">options, connectionListener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Server(options, connectionListener);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Server</span>(<span class="params">options, connectionListener</span>) </span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="built_in">this</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> connectionListener === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.on(<span class="string">&#x27;connection&#x27;</span>, connectionListener);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">this</span>._handle = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Server, EventEmitter);</span><br></pre></td></tr></table></figure><p>首先我们看到 server 对象是一个 EventEmitter 实例，它的自定义事件有如下几种:</p><ul><li>listening：在调用 server.listen() 绑定端口或 Domain Socket 后触发，可以写作 server.listen(port, listeningListener)。</li><li>connection：每个客户端 socket 连接到服务器时触发，可以写作 net.createServer(options, connectionListener)。</li><li>close：服务器关闭时触发。server.close() 会停止接受新的 socket，但是保存已有的连接，等待所有的连接断开后触发。</li><li>error：服务器发生异常时触发。</li></ul><p>其次我们在 server 对象中发现了 _handle 属性，_handle 是 server 处理的句柄，属性值最终由 C++ 部分的 TCP、Pipe 类创建。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServerHandle</span>(<span class="params">address, port, addressType, fd</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fd === <span class="string">&#x27;number&#x27;</span> &amp;&amp; fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    handle = createHandle(fd);</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">port === -<span class="number">1</span> &amp;&amp; addressType === -<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    handle = <span class="keyword">new</span> Pipe();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handle = <span class="keyword">new</span> TCP();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHandle</span>(<span class="params">fd</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = TTYWrap.guessHandleType(fd);</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;PIPE&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> Pipe();</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;TCP&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> TCP();</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Unsupported fd type: &#x27;</span> + type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_handle 由 C++ 中的 Pipe、TCP 实现，主要用于 Node 进程通信中 socket 句柄传递，具体可查看<a href="https://cnodejs.org/topic/572b8a2c8783d212174bd72b">通过源码解析 Node.js 中进程间通信中的 socket 句柄传递</a>。</p><p>再来看看 connectionListener 事件的回调函数，里面包含一个 socket 对象，该对象是一个连接套接字，是个五元组 (server_host、server_ip、protocol、client_host、client_ip)，相关实现如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onconnection</span>(<span class="params">err, clientHandle</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> socket = <span class="keyword">new</span> Socket(&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">  self.emit(<span class="string">&#x27;connection&#x27;</span>, socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Socket 是继承了 stream.Duplex，所以 Socket 也是一个可读可写流，可以使用流的方法进行数据的处理。</p><p>接下来就是很关键的端口监听(port)，这是 server 与 client 的主要区别，代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  listen(self, ip, port, addressType, backlog, fd, exclusive);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params">self, address, port, addressType, backlog, fd, exclusive</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!cluster) cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cluster.isMaster || exclusive) &#123;</span><br><span class="line">    self._listen2(address, port, addressType, backlog, fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cluster._getServer(self, &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;, cb);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">err, handle</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    self._handle = handle;</span><br><span class="line">    self._listen2(address, port, addressType, backlog, fd);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Server.prototype._listen2 = <span class="function"><span class="keyword">function</span>(<span class="params">address, port, addressType, backlog, fd</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>._handle) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    rval = createServerHandle(address, port, addressType, fd);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>._handle = rval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._handle.onconnection = onconnection;</span><br><span class="line">  <span class="keyword">var</span> err = _listen(<span class="built_in">this</span>._handle, backlog);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_listen</span>(<span class="params">handle, backlog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> handle.listen(backlog || <span class="number">511</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码有几个点需要注意:</p><ul><li>监听的对象可以是端口、路径、定义好的 server 句柄、文件描述符</li><li>当通过 cluster 创建工作进程(worker)时，exclusive 判断是否进行 socket 连接的共享</li><li>事件监听最终还是通过 TCP/Pipe 的 listen 来实现</li><li>backlog 规定了 socket 连接的限制，默认最多为 511</li></ul><h3 id="2-创建-tcp-客户端"><a class="markdownIt-Anchor" href="#2-创建-tcp-客户端"></a> 2、创建 TCP 客户端</h3><p>创建一个 TCP 客户端链接可以使用构造函数 <code>new net.Socket</code> 或者其工厂方法 <code>net.createConnection</code>，创建成功后都会返回一个 net.Socket 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = net.createConnection(&#123;<span class="attr">port</span>:<span class="number">3000</span>, <span class="attr">host</span>:<span class="string">&#x27;localhost&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;connect&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;client connect&#x27;</span>);</span><br><span class="line">  client.write(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    client.end(<span class="string">&#x27;bye bye&#x27;</span>);</span><br><span class="line">  &#125;,<span class="number">10000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;client data&#x27;</span>, data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;error&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> error;</span><br><span class="line">  client.destroy();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;close&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;client close&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>服务器可以与多个客户端保存连接，每个连接都是典型的可读可写的 Stream 对象。它的自定义事件有如下几种:</p><ul><li>data：当一端调用 write() 发送数据，另外一端触发 data 事件。</li><li>end：当连接中的任一端发送 FIN 数据时，触发该事件。</li><li>connect：客户端 socket 与服务器连接成功适触发。</li><li>drain：rain 和 socket.write() 的返回值强关联，当任意一端调用 write()，当前这端会触发该事件。</li><li>error：异常时触发。</li><li>close：socket 关闭时触发。</li><li>timeout：一定时间连接不再活跃时，该事件触发，通知用户当前连接已经闲置。</li></ul><p>从上面可以看出基于TCP连接的通信具有的特点:</p><ul><li>面向连接，必须建立连接后才能够互相通信</li><li>TCP 连接是一对一的，就是说在 TCP 中，一个客户端 socket 连接一个服务端 socket，并且两者可以相互通信，通信是双向的</li><li>TCP 连接关闭的时候是可以只关闭一方的连接而保留单向通信</li><li>一个特定的 IP 加端口可以连接多个 TCP 客户端，也可以通过编程指定连接上限</li></ul><h2 id="dgram模块"><a class="markdownIt-Anchor" href="#dgram模块"></a> dgram模块</h2><p>跟 net 模块相比，基于 UDP 通信的 dgram 模块就简单了很多，因为不需要通过三次握手建立连接，所以整个通信的过程就简单了很多，对于数据准确性要求不太高的业务场景，可以使用该模块完成数据的通信。</p><h3 id="1-创建-udp-服务端"><a class="markdownIt-Anchor" href="#1-创建-udp-服务端"></a> 1、创建 UDP 服务端</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram=<span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server=dgram.createSocket(<span class="string">&#x27;udp4&#x27;</span>);</span><br><span class="line">server.on(<span class="string">&quot;message&quot;</span>,<span class="function">(<span class="params">msg,rinfo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;已接收到客户端发送的数据为&#x27;</span> + msg);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;客户端地址新信息为%j&quot;</span>, rinfo);</span><br><span class="line">  <span class="keyword">var</span> buff=<span class="keyword">new</span> Buffer(<span class="string">&quot;确认信息&quot;</span>+msg);</span><br><span class="line">  server.send(buff,<span class="number">0</span>,buff.length,rinfo.port,rinfo.address);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    server.unref();</span><br><span class="line">  &#125;,<span class="number">10000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&quot;listening&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> address = server.address();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器开始监听，地址信息为%j&quot;</span>,address);</span><br><span class="line">&#125;);</span><br><span class="line">server.bind(<span class="number">3000</span>,<span class="string">&#x27;localhost&#x27;</span>);</span><br></pre></td></tr></table></figure><p>从源码层面分析上述代码的原理实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.createSocket = <span class="function"><span class="keyword">function</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Socket(type, listener);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Socket</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> handle = newHandle(type);</span><br><span class="line">  <span class="built_in">this</span>._handle = handle;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">this</span>.on(<span class="string">&#x27;message&#x27;</span>, listener);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Socket, EventEmitter);</span><br><span class="line"><span class="keyword">const</span> UDP = process.binding(<span class="string">&#x27;udp_wrap&#x27;</span>).UDP;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newHandle</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type == <span class="string">&#x27;udp4&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="keyword">new</span> UDP();</span><br><span class="line">    handle.lookup = lookup4;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type == <span class="string">&#x27;udp6&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="keyword">new</span> UDP();</span><br><span class="line">    handle.lookup = lookup6;</span><br><span class="line">    handle.bind = handle.bind6;</span><br><span class="line">    handle.send = handle.send6;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Socket.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">port_ <span class="comment">/*, address, callback*/</span></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  startListening(self);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startListening</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket._handle.onmessage = onMessage;</span><br><span class="line">  socket._handle.recvStart();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">nread, handle, buf, rinfo</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  self.emit(<span class="string">&#x27;message&#x27;</span>, buf, rinfo);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Socket.prototype.send = <span class="function"><span class="keyword">function</span>(<span class="params">buffer, offset, length, port, address, callback</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  self._handle.lookup(address, <span class="function"><span class="keyword">function</span> <span class="title">afterDns</span>(<span class="params">ex, ip</span>) </span>&#123;</span><br><span class="line">    doSend(ex, self, ip, list, address, port, callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> SendWrap = process.binding(<span class="string">&#x27;udp_wrap&#x27;</span>).SendWrap;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSend</span>(<span class="params">ex, self, ip, list, address, port, callback</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> req = <span class="keyword">new</span> SendWrap();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> err = self._handle.send(req, list, list.length, port, ip, !!callback);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码存在几个点需要注意:</p><ul><li>UDP 模块没有继承 stream，仅仅继承了 EventEmit，后续的所有操作都是基于事件的方式，它的自定义事件如下：<ul><li>message：当 UDP socket 侦听网卡端口后，接收到消息时触发该事件。</li><li>listening：当 UDP 开始侦听时触发该事件。</li><li>close：调用 close() 方法时触发该事件，并不再触发 message 事件。</li><li>error：发生异常时触发该事件。</li></ul></li><li>UDP 在创建的时候需要注意 ipv4 和 ipv6</li><li>UDP 的 _handle 是由 UDP 类创建的</li><li>通信过程中可能需要进行 DNS 查询，解析出 ip 地址，然后再进行其他操作</li></ul><h3 id="2-创建-udp-客户端"><a class="markdownIt-Anchor" href="#2-创建-udp-客户端"></a> 2、创建 UDP 客户端</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram=<span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> message= Buffer.from(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client=dgram.createSocket(<span class="string">&#x27;udp4&#x27;</span>);</span><br><span class="line">client.send(message,<span class="number">0</span>,message.length, <span class="number">3000</span>,<span class="string">&quot;localhost&quot;</span>, <span class="function">(<span class="params">err,bytes</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(<span class="string">&#x27;数据发送失败&#x27;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">&quot;已发送%d字节数据&quot;</span>,bytes);</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg,rinfo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;已接收到服务端发送的数据%s&quot;</span>,msg);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器地址信息为%j&quot;</span>,rinfo);</span><br><span class="line">  client.close();</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">&quot;close&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;socket端口被关闭&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-unix-domain-socket-ipc"><a class="markdownIt-Anchor" href="#3-unix-domain-socket-ipc"></a> 3、UNIX Domain Socket IPC</h3><p>socket API 原本是为网络通讯设计的，但后来在 socket 的框架上发展出一种 IPC 机制，就是 UNIX Domain Socket。虽然网络 socket 也可用于同一台主机的进程间通讯（通过 loopback 地址 127.0.0.1），但是 UNIX Domain Socket 用于 IPC 更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC 机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。UNIX Domain Socket 也提供面向流和面向数据包两种 API 接口，类似于 TCP 和 UDP，但是面向消息的 UNIX Domain Socket 也是可靠的，消息既不会丢失也不会顺序错乱。<br />UNIX Domain Socket 与网络 socket 编程最明显的不同在于地址格式不同，用结构体 sockaddr_un 表示，网络编程的 socket 地址是IP地址加端口号，而 UNIX Domain Socket 的地址是一个 socket 类型的文件在文件系统中的路径，这个 socket 文件由 bind() 调用创建，如果调用 bind() 时该文件已存在，则 bind() 错误返回。</p><p><strong>创建一个 UNIX 域套接字服务器</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">  c.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;client disconnected&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  c.write(<span class="string">&quot;hello\r\n&quot;</span>);</span><br><span class="line">  c.pipe(c);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// server.listen(path[, backlog][, callback]) for IPC servers</span></span><br><span class="line">server.listen(<span class="string">&quot;/tmp/echo.sock&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;server bound&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>连接UNIX 域套接字服务器</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -U /tmp/echo.sock <span class="comment"># -U — Use UNIX domain socket</span></span><br></pre></td></tr></table></figure><blockquote><p>nc（netcat）可以用于涉及 TCP 或 UDP 的相关内容，比如通过它我们可以打开 TCP 连接，发送 UDP 数据包，监听任意的 TCP 和 UDP 端口，执行端口扫描和处理 IPv4 和 IPv6 等。</p></blockquote><h2 id="dns-模块"><a class="markdownIt-Anchor" href="#dns-模块"></a> dns 模块</h2><p>DNS(Domain Name System) 用于域名解析，也就是找到 host 对应的 ip 地址，在计算机网络中，这个工作是由网络层的 ARP 协议实现。在 node 中存在 net 模块来完成相应功能，其中 dns 里面的函数分为两类:</p><ul><li>第一类函数，使用底层操作系统工具进行域名解析，且无需进行网络通信。 这类函数只有一个：dns.lookup()。</li><li>第二类函数，连接到一个真实的 DNS 服务器进行域名解析，且始终使用网络进行 DNS 查询。 这类函数包含了 dns 模块中除 dns.lookup() 以外的所有函数。 这些函数使用与 dns.lookup() 不同的配置文件（例如 /etc/hosts）。 这类函数适合于那些不想使用底层操作系统工具进行域名解析、而是想使用网络进行 DNS 查询的开发者。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">&#x27;dns&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&#x27;bj.meituan.com&#x27;</span>;</span><br><span class="line">dns.lookup(host, <span class="function">(<span class="params">err, address, family</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;by net.lookup, address is: %s, family is: %s&#x27;</span>, address, family);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dns.resolve(host, <span class="function">(<span class="params">err, address</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;by net.resolve, address is: %s&#x27;</span>, address);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// by net.resolve, address is: 103.37.152.41</span></span><br><span class="line"><span class="comment">// by net.lookup, address is: 103.37.152.41, family is: 4</span></span><br></pre></td></tr></table></figure><p>在这种情况下，二者解析的结果是一样的，但是假如我们修改本地的/etc/hosts文件呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在&#x2F;etc&#x2F;host文件中，增加:</span><br><span class="line">10.10.10.0 bj.meituan.com</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后再执行上述文件，结果是:</span><br><span class="line">by net.resolve, address is: 103.37.152.41</span><br><span class="line">by net.lookup, address is: 10.10.10.0, family is: 4</span><br></pre></td></tr></table></figure><p>接下来分析下dns的内部实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cares = process.binding(<span class="string">&#x27;cares_wrap&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> GetAddrInfoReqWrap = cares.GetAddrInfoReqWrap;</span><br><span class="line"><span class="built_in">exports</span>.lookup = <span class="function"><span class="keyword">function</span> <span class="title">lookup</span>(<span class="params">hostname, options, callback</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  callback = makeAsync(callback);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> req = <span class="keyword">new</span> GetAddrInfoReqWrap();</span><br><span class="line">  req.callback = callback;</span><br><span class="line">  <span class="keyword">var</span> err = cares.getaddrinfo(req, hostname, family, hints);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolver</span>(<span class="params">bindingName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> binding = cares[bindingName];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">name, callback</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    callback = makeAsync(callback);</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> QueryReqWrap();</span><br><span class="line">    req.callback = callback;</span><br><span class="line">    <span class="keyword">var</span> err = binding(req, name);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> resolveMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">exports</span>.resolve4 = resolveMap.A = resolver(<span class="string">&#x27;queryA&#x27;</span>);</span><br><span class="line"><span class="built_in">exports</span>.resolve6 = resolveMap.AAAA = resolver(<span class="string">&#x27;queryAaaa&#x27;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">exports</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">hostname, type_, callback_</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  resolver = resolveMap[type_];</span><br><span class="line">  <span class="keyword">return</span> resolver(hostname, callback);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码有几个点需要关注:</p><ul><li>lookup 与 resolve 存在差异，使用的时候需要注意</li><li>不管是 lookup 还是 resolve，均依赖于 cares 库</li><li>域名解析的 type 很多: resolve4、resolve6、resolveCname、resolveMx、resolveNs、resolveTxt、resolveSrv、resolvePtr、resolveNaptr、resolveSoa、reverse</li></ul><h2 id="http-模块"><a class="markdownIt-Anchor" href="#http-模块"></a> http 模块</h2><p>在WEB开发中，HTTP作为最流行、最重要的应用层，是每个开发人员应该熟知的基础知识，我面试的时候必问的一块内容。同时，大多数同学接触node时，首先使用的恐怕就是http模块。先来一个简单的demo看看:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.setHeader(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  res.write(<span class="string">&#x27;&lt;!doctype&gt;&#x27;</span>);</span><br><span class="line">  res.end(<span class="string">`&lt;html&gt;&lt;/html&gt;`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;server is on &#x27;</span>, server.address());</span><br><span class="line">  <span class="keyword">var</span> req = http.request(&#123; <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="attr">port</span>: <span class="number">3000</span>&#125;);</span><br><span class="line">  req.on(<span class="string">&#x27;response&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;data from server &#x27;</span>, chunk.toString()) );</span><br><span class="line">    res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> server.close() );</span><br><span class="line">  &#125;);</span><br><span class="line">  req.end();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出结果如下:</span></span><br><span class="line"><span class="comment">// server is on  &#123; address: &#x27;::&#x27;, family: &#x27;IPv6&#x27;, port: 3000 &#125;</span></span><br><span class="line"><span class="comment">// data from server  &lt;!doctype&gt;</span></span><br><span class="line"><span class="comment">// data from server  &lt;html&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-httpagent"><a class="markdownIt-Anchor" href="#1-httpagent"></a> 1、http.Agent</h3><p>因为HTTP协议是无状态协议，每个请求均需通过三次握手建立连接进行通信，众所周知三次握手、慢启动算法、四次挥手等过程很消耗时间，因此HTTP1.1协议引入了keep-alive来避免频繁的连接。那么对于tcp连接该如何管理呢？http.Agent就是做这个工作的。先看看源码中的关键部分:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Agent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  EventEmitter.call(<span class="built_in">this</span>);</span><br><span class="line">  ...</span><br><span class="line">  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;</span><br><span class="line">  self.maxFreeSockets = self.options.maxFreeSockets || <span class="number">256</span>;</span><br><span class="line">  ...</span><br><span class="line">  self.requests = &#123;&#125;; <span class="comment">// 请求队列</span></span><br><span class="line">  self.sockets = &#123;&#125;; <span class="comment">// 正在使用的tcp连接池</span></span><br><span class="line">  self.freeSockets = &#123;&#125;; <span class="comment">// 空闲的连接池</span></span><br><span class="line">  self.on(<span class="string">&#x27;free&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket, options</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// requests、sockets、freeSockets的读写操作</span></span><br><span class="line">    self.requests[name].shift().onSocket(socket);</span><br><span class="line">    freeSockets.push(socket);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Agent.defaultMaxSockets = <span class="literal">Infinity</span>;</span><br><span class="line">util.inherits(Agent, EventEmitter);</span><br><span class="line"><span class="comment">// 关于socket的相关增删改查操作</span></span><br><span class="line">Agent.prototype.addRequest = <span class="function"><span class="keyword">function</span>(<span class="params">req, options</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (freeLen) &#123;</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="built_in">this</span>.freeSockets[name].shift();</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.sockets[name].push(socket);</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockLen &lt; <span class="built_in">this</span>.maxSockets) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.requests[name].push(req);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Agent.prototype.createSocket = <span class="function"><span class="keyword">function</span>(<span class="params">req, options, cb</span>) </span>&#123; ... &#125;</span><br><span class="line">Agent.prototype.removeSocket = <span class="function"><span class="keyword">function</span>(<span class="params">s, options</span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="built_in">exports</span>.globalAgent = <span class="keyword">new</span> Agent();</span><br></pre></td></tr></table></figure><p>上述代码有几个点需要注意:</p><ul><li>maxSockets默认情况下，没有tcp连接数量的上限(Infinity)</li><li>连接池管理的核心是对sockets、freeSockets的增删查</li><li>globalAgent会作为http.ClientRequest的默认agent</li></ul><p>下面可以测试下agent对请求本身的限制:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// req.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;ok &#x27;</span>, i++);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> max = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>; i&lt;max; i++</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req = http.request(&#123; <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="attr">port</span>: <span class="number">3000</span>&#125;);</span><br><span class="line">    req.on(<span class="string">&#x27;response&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;data from server &#x27;</span>, chunk.toString()) );</span><br><span class="line">      res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> server.close() );</span><br><span class="line">    &#125;);</span><br><span class="line">    req.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在终端中执行time node ./req.js，结果为:</span></span><br><span class="line"><span class="comment">// real  0m1.123s</span></span><br><span class="line"><span class="comment">// user  0m0.102s</span></span><br><span class="line"><span class="comment">// sys 0m0.024s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在req.js中添加下面代码</span></span><br><span class="line">http.globalAgent.maxSockets = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 然后同样time node ./req.js，结果为:</span></span><br><span class="line">real  <span class="number">0</span>m4<span class="number">.141</span>s</span><br><span class="line">user  <span class="number">0</span>m0<span class="number">.103</span>s</span><br><span class="line">sys <span class="number">0</span>m0<span class="number">.024</span>s</span><br></pre></td></tr></table></figure><p>当设置maxSockets为某个值时，tcp的连接就会被限制在某个值，剩余的请求就会进入requests队列里面，等有空余的socket连接后，从request队列中出栈，发送请求。</p><h3 id="2-httpclientrequest"><a class="markdownIt-Anchor" href="#2-httpclientrequest"></a> 2、http.ClientRequest</h3><p>当执行http.request时，会生成ClientRequest对象，该对象虽然没有直接继承Stream.Writable，但是继承了http.OutgoingMessage，而http.OutgoingMessage实现了write、end方法，因为可以当跟stream.Writable一样的使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = http.request(&#123; <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="attr">port</span>: <span class="number">3000</span>, <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>&#125;);</span><br><span class="line">req.on(<span class="string">&#x27;response&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;data from server &#x27;</span>, chunk.toString()) );</span><br><span class="line">  res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> server.close() );</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 直接使用pipe，在request请求中添加数据</span></span><br><span class="line">fs.createReadStream(<span class="string">&#x27;./data.json&#x27;</span>).pipe(req);</span><br></pre></td></tr></table></figure><p>接下来，看看http.ClientRequest的实现, ClientRequest继承了OutgoingMessage:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OutgoingMessage = <span class="built_in">require</span>(<span class="string">&#x27;_http_outgoing&#x27;</span>).OutgoingMessage;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClientRequest</span>(<span class="params">options, cb</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  OutgoingMessage.call(self);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(ClientRequest, OutgoingMessage);</span><br></pre></td></tr></table></figure><h3 id="3-httpserver"><a class="markdownIt-Anchor" href="#3-httpserver"></a> 3、http.Server</h3><p>http.createServer其实就是创建了一个http.Server对象，关键源码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.createServer = <span class="function"><span class="keyword">function</span>(<span class="params">requestListener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Server(requestListener);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Server</span>(<span class="params">requestListener</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  net.Server.call(<span class="built_in">this</span>, &#123; <span class="attr">allowHalfOpen</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  <span class="keyword">if</span> (requestListener) &#123;</span><br><span class="line">    <span class="built_in">this</span>.addListener(<span class="string">&#x27;request&#x27;</span>, requestListener);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">this</span>.addListener(<span class="string">&#x27;connection&#x27;</span>, connectionListener);</span><br><span class="line">  <span class="built_in">this</span>.timeout = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Server, net.Server);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectionListener</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  socket.on(<span class="string">&#x27;end&#x27;</span>, socketOnEnd);</span><br><span class="line">  socket.on(<span class="string">&#x27;data&#x27;</span>, socketOnData)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个需要要关注的点:</p><ul><li>服务的创建依赖于net.server，通过net.server在底层实现服务的创建</li><li>默认情况下，服务的超时时间为2分钟</li><li>connectionListener处理tcp连接后的行为，跟net保持一致</li></ul><h3 id="4-httpserverresponse"><a class="markdownIt-Anchor" href="#4-httpserverresponse"></a> 4、http.ServerResponse</h3><p>看node.org官方是如何介绍server端的response对象的:</p><blockquote><p>This object is created internally by an HTTP server–not by the user. It is passed as the second parameter to the ‘request’ event.</p></blockquote><blockquote><p>The response implements, but does not inherit from, the Writable Stream interface.</p></blockquote><p>跟http.ClientRequest很像，继承了OutgoingMessage，没有继承Stream.Writable，但是实现了Stream的功能，可以跟Stream.Writable一样灵活使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ServerResponse</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  OutgoingMessage.call(<span class="built_in">this</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(ServerResponse, OutgoingMessage);</span><br></pre></td></tr></table></figure><h3 id="5-httpincomingmessage"><a class="markdownIt-Anchor" href="#5-httpincomingmessage"></a> 5、http.IncomingMessage</h3><blockquote><p>An IncomingMessage object is created by http.Server or http.ClientRequest and passed as the first argument to the ‘request’ and ‘response’ event respectively. It may be used to access response status, headers and data.</p></blockquote><p>http.IncomingMessage有两个地方时被内部创建，一个是作为server端的request，另外一个是作为client请求中的response，同时该类显示地继承了Stream.Readable。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IncomingMessage</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  Stream.Readable.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.socket = socket;</span><br><span class="line">  <span class="built_in">this</span>.connection = socket;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(IncomingMessage, Stream.Readable);</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="http://zhenhua-lee.github.io/node/socket.html">初步研究node中的网络通信模块</a></p><p><a href="https://github.com/kekobin/blog/issues/32">node基础篇之网络编程</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络编程的概念是&amp;quot;使用套接字来达到进程间通信的目的&amp;quot;。通常情况下，我们要使用网络提供的功能，可以有以下几种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用应用软件提供的网络通信功能来获取网络服务，最著名的就是浏览器，它在应用层上使用 http 协议，在传输层基于 TCP 协议；&lt;/li&gt;
&lt;li&gt;在命令行方式下使用 shell 命令获取系统提供的网络服务，如 telnet、ftp 等；&lt;/li&gt;
&lt;li&gt;使用编程的方式通过系统调用获取操作系统提供给我们的网络服务。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Node" scheme="http://kyleezhang.com/categories/Node/"/>
    
    
    <category term="Node" scheme="http://kyleezhang.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>无包构建方案解析</title>
    <link href="http://kyleezhang.com/2021/08/16/no-bundle/"/>
    <id>http://kyleezhang.com/2021/08/16/no-bundle/</id>
    <published>2021-08-16T10:02:00.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<p>什么是无包构建呢？这是一个与基于模块化打包的构建方案相对的概念。</p><p>目前主流的构建工具，例如 Webpack、Rollup 等都是基于一个或多个入口点模块，通过依赖分析将有依赖关系的模块打包到一起，最后形成少数几个产物代码包，因此这些工具也被称为打包工具。只不过，这些工具的构建过程除了打包外，还包括了模块编译和代码优化等，因此称为打包式构建工具或许更恰当。</p><p>而无包构建是指这样一类构建方式：在构建时只需处理模块的编译而无须打包，把模块间的<strong>依赖关系完全交给浏览器来处理</strong>。</p><a id="more"></a><p>在详细讲解无包构建之前我们需要先介绍一下 script 标签的三个属性：</p><ul><li><strong>async 属性</strong>。立即请求文件，但不阻塞渲染引擎，而是文件加载完毕后阻塞渲染引擎并立即执行文件内容。</li><li><strong>defer 属性</strong>。立即请求文件，但不阻塞渲染引擎，等到解析完 HTML 之后再执行文件内容。</li><li><strong>HTML5 标准 type 属性，对应值为“module”</strong>。让浏览器按照 ECMA Script 6 标准将文件当作模块进行解析，默认阻塞效果同 defer，也可以配合 async 在请求完成后立即执行。</li></ul><p>具体效果如下图所示：</p><img src="/assets/no-bundle/01.png"><p>通过HTML5 标准 type 属性浏览器会加载入口模块，分析依赖后，再通过网络请求加载被依赖的模块。通过这样的方式简化构建时的处理过程，提升构建效率。这种通过浏览器原生的模块进行解析的方式又称为 Native-ESM（Native ES Module）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// ./src/index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./modules/foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.src/modules/foo.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; appendHTML &#125; <span class="keyword">from</span> <span class="string">&#x27;./common.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;https://cdn.jsdelivr.net/npm/lodash-es@4.17.15/slice.js&#x27;</span>).then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;...&#125;)</span><br></pre></td></tr></table></figure><img src="/assets/no-bundle/02.png" ><p>从示例中可以看到，在没有任何构建工具处理的情况下，在页面中引入带有 type=“module” 属性的 script，浏览器就会在加载入口模块时依次加载了所有被依赖的模块。下面我们就来深入了解一下这种基于浏览器加载 JS 模块的技术的细节。</p><h2 id="注意点"><a class="markdownIt-Anchor" href="#注意点"></a> 注意点</h2><p>我们来总结这种加载方式的注意点。</p><h3 id="1-html-中的-script-引用"><a class="markdownIt-Anchor" href="#1-html-中的-script-引用"></a> 1、HTML 中的 Script 引用</h3><ul><li>入口模块文件在页面中引用时需要带上**type=“module”**属性。对应的，存在 type=“nomodule”，即支持 ES Module 的现代浏览器，它会忽略 type=“nomodule” 属性的 script，因此可以用作旧浏览器中的降级方案。</li><li>带有 type=“module” 属性的 script在浏览器中通过 defer 的方式异步执行（异步下载，不阻塞 HTML，顺次执行），即使是行内的 script 代码也遵循这一原则（而普通的行内 script 代码则忽略 defer 属性）。</li><li>带有 type=“module” 属性且带有async属性的 script，在浏览器中通过 async 的方式异步执行（异步下载，不阻塞 HTML，按该模块和所依赖的模块下载完成的先后顺序执行，无视 DOM 中的加载顺序），即使是行内的 script 代码，也遵循这一原则（而普通的行内 script 代码则忽略 async 属性）。</li><li>即使多次加载相同模块，也只会执行一次。</li></ul><h3 id="2-模块内依赖的引用"><a class="markdownIt-Anchor" href="#2-模块内依赖的引用"></a> 2、模块内依赖的引用</h3><ul><li>只能使用 <code>import ... from '...'</code> 的 ES6 风格的模块导入方式，或者使用 <code>import(...).then(...)</code> 的 ES6 动态导入方式，不支持其他模块化规范的引用方式（例如 require、define 等）。</li><li>导入的模块只支持使用相对路径（’/xxx’, ‘./xxx’, ‘…/xxx’）和 URL 方式（‘<a href="https://xxx">https://xxx</a>’, ‘<a href="http://xxx">http://xxx</a>’）进行引用，不支持直接使用包名开头的方式（‘xxxx’, ‘xxx/xxx’）。</li><li>只支持引用MIME Type为 text/javascript 方式的模块，不支持其他类型文件的加载（例如 CSS 等）。</li></ul><h2 id="为什么需要构建工具"><a class="markdownIt-Anchor" href="#为什么需要构建工具"></a> 为什么需要构建工具</h2><p>从上面的技术细节中我们会发现，对于一个普通的项目而言，要使用这种加载方案仍然有几个主要问题：</p><ul><li>许多其他类型的文件需要编译处理为 ES6 模块才能被浏览器正常加载（JSX、Vue、TS、CSS、Image 等）。</li><li>许多第三方依赖包在通过第三方 URL 引用时，不仅过程烦琐，而且往往难以进行灵活的版本控制与更新，因此需要合适的方式来解决引用路径的问题。</li><li>对于现实中的项目开发而言，一些便利的辅助开发技术，例如热更新等还是需要由构建工具来提供。</li></ul><p>下面，我们分析 Vite 和 Snowpack 这两个有代表性的构建工具是如何解决上面的问题的</p><h2 id="vite"><a class="markdownIt-Anchor" href="#vite"></a> Vite</h2><p>Vite 是 Vue 框架的作者尤雨溪最新推出的基于 Native-ESM 的 Web 构建工具。它在开发环境下基于 Native-ESM 处理构建过程，只编译不打包，在生产环境下则基于 Rollup 打包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm init vite-app example-vite</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> example-vite</span><br><span class="line"></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><img src="/assets/no-bundle/03.png"><p>可以看到，运行示例代码后，在浏览器中只引入了 src/main.js 这一个入口模块，但是在网络面板中却依次加载了若干依赖模块，包括外部模块 vue 和 css。依赖图如下：</p><img src="/assets/no-bundle/04.png"><p>可以看到，经过 Vite 处理后，浏览器中加载的模块与源代码中导入的模块相比发生了变化，这些变化包括对外部依赖包的处理，对 vue 文件的处理，对 css 文件的处理等。下面我们就来逐个分析其中的变化。</p><h3 id="1-对导入模块的解析"><a class="markdownIt-Anchor" href="#1-对导入模块的解析"></a> 1、对导入模块的解析</h3><h4 id="1对-html-文件的预处理"><a class="markdownIt-Anchor" href="#1对-html-文件的预处理"></a> (1)对 HTML 文件的预处理</h4><p>当启动 Vite 时，会通过 serverPluginHtml.ts 注入 /vite/client 运行时的依赖模块，该模块用于处理热更新，以及提供更新 CSS 的方法 updateStyle。</p><h4 id="2对外部依赖包的解析"><a class="markdownIt-Anchor" href="#2对外部依赖包的解析"></a> (2)对外部依赖包的解析</h4><p>首先是对不带路径前缀的外部依赖包（也称为Bare Modules）的解析，比如 ‘vue’ 模块，但是在浏览器的网络请求中变为了请求 /@module/vue。</p><p>这个解析过程在 Vite 中主要通过三个文件来处理：</p><ul><li>resolver.ts 负责找到对应在 node_modules 中的真实依赖包代码（Vite 会在启动服务时对项目 package.json 中的 dependencies 做预处理读取并存入缓存目录 node_modules/.vite_opt_cache 中）。</li><li>serverPluginModuleRewrite.ts 负责把源码中的 bare modules 加上 /@module/ 前缀。</li><li>serverPluginModuleResolve.ts 负责解析加上前缀后的模块。</li></ul><h4 id="3对-vue文件的解析"><a class="markdownIt-Anchor" href="#3对-vue文件的解析"></a> (3)对 Vue文件的解析</h4><p>对 Vue 文件的解析是通过 serverPluginVue.ts 处理的，分离出 Vue 代码中的 script/template/style 代码片段，并分别转换为 JS 模块，然后将 template/style 模块的 import写到script 模块代码的头部。因此在浏览器访问时，一个 Vue 源代码文件会分裂为 2~3 的关联请求（例如上面的 /src/App.vue 和 /src/App.vue?type=template，如果 App.vue 中包含 <code>&lt;style&gt;</code> 则会产生第 3 个请求 <code>/src/App.vue?type=style</code>）。</p><h4 id="4对-css-文件的解析"><a class="markdownIt-Anchor" href="#4对-css-文件的解析"></a> (4)对 CSS 文件的解析</h4><p>对 CSS 文件的解析是通过 serverPluginCSS.ts 处理的，解析过程主要是将 CSS 文件的内容转换为下面的 JS 代码模块，其中的 updateStyle 由注入 HTML 中的 /vite/client 模块提供，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; updateStyle &#125; <span class="keyword">from</span> <span class="string">&quot;/vite/client&quot;</span></span><br><span class="line"><span class="keyword">const</span> css = <span class="string">&quot;...&quot;</span></span><br><span class="line">updateStyle(<span class="string">&quot;\&quot;...\&quot;&quot;</span>, css) <span class="comment">// id, cssContent</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> css</span><br></pre></td></tr></table></figure><p>以上就是示例代码中主要文件类型的基本解析逻辑，可以看到，Vite 正是通过这些解析器来解决不同类型文件以 JS 模块的方式在浏览器中加载的问题。在 Vite 源码中还包含了其他更多文件类型的解析器，例如 JSON、TS、SASS 等，这里就不一一列举了，详情可查看<a href="https://github.com/vitejs/vite">官方文档</a></p><h3 id="2-vite-中的其他辅助功能"><a class="markdownIt-Anchor" href="#2-vite-中的其他辅助功能"></a> 2、Vite 中的其他辅助功能</h3><p>除了提供这些解析器的能力外，Vite 还提供了其他便捷的构建功能，大致整理如下：</p><ul><li>多框架：除了在默认的 Vue 中使用外，还支持在 React 和 Preact 项目中使用。工具默认提供了 Vue、React 和 Preact 对应的脚手架模板。</li><li>热更新（HMR）：默认提供的 3 种框架的脚手架模板中都内置了 HMR 功能，同时也提供了 HMR 的 API 供第三方插件或项目代码使用。</li><li>自定义配置文件：支持使用自定义配置文件来细化构建配置，配置项功能参考 <a href="https://github.com/vuejs/vite/blob/master/src/node/config.ts">config.ts</a>。</li><li>HTTPS 与 HTTP/2：支持使用 --https 启动参数来开启使用 HTTPS 和 HTTP/2 协议的开发服务器。</li><li>服务代理：在自定义配置中支持配置代理，将部分请求代理到第三方服务。</li><li>模式与环境变量：支持通过 mode 来指定构建模式为 development 或 production。相应模式下自动读取 dotenv 类型的环境变量配置文件（例如 .env.production.local）。</li><li>生产环境打包：生产环境使用 Rollup 进行打包，支持传入自定义配置，配置项功能参考 <a href="https://github.com/vitejs/vite/blob/master/src/node/build/index.ts">build/index.ts</a>。</li></ul><h3 id="3-vite-使用限制"><a class="markdownIt-Anchor" href="#3-vite-使用限制"></a> 3、Vite 使用限制</h3><p>Vite 的使用限制如下：</p><ul><li>面向支持 ES6 的现代浏览器，在生产环境下，编译目标参数 esBuildTarget 的默认值为 es2019，最低支持版本为 es2015（因为内部会使用 esbuild 处理编译压缩，用来获得最快的构建速度）。</li><li>对 Vue 框架的支持目前仅限于最新的 Vue 3 版本，不兼容更低版本。</li></ul><h2 id="snowpack"><a class="markdownIt-Anchor" href="#snowpack"></a> SnowPack</h2><p>Snowpack 是另一个比较知名的无包构建工具，从整体功能来说和上述 Vite工具提供的功能大致相同，主要差异点在 Snowpack 在生产环境下默认使用无包构建而非打包模式（可以通过引入打包插件例如 @snowpack/plugin-webpack 来实现打包模式），而 Vite 仅在开发模式下使用。</p><h3 id="1-与-vite-相同的功能点"><a class="markdownIt-Anchor" href="#1-与-vite-相同的功能点"></a> 1、与 Vite 相同的功能点</h3><p>两者都支持各种代码转换加载器、热更新、环境变量（需要安装 dotenv 插件）、服务代理、HTTPS 与 HTTP/2 等。</p><h3 id="2-与-vite-的差异点"><a class="markdownIt-Anchor" href="#2-与-vite-的差异点"></a> 2、与 Vite 的差异点</h3><ul><li>相同的功能，实现细节不同：例如对 Bare Module 的处理，除了转换后前缀名称不同外（Vite 使用 /@module/ 前缀，而 Snowpack 使用 /web_modules/ 前缀)，Vite 支持类似 “AAA/BBB” 类型的子模块引用方式，而 Snowpack 目前尚不支持。</li><li>插件体系：除了版本差异外，Snowpack 提供了较完善的插件体系，支持用户和社区发布自定义插件，而 Vite 虽然也内置了许多插件，但目前并没有提供自定义插件的相关文档。</li><li>打包工具：在生产环境下，Vite 使用 Rollup 作为打包工具，而 Snowpack 则需要引入插件来实现打包功能，官方支持的打包插件有 @snowpack/plugin-webpack 和 @snowpack/plugin-parcel，暂未提供 Rollup 对应的插件。</li><li>特殊优化：Vite 中内置了对 Vue 的大量构建优化，因此对 Vue 项目而言，选择 Vite 通常可以获得更好的开发体验。</li></ul><h2 id="无包构建与打包构建"><a class="markdownIt-Anchor" href="#无包构建与打包构建"></a> 无包构建与打包构建</h2><p>通过上面的 Vite 等无包构建工具的功能介绍可以发现，同 Webpack 等主流打包构建工具相比，无包构建流程的优缺点都十分明显</p><h3 id="1-无包构建的优点"><a class="markdownIt-Anchor" href="#1-无包构建的优点"></a> 1、无包构建的优点</h3><p>无包构建的最大优势在于构建速度快，尤其是启动服务的初次构建速度要比目前主流的打包构建工具要快很多，原因如下：</p><ul><li>初次构建启动快：打包构建流程在初次启动时需要进行一系列的模块依赖分析与编译，而在无包构建流程中，这些工作都是在浏览器渲染页面时异步处理的，启动服务时只需要做少量的优化处理即可（例如缓存项目依赖的 Bare Modules），所以启动非常快。</li><li>按需编译：在打包构建流程中，启动服务时即需要完整编译打包所有模块，而无包构建流程是在浏览器渲染时，根据入口模块分析加载所需模块，编译过程按需处理，因此相比之下处理内容更少，速度也会更快</li><li>增量构建速度快：在修改代码后的 rebuild 过程中，主流的打包构建中仍然包含编译被修改的模块和打包产物这两个主要流程，因此相比之下，只需处理编译单个模块的无包构建在速度上也会更胜一筹（尽管在打包构建工具中，也可以通过分包等方式尽可能地减少两者的差距）。</li></ul><h3 id="2-无包构建的缺点"><a class="markdownIt-Anchor" href="#2-无包构建的缺点"></a> 2、无包构建的缺点</h3><ul><li><p>浏览器网络请求数量剧增：无包构建最主要面对的问题是，它的运行模式决定了在一般项目里，渲染页面所需发起的请求数远比打包构建要多得多，使得打开页面会产生瀑布式的大量网络请求，将对页面的渲染造成延迟。这对于服务稳定性和访问性能要求更高的生产环境而言，通常是不太能接受的，尤其对不支持 HTTP/2 的服务器而言，这种处理更是灾难性的。因此，一般是在开发环境下才使用无包构建，在生产环境下则仍旧使用打包构建。</p></li><li><p>浏览器的兼容性：无包构建要求浏览器支持 JavaScript module 特性，尽管目前的主流浏览器已大多支持，但是对于需要兼容旧浏览器的项目而言，仍然不可能在生产环境下使用。而在开发环境下则通常没有这种顾虑。</p></li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>拉勾教育专栏《前端工程化精讲》</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是无包构建呢？这是一个与基于模块化打包的构建方案相对的概念。&lt;/p&gt;
&lt;p&gt;目前主流的构建工具，例如 Webpack、Rollup 等都是基于一个或多个入口点模块，通过依赖分析将有依赖关系的模块打包到一起，最后形成少数几个产物代码包，因此这些工具也被称为打包工具。只不过，这些工具的构建过程除了打包外，还包括了模块编译和代码优化等，因此称为打包式构建工具或许更恰当。&lt;/p&gt;
&lt;p&gt;而无包构建是指这样一类构建方式：在构建时只需处理模块的编译而无须打包，把模块间的&lt;strong&gt;依赖关系完全交给浏览器来处理&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="前端工程化" scheme="http://kyleezhang.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="Vite" scheme="http://kyleezhang.com/tags/Vite/"/>
    
  </entry>
  
  <entry>
    <title>谈谈微服务</title>
    <link href="http://kyleezhang.com/2021/08/15/microservices/"/>
    <id>http://kyleezhang.com/2021/08/15/microservices/</id>
    <published>2021-08-15T21:41:42.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<p>早些年，各大互联网公司的应用技术栈大致可分为 LAMP（Linux + Apache + MySQL + PHP）和 MVC（Spring + iBatis/Hibernate + Tomcat）两大流派。无论是 LAMP 还是 MVC，都是为单体应用架构设计的，其优点是学习成本低，开发上手快，测试、部署、运维也比较方便，甚至一个人就可以完成一个网站的开发与部署。</p><p>以 MVC 架构为例，业务通常是通过部署一个 WAR 包到 Tomcat 中，然后启动 Tomcat，监听某个端口即可对外提供服务。早期在业务规模不大、开发团队人员规模较小的时候，采用单体应用架构，团队的开发和运维成本都可控。但是单体应用架构的设计存在如下问题：</p><ul><li>部署效率低下：当单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试的速度会越来越慢。</li><li>团队协作开发成本高</li><li>系统高可用性差。因为所有的功能开发最后都部署到同一个 WAR 包里，运行在同一个 Tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 WAR 包中部署的功能。</li><li>线上发布变慢。单体应用的代码越膨胀，服务启动的时间就会变长，因此我们需要一种方法能够将应用的不同模块的解耦，降低开发和部署成本。</li></ul><p>因此为了解决这些问题，服务化的思想随之而生。</p><a id="more"></a><h2 id="什么是服务化"><a class="markdownIt-Anchor" href="#什么是服务化"></a> 什么是服务化</h2><p>服务化是指把一个大型系统中的各个业务进行抽象以后，以服务为单位进行开发和管理的方法。 与之相关联就是面向服务架构。 所谓的服务化是指把一个大型系统中的各个业务进行抽象以后，以服务为单位进行开发和管理的方法。</p><p>用通俗的话来讲，服务化就是把传统的单机应用中通过 JAR 包依赖产生的本地方法调用，改造成通过 RPC 接口产生的远程方法调用。在编写业务代码时，对于一些通用的业务逻辑，把它抽象并独立成为专门的模块，因为这对于代码复用和业务理解都大有裨益。</p><h2 id="什么是微服务"><a class="markdownIt-Anchor" href="#什么是微服务"></a> 什么是微服务</h2><p>从 2014 年开始，得益于以 Docker 为代表的容器化技术的成熟以及 DevOps 文化的兴起，服务化的思想进一步演化，演变为今天我们所熟知的微服务。</p><p>那么微服务相比于服务化又有什么不同呢？主要有以下四点：</p><ul><li><strong>服务拆分粒度更细</strong>。微服务可以说是更细维度的服务化，小到一个子模块，只要该模块依赖的资源与其他模块都没有关系，那么就可以拆分为一个微服务。</li><li><strong>服务独立部署</strong>。每个微服务都严格遵循独立打包部署的准则，互不影响。比如一台物理机上可以部署多个 Docker 实例，每个 Docker 实例可以部署一个微服务的代码。</li><li><strong>服务独立维护</strong>。每个微服务都可以交由一个小团队甚至个人来开发、测试、发布和运维，并对整个生命周期负责。</li><li><strong>服务治理能力要求高</strong>。因为拆分为微服务之后，服务的数量变多，因此需要有统一的服务治理平台，来对各个服务进行管理。</li></ul><h2 id="如何进行服务化拆分"><a class="markdownIt-Anchor" href="#如何进行服务化拆分"></a> 如何进行服务化拆分</h2><p>服务化的拆分方式主要有两种：<strong>纵向拆分</strong>和<strong>横向拆分</strong>：</p><ul><li>纵向拆分，是从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。</li><li>横向拆分，是从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</li></ul><h2 id="微服务架构体系"><a class="markdownIt-Anchor" href="#微服务架构体系"></a> 微服务架构体系</h2><p>在介绍微服务架构体系之前我们先思考这种新体系带来了哪些问题：</p><ul><li>服务如何定义：对于单体应用来说，不同功能模块之前相互交互时，通常是以类库的方式来提供各个模块的功能。对于微服务来说，每个服务都运行在各自的进程之中，应该以何种形式向外界传达自己的信息呢？答案就是接口，无论采用哪种通讯协议，是 HTTP 还是 RPC，服务之间的调用都通过接口描述来约定，约定内容包括接口名、接口参数以及接口返回值。</li><li>服务如何发布和订阅：单体应用由于部署在同一个 WAR 包里，接口之间的调用属于进程内的调用。而拆分为微服务独立部署后，服务提供者该如何对外暴露自己的地址，服务调用者该如何查询所需要调用的服务的地址呢？这个时候你就需要一个类似登记处的地方，能够记录每个服务提供者的地址以供服务调用者查询，在微服务架构里，这个地方就是注册中心。</li><li>服务如何监控。通常对于一个服务，我们最关心的是 QPS（调用量）、AvgTime（平均耗时）以及 P999（99.9% 的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。</li><li>服务如何治理。可以想象，拆分为微服务架构后，服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回，这就是熔断，也是服务治理最常用的手段之一。</li><li>故障如何定位。在单体应用拆分为微服务之后，一次用户调用可能依赖多个服务，每个服务又部署在不同的节点上，如果用户调用出现问题，你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位。</li></ul><p>因此微服务架构下，服务调用主要依赖下面几个基本组件：</p><ul><li>服务描述</li><li>注册中心</li><li>服务框架</li><li>服务监控</li><li>服务追踪</li><li>服务治理</li></ul><h3 id="一-服务描述"><a class="markdownIt-Anchor" href="#一-服务描述"></a> 一、服务描述</h3><p>服务调用首先要解决的问题就是服务如何对外描述，比如，你对外提供了一个服务，那么这个服务的服务名叫什么？调用这个服务需要提供哪些信息？调用这个服务返回的结果是什么格式的？该如何解析等等，常用的服务描述方式包括 RESTful API、XML 配置以及 IDL 文件三种。</p><h4 id="1-restful-api"><a class="markdownIt-Anchor" href="#1-restful-api"></a> 1、RESTful API</h4><p>RESTful API 方式通常用作 HTTP 或者 HTTPS 协议的接口定义，并且常用 Wiki 或者Swagger来进行管理。因为 HTTP 协议本身是一个公开的协议，对于服务消费者来说几乎没有学习成本，所以比较适合用作跨业务平台之间的服务协议。比如你有一个服务，不仅需要在业务部门内部提供服务，还需要向其他业务部门提供服务，甚至开放给外网提供服务，这时候采用 HTTP 协议就比较合适，也省去了沟通服务协议的成本。</p><h4 id="2-xml配置"><a class="markdownIt-Anchor" href="#2-xml配置"></a> 2、XML配置</h4><p>XML 配置方式多用作 RPC 协议的服务描述，通过 *.xml 配置文件来定义接口名、参数以及返回值类型等。</p><p>这种配置方式的服务发布和引用主要分三个步骤：</p><ul><li>服务提供者定义接口，并实现接口。</li><li>服务提供者进程启动时，通过加载 server.xml 配置文件将接口暴露出去。</li><li>服务消费者进程启动时，通过加载 client.xml 配置文件来引入要调用的接口，然后发起调用。</li></ul><p>XML 配置方式的核心便是通过在服务提供者和服务消费者之间维持一份对等的 XML 配置文件，来保证服务消费者按照服务提供者的约定来进行服务调用，在这种方式下，如果服务提供者变更了接口定义，不仅需要更新服务提供者加载的接口描述文件 server.xml，还需要同时更新服务消费者加载的接口描述文件 client.xml。</p><h4 id="3-idl文件"><a class="markdownIt-Anchor" href="#3-idl文件"></a> 3、IDL文件</h4><p>IDL 就是接口描述语言（interface description language）的缩写，通过一种中立的方式来描述接口，使得在不同的平台上运行的对象和不同语言编写的程序可以相互通信交流。也就是说 IDL 主要是用作<strong>跨语言平台的服务</strong>之间的调用，有两种最常用的 IDL：一个是 Facebook 开源的 Thrift 协议，另一个是 Google 开源的 gRPC 协议。无论是 Thrift 协议还是 gRPC 协议，它们的工作原理都是类似的。</p><p>以 gRPC 协议为例，gRPC 协议使用 Protobuf 简称 proto 文件来定义接口名、调用参数以及返回值类型：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The greeter service definition.</span></span><br><span class="line">service Greeter &#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user&#x27;s name.</span></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  <span class="keyword">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  <span class="keyword">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如服务提供者使用的是 Java 语言，那么利用 protoc 插件即可自动生成 Server 端的 Java 代码。假如服务消费者使用的是 PHP 语言，那么利用 protoc 插件即可自动生成 Client 端的 PHP 代码。由此可见，<strong>gRPC 协议的服务描述是通过 proto 文件来定义接口的，然后再使用 protoc 来生成不同语言平台的客户端和服务端代码，从而具备跨语言服务调用能力</strong>。有一点特别需要注意的是，在描述接口定义时，IDL 文件需要对接口返回值进行详细定义。如果接口返回值的字段比较多，并且经常变化时，采用 IDL 文件方式的接口定义就不太合适了。一方面可能会造成 IDL 文件过大难以维护，另一方面只要 IDL 文件中定义的接口返回值有变更，都需要同步所有的服务消费者都更新，管理成本就太高了。</p><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><img src="/assets/microservices/02.webp" width="500"><p>总的来说，具体采用哪种服务描述方式是根据实际情况决定的，通常情况下，如果只是企业内部之间的服务调用，并且都是 Java 语言的话，选择 XML 配置方式是最简单的。如果企业内部存在多个服务，并且服务采用的是不同语言平台，建议使用 IDL 文件方式进行描述服务。如果还存在对外开放服务调用的情形的话，使用 RESTful API 方式则更加通用。</p><h3 id="二-注册中心"><a class="markdownIt-Anchor" href="#二-注册中心"></a> 二、注册中心</h3><p>有了服务的接口描述，下一步要解决的问题就是服务的发布和订阅，就是说你提供了一个服务，如何让外部想调用你的服务的人知道。这个时候就需要一个类似注册中心的角色，服务提供者将自己提供的服务以及地址登记到注册中心，服务消费者则从注册中心查询所需要调用的服务的地址，然后发起请求。</p><p>一般来讲，注册中心的工作流程是：</p><ul><li>服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务，并向注册中心定期发送心跳汇报存活状态。</li><li>服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。</li><li>注册中心返回服务提供者地址列表给服务消费者，服务消费者将地址缓存到本地内存中并与服务提供者建立连接。</li><li>当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者，服务消费者感知后会刷新本地内存中缓存的服务节点列表。</li><li>服务消费者根据本地缓存的服务节点列表基于负载均衡算法选择一台服务提供者发起调用。</li></ul><p>具体调用流程如下图所示：</p><img src="/assets/microservices/01.webp" width="700"><p>那么我们如何实现一个注册中心呢？</p><p>注册中心的实现主要涉及几个问题：注册中心需要提供哪些接口，该如何部署；如何存储服务信息；如何监控服务提供者节点的存活；如果服务提供者节点有变化如何通知服务消费者，以及如何控制注册中心的访问权限。</p><h4 id="1-注册中心-api"><a class="markdownIt-Anchor" href="#1-注册中心-api"></a> 1、注册中心 API</h4><p>根据注册中心原理的描述，注册中心必须提供以下最基本的 API，例如：</p><ul><li>服务注册接口：服务提供者通过调用服务注册接口来完成服务注册。</li><li>服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销。</li><li>心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报。</li><li>服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。</li><li>服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。</li></ul><p>除此之外，为了便于管理，注册中心还必须提供一些后台管理的 API，例如：</p><ul><li>服务查询接口：查询注册中心当前注册了哪些服务信息。</li><li>服务修改接口：修改注册中心中某一服务的信息。</li></ul><h4 id="2-集群部署"><a class="markdownIt-Anchor" href="#2-集群部署"></a> 2、集群部署</h4><p>注册中心作为服务提供者和服务消费者之间沟通的桥梁，它的重要性不言而喻。所以注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。</p><p>以开源注册中心 ZooKeeper 为例，ZooKeeper 集群中包含多个节点，服务提供者和服务消费者可以同任意一个节点通信，因为它们的数据一定是相同的，这是为什么呢？这就要从 ZooKeeper 的工作原理说起：</p><ul><li>每个 Server 在内存中存储了一份数据，Client 的读请求可以请求任意一个 Server。</li><li>ZooKeeper 启动时，将从实例中选举一个 leader（Paxos 协议）。</li><li>Leader 负责处理数据更新等操作（ZAB 协议）。</li><li>一个更新操作成功，当且仅当大多数 Server 在内存中成功修改 。</li></ul><img src="/assets/microservices/03.webp" width="700"><h4 id="3-目录存储"><a class="markdownIt-Anchor" href="#3-目录存储"></a> 3、目录存储</h4><p>以 ZooKeeper 为例，注册中心存储服务信息一般采用层次化的目录结构：</p><ul><li>每个目录在 ZooKeeper 中叫作 znode，并且其有一个唯一的路径标识。</li><li>znode 可以包含数据和子 znode。</li><li>znode 中的数据可以有多个版本，比如某一个 znode 下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。</li></ul><img src="/assets/microservices/04.webp" width="700"><h4 id="4-服务健康状态检测"><a class="markdownIt-Anchor" href="#4-服务健康状态检测"></a> 4、服务健康状态检测</h4><p>注册中心除了要支持最基本的服务注册和服务订阅功能以外，还必须具备对服务提供者节点的健康状态检测功能，这样才能保证注册中心里保存的服务节点都是可用的。</p><p>以 ZooKeeper 为例，它是基于 ZooKeeper 客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态检测的。</p><p>在 ZooKeeper 中，客户端和服务端建立连接后，会话也随之建立，并生成一个全局唯一的 Session ID。服务端和客户端维持的是一个长连接，在 SESSION_TIMEOUT 周期内，服务端会检测与客户端的链路是否正常，具体方式是通过客户端定时向服务端发送心跳消息（ping 消息），服务器重置下次 SESSION_TIMEOUT 时间。如果超过 SESSION_TIMEOUT 后服务端都没有收到客户端的心跳消息，则服务端认为这个 Session 就已经结束了，ZooKeeper 就会认为这个服务节点已经不可用，将会从注册中心中删除其信息。</p><h4 id="5-服务状态变更通知"><a class="markdownIt-Anchor" href="#5-服务状态变更通知"></a> 5、服务状态变更通知</h4><p>一旦注册中心探测到有服务提供者节点新加入或者被剔除，就必须立刻通知所有订阅该服务的服务消费者，刷新本地缓存的服务节点信息，确保服务调用不会请求不可用的服务提供者节点。继续以 ZooKeeper 为例，基于 ZooKeeper 的 Watcher 机制，来实现服务状态变更通知给服务消费者的。服务消费者在调用 ZooKeeper 的 getData 方法订阅服务时，还可以通过监听器 Watcher 的 process 方法获取服务的变更，然后调用 getData 方法来获取变更后的数据，刷新本地缓存的服务节点信息。</p><h4 id="6-白名单机制"><a class="markdownIt-Anchor" href="#6-白名单机制"></a> 6、白名单机制</h4><p>在实际的微服务测试和部署时，通常包含多套环境，比如生产环境一套、测试环境一套。开发在进行业务自测、测试在进行回归测试时，一般都是用测试环境，部署的 RPC Server 节点注册到测试的注册中心集群。但经常会出现开发或者测试在部署时，错误的把测试环境下的服务节点注册到了线上注册中心集群，这样的话线上流量就会调用到测试环境下的 RPC Server 节点，可能会造成意想不到的后果。</p><p>为了防止这种情况发生，注册中心需要提供一个保护机制，你可以把注册中心想象成一个带有门禁的房间，只有拥有门禁卡的 RPC Server 才能进入。在实际应用中，注册中心可以提供一个白名单机制，只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。</p><h4 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h4><p>总结注册中心可以说是实现服务化的关键，因为服务化之后，服务提供者和服务消费者不在同一个进程中运行，实现了解耦，这就需要一个纽带去连接服务提供者和服务消费者，而注册中心就正好承担了这一角色。</p><p>此外，服务提供者可以任意伸缩即增加节点或者减少节点，通过服务健康状态检测，注册中心可以保持最新的服务节点信息，并将变化通知给订阅服务的服务消费者。注册中心一般采用分布式集群部署，来保证高可用性，并且为了实现异地多活，有的注册中心还采用多 IDC 部署，这就对数据一致性产生了很高的要求，这些都是注册中心在实现时必须要解决的问题。</p><h3 id="三-服务框架"><a class="markdownIt-Anchor" href="#三-服务框架"></a> 三、服务框架</h3><p>通过注册中心，服务消费者就可以获取到服务提供者的地址，有了地址后就可以发起调用。但在发起调用之前你还需要解决以下几个问题。</p><ul><li>服务通信采用什么协议？就是说服务提供者和服务消费者之间以什么样的协议进行网络通信，是采用四层 TCP、UDP 协议，还是采用七层 HTTP 协议，还是采用其他协议？</li><li>数据传输采用什么方式？就是说服务提供者和服务消费者之间的数据传输采用哪种方式，是同步还是异步，是在单连接上传输，还是多路复用。</li><li>数据压缩采用什么格式？通常数据传输都会对数据进行压缩，来减少网络传输的数据量，从而减少带宽消耗和网络传输时间，比如常见的 JSON 序列化、Java 对象序列化以及 Protobuf 序列化等。</li></ul><p>为了解决上述三个问题我们需要引入下面内容：</p><h4 id="1-通信框架"><a class="markdownIt-Anchor" href="#1-通信框架"></a> 1、通信框架</h4><p>通信框架主要解决两个问题：客户端和服务端如何建立连接、管理连接以及服务端如何处理请求。</p><p><strong>客户端和服务端如何建立网络连接？</strong></p><p>1）HTTP通信</p><p>HTTP 通信是基于应用层 HTTP 协议的，而 HTTP 协议又是基于传输层 TCP 协议的。一次 HTTP 通信过程就是发起一次 HTTP 调用，而一次 HTTP 调用就会建立一个 TCP 连接，经历一次下图所示的“三次握手”的过程来建立连接。</p><img src="/assets/microservices/05.webp" width="600" /><p>完成请求后，再经历一次“四次挥手”的过程来断开连接。</p><img src="/assets/microservices/06.webp" width="600" /><p>2）Socket 通信</p><p>Socket 通信是基于 TCP/IP 协议的封装，建立一次 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ；另一个运行于服务器端，称为 ServerSocket 。就像下图所描述的，Socket 通信的过程分为四个步骤：服务器监听、客户端请求、连接确认、数据传输。</p><ul><li>服务器监听：ServerSocket 通过调用 bind() 函数绑定某个具体端口，然后调用 listen() 函数实时监控网络状态，等待客户端的连接请求。</li><li>客户端请求：ClientSocket 调用 connect() 函数向 ServerSocket 绑定的地址和端口发起连接请求。</li><li>服务端连接确认：当 ServerSocket 监听到或者接收到 ClientSocket 的连接请求时，调用 accept() 函数响应 ClientSocket 的请求，同客户端建立连接。</li><li>数据传输：当 ClientSocket 和 ServerSocket 建立连接后，ClientSocket 调用 send() 函数，ServerSocket 调用 receive() 函数，ServerSocket 处理完请求后，调用 send() 函数，ClientSocket 调用 receive() 函数，就可以得到得到返回结果。</li></ul><img src="/assets/microservices/07.webp" width="600" /><p>当客户端和服务端建立网络连接后，就可以发起请求了。但网络不一定总是可靠的，经常会遇到网络闪断、连接超时、服务端宕机等各种异常，通常的处理手段有两种。</p><ul><li>链路存活检测：客户端需要定时地发送心跳检测消息（一般是通过 ping 请求）给服务端，如果服务端连续 n 次心跳检测或者超过规定的时间都没有回复消息，则认为此时链路已经失效，这个时候客户端就需要重新与服务端建立连接。</li><li>断连重试：通常有多种情况会导致连接断开，比如客户端主动关闭、服务端宕机或者网络故障等。这个时候客户端就需要与服务端重新建立连接，但一般不能立刻完成重连，而是要等待固定的间隔后再发起重连，避免服务端的连接回收不及时，而客户端瞬间重连的请求太多而把服务端的连接数占满。</li></ul><p><strong>服务端如何处理请求</strong></p><p>假设这时候客户端和服务端已经建立了网络连接，服务端又该如何处理客户端的请求呢？通常来讲，有三种处理方式。</p><ul><li>同步阻塞方式（BIO），客户端每发一次请求，服务端就生成一个线程去处理。当客户端同时发起的请求很多时，服务端需要创建很多的线程去处理每一个请求，如果达到了系统最大的线程数瓶颈，新来的请求就没法处理了。</li><li>同步非阻塞方式 (NIO)，客户端每发一次请求，服务端并不是每次都创建一个新线程来处理，而是通过 I/O 多路复用技术进行处理。就是把多个 I/O 的阻塞复用到同一个 select 的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。这种方式的优势是开销小，不用为每个请求创建一个线程，可以节省系统开销。</li><li>异步非阻塞方式（AIO），客户端只需要发起一个 I/O 操作然后立即返回，等 I/O 操作真正完成以后，客户端会得到 I/O 操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的 I/O 读写操作，因为真正的 I/O 读取或者写入操作已经由内核完成了。这种方式的优势是客户端无需等待，不存在阻塞等待问题。</li></ul><p>从前面的描述，可以看出来不同的处理方式适用于不同的业务场景：</p><ul><li>BIO 适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。</li><li>NIO 适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比 BIO，相对来说编程比较复杂。</li><li>AIO 适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及 I/O 操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。</li></ul><h4 id="2-数据传输采用什么样的协议"><a class="markdownIt-Anchor" href="#2-数据传输采用什么样的协议"></a> 2、数据传输采用什么样的协议</h4><p>最常用的有 HTTP 协议，它是一种开放的协议，各大网站的服务器和浏览器之间的数据传输大都采用了这种协议。还有一些定制的私有协议，比如阿里巴巴开源的 Dubbo 协议，也可以用于服务端和客户端之间的数据传输。</p><p>无论是开放的还是私有的协议，都必须定义一个“契约”，以便服务消费者和服务提供者之间能够达成共识。服务消费者按照契约，对传输的数据进行编码，然后通过网络传输过去；服务提供者从网络上接收到数据后，按照契约，对传输的数据进行解码，然后处理请求，再把处理后的结果进行编码，通过网络传输返回给服务消费者；服务消费者再对返回的结果进行解码，最终得到服务提供者处理后的返回值。</p><p>通常协议契约包括两个部分：消息头和消息体。其中消息头存放的是协议的公共字段以及用户扩展字段，消息体存放的是传输数据的具体内容。</p><h4 id="3-数据该如何序列化和反序列化"><a class="markdownIt-Anchor" href="#3-数据该如何序列化和反序列化"></a> 3、数据该如何序列化和反序列化？</h4><p>一般数据在网络中进行传输前，都要先在发送方一端对数据进行编码，经过网络传输到达另一端后，再对数据进行解码，这个过程就是序列化和反序列化。</p><p>为什么要对数据进行序列化和反序列化呢？要知道网络传输的耗时一方面取决于网络带宽的大小，另一方面取决于数据传输量。要想加快网络传输，要么提高带宽，要么减小数据传输量，而对数据进行编码的主要目的就是减小数据传输量。比如一部高清电影原始大小为 30GB，如果经过特殊编码格式处理，可以减小到 3GB，同样是 100MB/s 的网速，下载时间可以从 300s 减小到 30s。</p><p>常用的序列化方式分为两类：文本类如 XML/JSON 等，二进制类如 PB/Thrift 等，而具体采用哪种序列化方式，主要取决于三个方面的因素。</p><ul><li>支持数据结构类型的丰富度。数据结构种类支持的越多越好，这样的话对于使用者来说在编程时更加友好，有些序列化框架如 Hessian 2.0 还支持复杂的数据结构比如 Map、List 等。</li><li>跨语言支持。序列化方式是否支持跨语言也是一个很重要的因素，否则使用的场景就比较局限，比如 Java 序列化只支持 Java 语言，就不能用于跨语言的服务调用了。</li><li>性能。主要看两点，一个是序列化后的压缩比，一个是序列化的速度。以常用的 PB 序列化和 JSON 序列化协议为例来对比分析，PB 序列化的压缩比和速度都要比 JSON 序列化高很多，所以对性能和存储空间要求比较高的系统选用 PB 序列化更合适；而 JSON 序列化虽然性能要差一些，但可读性更好，更适合对外部提供服务。</li></ul><h3 id="四-服务监控"><a class="markdownIt-Anchor" href="#四-服务监控"></a> 四、服务监控</h3><p>一旦服务消费者与服务提供者之间能够正常发起服务调用，你就需要对调用情况进行监控，以了解服务是否正常。通常来讲，服务监控主要包括三个流程：</p><ul><li>指标收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。</li><li>数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。</li><li>数据展示。数据收集起来，经过处理之后，还需要以友好的方式对外展示，才能发挥价值。通常都是将数据展示在 Dashboard 面板上，并且每隔 10s 等间隔自动刷新，用作业务监控和报警等。</li></ul><p>在展开讲述如何监控微服务调用前，首先我们要搞清楚三个问题：监控的对象是什么？具体监控哪些指标？从哪些维度进行监控？下面就从这三个问题开始，一起来看看如何监控微服务调用。</p><h4 id="1-监控对象"><a class="markdownIt-Anchor" href="#1-监控对象"></a> 1、监控对象</h4><p>既然要监控，那么要监控哪些对象呢？对于微服务系统来说，监控对象可以分为四个层次，由上到下可归纳为：</p><ul><li>用户端监控。通常是指业务直接对用户提供的功能的监控。以微博首页 Feed 为例，它向用户提供了聚合关注的所有人的微博并按照时间顺序浏览的功能，对首页 Feed 功能的监控就属于用户端的监控。</li><li>接口监控。通常是指业务提供的功能所依赖的具体 RPC 接口的监控。继续以微博首页 Feed 为例，这个功能依赖于用户关注了哪些人的关系服务，每个人发过哪些微博的微博列表服务，以及每条微博具体内容是什么的内容服务，对这几个服务的调用情况的监控就属于接口监控。</li><li>资源监控。通常是指某个接口依赖的资源的监控。比如用户关注了哪些人的关系服务使用的是 Redis 来存储关注列表，对 Redis 的监控就属于资源监控。</li><li>基础监控。通常是指对服务器本身的健康状况的监控。主要包括 CPU 利用率、内存使用量、I/O 读写量、网卡带宽等。对服务器的基本监控也是必不可少的，因为服务器本身的健康状况也是影响服务本身的一个重要因素，比如服务器本身连接的网络交换机上联带宽被打满，会影响所有部署在这台服务器上的业务。</li></ul><h4 id="2-监控指标"><a class="markdownIt-Anchor" href="#2-监控指标"></a> 2、监控指标</h4><p>搞清楚要监控的对象之后，需要监控具体哪些指标呢？通常有以下几个业务指标需要重点监控：</p><ul><li>请求量。请求量监控分为两个维度，一个是实时请求量，一个是统计请求量。实时请求量用 QPS（Queries Per Second）即每秒查询次数来衡量，它反映了服务调用的实时变化情况。统计请求量一般用 PV（Page View）即一段时间内用户的访问量来衡量，比如一天的 PV 代表了服务一天的请求量，通常用来统计报表。</li><li>响应时间。大多数情况下，可以用一段时间内所有调用的平均耗时来反映请求的响应时间。但它只代表了请求的平均快慢情况，有时候我们更关心慢请求的数量。为此需要把响应时间划分为多个区间，比如 0～10ms、10ms～50ms、50ms～100ms、100ms～500ms、500ms 以上这五个区间，其中 500ms 以上这个区间内的请求数就代表了慢请求量，正常情况下，这个区间内的请求数应该接近于 0；在出现问题时，这个区间内的请求数会大幅增加，可能平均耗时并不能反映出这一变化。除此之外，还可以从 P90、P95、P99、P999 角度来监控请求的响应时间，比如 P99 = 500ms，意思是 99% 的请求响应时间在 500ms 以内，它代表了请求的服务质量，即 SLA。</li><li>错误率。错误率的监控通常用一段时间内调用失败的次数占调用总次数的比率来衡量，比如对于接口的错误率一般用接口返回错误码为 503 的比率来表示。</li></ul><h4 id="3-监控维度"><a class="markdownIt-Anchor" href="#3-监控维度"></a> 3、监控维度</h4><p>一般来说，要从多个维度来对业务进行监控，具体来讲可以包括下面几个维度：</p><ul><li>全局维度。从整体角度监控对象的的请求量、平均耗时以及错误率，全局维度的监控一般是为了让你对监控对象的调用情况有个整体了解。</li><li>分机房维度。一般为了业务的高可用性，服务通常部署在不止一个机房，因为不同机房地域的不同，同一个监控对象的各种指标可能会相差很大，所以需要深入到机房内部去了解。</li><li>单机维度。即便是在同一个机房内部，可能由于采购年份和批次的不同，位于不同机器上的同一个监控对象的各种指标也会有很大差异。一般来说，新采购的机器通常由于成本更低，配置也更高，在同等请求量的情况下，可能表现出较大的性能差异，因此也需要从单机维度去监控同一个对象。</li><li>时间维度。同一个监控对象，在每天的同一时刻各种指标通常也不会一样，这种差异要么是由业务变更导致，要么是运营活动导致。为了了解监控对象各种指标的变化，通常需要与一天前、一周前、一个月前，甚至三个月前做比较。</li><li>核心维度。根据我的经验，业务上一般会依据重要性程度对监控对象进行分级，最简单的是分成核心业务和非核心业务。核心业务和非核心业务在部署上必须隔离，分开监控，这样才能对核心业务做重点保障。</li></ul><p>讲到这里先小结一下，对于一个微服务来说，你必须明确要监控哪些对象、哪些指标，并且还要从不同的维度进行监控，才能掌握微服务的调用情况。明确了这几个关键的问题后，那么该如何搭建一个监控系统，来完成上面这些监控功能呢？</p><h4 id="4-监控系统原理"><a class="markdownIt-Anchor" href="#4-监控系统原理"></a> 4、监控系统原理</h4><p>显然，我们要对服务调用进行监控，首先要能收集到每一次调用的详细信息，包括调用的响应时间、调用是否成功、调用的发起者和接收者分别是谁，这个过程叫作数据采集。采集到数据之后，要把数据通过一定的方式传输给数据处理中心进行处理，这个过程叫作数据传输。数据传输过来后，数据处理中心再按照服务的维度进行聚合，计算出不同服务的请求量、响应时间以及错误率等信息并存储起来，这个过程叫作数据处理。最后再通过接口或者 Dashboard 的形式对外展示服务的调用情况，这个过程叫作数据展示。</p><p>可见，监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示，下面我来给你讲解下每一个环节的实现原理。</p><p><strong>数据采集</strong></p><p>通常有两种数据收集方式：</p><ul><li>服务主动上报，这种处理方式通过在业务代码或者服务框架里加入数据收集代码逻辑，在每一次服务调用完成后，主动上报服务的调用信息。</li><li>代理收集，这种处理方式通过服务调用后把调用的详细信息记录到本地日志文件中，然后再通过代理去解析本地日志文件，然后再上报服务的调用信息。</li></ul><p>无论哪种数据采集方式，首先要考虑的问题就是采样率，也就是采集数据的频率。采样率决定了监控的实时性与精确度，一般来说，采样率越高，监控的实时性就越高，精确度也越高。但采样对系统本身的性能也会有一定的影响，尤其是采集后的数据需要写到本地磁盘的时候，过高的采样率会导致系统写入磁盘的 I/O 过高，进而会影响到正常的服务调用。所以设置合理的采用率是数据采集的关键，最好是可以动态控制采样率，在系统比较空闲的时候加大采样率，追求监控的实时性与精确度；在系统负载比较高的时候减小采样率，追求监控的可用性与系统的稳定性。</p><p><strong>数据传输</strong></p><p>数据传输最常用的方式有两种：</p><ul><li>UDP 传输，这种处理方式是数据处理单元提供服务器的请求地址，数据采集后通过 UDP 协议与服务器建立连接，然后把数据发送过去。</li><li>Kafka 传输，这种处理方式是数据采集后发送到指定的 Topic，然后数据处理单元再订阅对应的 Topic，就可以从 Kafka 消息队列中读取到对应的数据。</li></ul><p>无论采用哪种传输方式，数据格式都十分重要，尤其是对带宽敏感以及解析性能要求比较高的场景，一般数据传输时采用的数据格式有两种：</p><ul><li>二进制协议，最常用的就是 PB 对象，它的优点是高压缩比和高性能，可以减少传输带宽并且序列化和反序列化效率特别高。</li><li>文本协议，最常用的就是 JSON 字符串，它的优点是可读性好，但相比于 PB 对象，传输占用带宽高，并且解析性能也要差一些。</li></ul><p><strong>数据处理</strong></p><p>数据处理是对收集来的原始数据进行聚合并存储。数据聚合通常有两个维度：</p><ul><li>接口维度聚合，这个维度是把实时收到的数据按照接口名维度实时聚合在一起，这样就可以得到每个接口的实时请求量、平均耗时等信息。</li><li>机器维度聚合，这个维度是把实时收到的数据按照调用的节点维度聚合在一起，这样就可以从单机维度去查看每个接口的实时请求量、平均耗时等信息。</li></ul><p>聚合后的数据需要持久化到数据库中存储，所选用的数据库一般分为两种：</p><ul><li>索引数据库，比如 Elasticsearch，以倒排索引的数据结构存储，需要查询的时候，根据索引来查询。</li><li>时序数据库，比如 OpenTSDB，以时序序列数据的方式存储，查询的时候按照时序如 1min、5min 等维度来查询。</li></ul><p><strong>数据展示</strong></p><p>数据展示是把处理后的数据以 Dashboard 的方式展示给用户。数据展示有多种方式，比如曲线图、饼状图、格子图展示等。</p><h3 id="五-服务追踪"><a class="markdownIt-Anchor" href="#五-服务追踪"></a> 五、服务追踪</h3><p>除了需要对服务调用情况进行监控之外，你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。</p><p>服务追踪的工作原理大致如下：</p><ul><li>服务消费者发起调用前，会在本地按照一定的规则生成一个 requestid，发起调用时，将 requestid 当作请求参数的一部分，传递给服务提供者。</li><li>服务提供者接收到请求后，记录下这次请求的 requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的 requestid，然后把这两个 requestid 都当作请求参数继续往下传递。</li></ul><p>以此类推，通过这种层层往下传递的方式，一次请求，无论最后依赖多少次服务调用、经过多少服务节点，都可以通过最开始生成的 requestid 串联所有节点，从而达到服务追踪的目的。</p><h4 id="1-服务追踪的作用"><a class="markdownIt-Anchor" href="#1-服务追踪的作用"></a> 1、服务追踪的作用</h4><p>在介绍追踪原理与实现之前，我们先来看看服务追踪的作用。</p><p><strong>快速定位请求失败的原因</strong></p><p>通过服务追踪系统我们可以跟踪记录一次用户请求都发起了哪些调用，经过哪些服务处理，并且记录每一次调用所涉及的服务的详细信息，这时候如果发生调用失败，你就可以通过这个日志快速定位是在哪个环节出了问题</p><p><strong>优化系统瓶颈</strong></p><p>通过记录调用经过的每一条链路上的耗时，我们能快速定位整个系统的瓶颈点在哪里。比如你访问微博首页发现很慢，肯定是由于某种原因造成的，有可能是运营商网络延迟，有可能是网关系统异常，有可能是某个服务异常，还有可能是缓存或者数据库异常。通过服务追踪，可以从全局视角上去观察，找出整个系统的瓶颈点所在，然后做出针对性的优化。</p><p><strong>优化链路调用</strong></p><p>通过服务追踪可以分析调用所经过的路径，然后评估是否合理。比如一个服务调用下游依赖了多个服务，通过调用链分析，可以评估是否每个依赖都是必要的，是否可以通过业务优化来减少服务依赖。还有就是，一般业务都会在多个数据中心都部署服务，以实现异地容灾，这个时候经常会出现一种状况就是服务 A 调用了另外一个数据中心的服务 B，而没有调用同处于一个数据中心的服务 B。通过对调用链路进行分析，可以找出跨数据中心的服务调用，从而进行优化，尽量规避这种情况出现。</p><p><strong>生成网络拓扑</strong></p><p>通过服务追踪系统中记录的链路信息，可以生成一张系统的网络调用拓扑图，它可以反映系统都依赖了哪些服务，以及服务之间的调用关系是什么样的，可以一目了然。除此之外，在网络拓扑图上还可以把服务调用的详细信息也标出来，也能起到服务监控的作用。</p><p><strong>透明传输数据</strong></p><p>除了服务追踪，业务上经常有一种需求，期望能把一些用户数据，从调用的开始一直往下传递，以便系统中的各个服务都能获取到这个信息。比如业务想做一些 A/B 测试，这时候就想通过服务追踪系统，把 A/B 测试的开关逻辑一直往下传递，经过的每一层服务都能获取到这个开关值，就能够统一进行 A/B 测试。</p><h4 id="2-服务追踪系统原理"><a class="markdownIt-Anchor" href="#2-服务追踪系统原理"></a> 2、服务追踪系统原理</h4><p>服务追踪系统的实现原理。它的核心理念就是调用链：通过一个全局唯一的 ID 将分布在各个服务节点上的同一次请求串联起来，从而还原原有的调用关系，可以追踪系统问题、分析调用数据并统计各种系统指标。</p><p>要理解服务追踪的原理，首先必须搞懂一些基本概念：traceId、spanId、annonation 等。以美团的 MTrace 为例：</p><img src="/assets/microservices/08.webp" /><ul><li>traceId，用于标识某一次具体的请求 ID。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 traceId，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 traceId 就可以把一次用户请求在系统中调用的路径串联起来。</li><li>spanId，用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 spanId 初始值是 0，进入下一层 RPC 调用 B 的时候 spanId 是 0.1，继续进入下一层 RPC 调用 C 时 spanId 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 spanId 是 0.2，这样的话通过 spanId 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。</li><li>annotation，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。</li></ul><h4 id="3-服务追踪系统实现"><a class="markdownIt-Anchor" href="#3-服务追踪系统实现"></a> 3、服务追踪系统实现</h4><img src="/assets/microservices/09.webp" /><p>上面是服务追踪系统架构图，你可以看到一个服务追踪系统可以分为三层。</p><ul><li>数据采集层，负责数据埋点并上报。</li><li>数据处理层，负责数据的存储与计算。</li><li>数据展示层，负责数据的图形化展示。</li></ul><p>下面我们看看每一层具体的实现方式是怎样的？</p><p><strong>数据采集层</strong></p><p>数据采集层的作用就是在系统的各个不同模块中进行埋点，采集数据并上报给数据处理层进行处理。那么该如何进行数据埋点呢？结合下面这张图来了解一下数据埋点的流程。</p><img src="/assets/microservices/10.webp" /><p>以红色方框里圈出的 A 调用 B 的过程为例，一次 RPC 请求可以分为四个阶段。</p><ul><li>CS（Client Send）阶段 : 客户端发起请求，并生成调用的上下文。</li><li>SR（Server Recieve）阶段 : 服务端接收请求，并生成上下文。</li><li>SS（Server Send）阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：traceId=123456，spanId=0.1，appKey=B，method=B.method，start=103，duration=38。</li><li>CR（Client Recieve）阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：traceid=123456，spanId=0.1，appKey=A，method=B.method，start=103，duration=38。</li></ul><img src="/assets/microservices/11.webp"><p><strong>数据处理层</strong></p><p>数据处理层的作用就是把数据采集层上报的数据按需计算，然后落地存储供查询使用。数据处理的需求一般分为两类，一类是实时计算需求，一类是离线计算需求。</p><p>实时计算需求对计算效率要求比较高，一般要求对收集的链路数据能够在秒级别完成聚合计算，以供实时查询。而离线计算需求对计算效率要求就没那么高了，一般能在小时级别完成链路数据的聚合计算即可，一般用作数据汇总统计。针对这两类不同的数据处理需求，采用的计算方法和存储也不相同。</p><p>实时数据处理：针对实时数据处理，一般采用 Storm 或者 Spark Streaming 来对链路数据进行实时聚合加工，存储一般使用 OLTP 数据仓库，比如 HBase，使用 traceId 作为 RowKey，能天然地把一整条调用链聚合在一起，提高查询效率。</p><p>离线数据处理：针对离线数据处理，一般通过运行 MapReduce 或者 Spark 批处理程序来对链路数据进行离线计算，存储一般使用 Hive。</p><p><strong>数据展示层</strong></p><p>数据展示层的作用就是将处理后的链路信息以图形化的方式展示给用户。实际项目中主要用到两种图形展示，一种是调用链路图，一种是调用拓扑图。</p><p>调用链路图：</p><img src="/assets/microservices/12.webp"><p>以上面Zipkin 的调用链路图为例，可以看出下面几个信息：</p><ul><li>服务整体情况：服务总耗时、服务调用的网络深度、每一层经过的系统，以及多少次调用。下图展示的一次调用，总共耗时 209.323ms，经过了 5 个不同的系统模块，调用深度为 7 层，共发生了 24 次系统调用。</li><li>每一层的情况：每一层发生了几次调用，以及每一层调用的耗时。</li></ul><p>调用拓扑图：</p><img src="/assets/microservices/13.webp"><p>如图是一张 Pinpoint 的调用拓扑图，通过这张图可以看出系统内都包含哪些应用，它们之间是什么关系，以及依赖调用的 QPS、平均耗时情况。</p><p>调用拓扑图是一种全局视野图，在实际项目中，主要用作全局监控，用于发现系统中异常的点，从而快速做出决策。比如，某一个服务突然出现异常，那么在调用链路拓扑图中可以看出对这个服务的调用耗时都变高了，可以用红色的图样标出来，用作监控报警。</p><h3 id="六-服务治理"><a class="markdownIt-Anchor" href="#六-服务治理"></a> 六、服务治理</h3><p>服务监控能够发现问题，服务追踪能够定位问题所在，而解决问题就得靠服务治理了。服务治理就是通过一系列的手段来保证在各种意外情况下，服务调用仍然能够正常进行。</p><p>在生产环境中，你应该经常会遇到下面几种状况：</p><ul><li>单机故障。通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然而集群的规模越大，越是容易遇到单机故障，在机器规模超过一百台以上时，靠传统的人肉运维显然难以应对。而服务治理可以通过一定的策略，自动摘除故障节点，不需要人为干预，就能保证单机故障不会影响业务。</li><li>单 IDC 故障。你应该经常听说某某 App，因为施工挖断光缆导致大批量用户无法使用的严重故障。而服务治理可以通过自动切换故障 IDC 的流量到其他正常 IDC，可以避免因为单 IDC 故障引起的大批量业务受影响。</li><li>依赖服务不可用。比如你的服务依赖依赖了另一个服务，当另一个服务出现问题时，会拖慢甚至拖垮你的服务。而服务治理可以通过熔断，在依赖服务异常的情况下，一段时期内停止发起调用而直接返回。这样一方面保证了服务消费者能够不被拖垮，另一方面也给服务提供者减少压力，使其能够尽快恢复。</li></ul><p>上面是三种最常见的需要引入服务治理的场景，当然还有一些其他服务治理的手段比如自动扩缩容，可以用来解决服务的容量问题。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>极客时间《从零开始学微服务专栏》</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;早些年，各大互联网公司的应用技术栈大致可分为 LAMP（Linux + Apache + MySQL + PHP）和 MVC（Spring + iBatis/Hibernate + Tomcat）两大流派。无论是 LAMP 还是 MVC，都是为单体应用架构设计的，其优点是学习成本低，开发上手快，测试、部署、运维也比较方便，甚至一个人就可以完成一个网站的开发与部署。&lt;/p&gt;
&lt;p&gt;以 MVC 架构为例，业务通常是通过部署一个 WAR 包到 Tomcat 中，然后启动 Tomcat，监听某个端口即可对外提供服务。早期在业务规模不大、开发团队人员规模较小的时候，采用单体应用架构，团队的开发和运维成本都可控。但是单体应用架构的设计存在如下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署效率低下：当单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试的速度会越来越慢。&lt;/li&gt;
&lt;li&gt;团队协作开发成本高&lt;/li&gt;
&lt;li&gt;系统高可用性差。因为所有的功能开发最后都部署到同一个 WAR 包里，运行在同一个 Tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 WAR 包中部署的功能。&lt;/li&gt;
&lt;li&gt;线上发布变慢。单体应用的代码越膨胀，服务启动的时间就会变长，因此我们需要一种方法能够将应用的不同模块的解耦，降低开发和部署成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此为了解决这些问题，服务化的思想随之而生。&lt;/p&gt;</summary>
    
    
    
    <category term="应用架构" scheme="http://kyleezhang.com/categories/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://kyleezhang.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>浏览器应用基础思维导图</title>
    <link href="http://kyleezhang.com/2021/08/13/client-xmind/"/>
    <id>http://kyleezhang.com/2021/08/13/client-xmind/</id>
    <published>2021-08-13T21:45:51.000Z</published>
    <updated>2022-06-12T11:24:41.821Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://gitmind.cn/app/doc/a6d2369264">GitMind链接</a></p><a id="more"></a><img src="/assets/xmind/client.png">]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://gitmind.cn/app/doc/a6d2369264&quot;&gt;GitMind链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="浏览器工作原理" scheme="http://kyleezhang.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Chrome" scheme="http://kyleezhang.com/tags/Chrome/"/>
    
    <category term="思维导图" scheme="http://kyleezhang.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript思维导图</title>
    <link href="http://kyleezhang.com/2021/08/12/javascript-xmind/"/>
    <id>http://kyleezhang.com/2021/08/12/javascript-xmind/</id>
    <published>2021-08-12T21:45:51.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://gitmind.cn/app/doc/03b2369347">GitMind链接</a></p><a id="more"></a><img src="/assets/xmind/javascript.png">]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://gitmind.cn/app/doc/03b2369347&quot;&gt;GitMind链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解 JavaScript" scheme="http://kyleezhang.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/"/>
    
    
    <category term="思维导图" scheme="http://kyleezhang.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="JavaScript" scheme="http://kyleezhang.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack Dependency Graph深度解析</title>
    <link href="http://kyleezhang.com/2021/08/12/webpack-dependency/"/>
    <id>http://kyleezhang.com/2021/08/12/webpack-dependency/</id>
    <published>2021-08-12T11:31:12.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>非原创：原文地址<a href="https://mp.weixin.qq.com/s/kr73Epnn6wAx9DH7KRVUaA">有点难的 webpack 知识点：Dependency Graph 深度解析</a></p></blockquote><p>Dependency Graph 概念来自官网 Dependency Graph | webpack 一文，原文解释是这样的：</p><blockquote><p>Any time one file depends on another, webpack treats this as a dependency. This allows webpack to take non-code assets, such as images or web fonts, and also provide them as dependencies for your application.<br />When webpack processes your application, it starts from a list of modules defined on the command line or in its configuration file. Starting from these entry points, webpack recursively builds a dependency graph that includes every module your application needs, then bundles all of those modules into a small number of bundles - often, just one - to be loaded by the browser.</p></blockquote><p>翻译过来核心意思是：webpack 处理应用代码时，会从开发者提供的 entry 开始递归地组建起包含所有模块的 dependency graph，之后再将这些 module 打包为 bundles 。</p><p>然而事实远不止官网描述的这么简单，Dependency Graph 贯穿 webpack 整个运行周期，从 make 阶段的模块解析，到 seal 阶段的 chunk 生成，以及 tree-shaking 功能都高度依赖于Dependency Graph ，是 webpack 资源构建的一个非常核心的数据结构</p><p>本文将围绕 webpack@v5.x 的 Dependency Graph 实现，展开讨论三个方面的内容：</p><ul><li>Dependency Graph 在 webpack 实现中以何种数据结构呈现</li><li>Webpack 运行过程中如何收集模块间依赖关系，进而构建出 Dependency Graph</li><li>Dependency Graph 构建完毕后，又是如何被消费的</li></ul><a id="more"></a><h2 id="一-dependency-graph"><a class="markdownIt-Anchor" href="#一-dependency-graph"></a> 一、Dependency Graph</h2><p>本节将深入 webpack 源码，解读 Dependency Graph 的内在数据结构及依赖关系收集过程。在正式展开之前，有必要回顾几个 webpack 重要的概念：</p><ul><li>Module：资源在 webpack 内部的映射对象，包含了资源的路径、上下文、依赖、内容等信息</li><li>Dependency ：在模块中引用其它模块，例如 <code>import &quot;a.js&quot;</code> 语句，webpack 会先将引用关系表述为 Dependency 子类并关联 module 对象，等到当前 module 内容都解析完毕之后，启动下次循环开始将 Dependency 对象转换为适当的 Module 子类。</li><li>Chunk ：用于组织输出结构的对象，webpack 分析完所有模块资源的内容，构建出完整的 Dependency Graph 之后，会根据用户配置及 Dependency Graph 内容构建出一个或多个 chunk 实例，每个 chunk 与最终输出的文件大致上是一一对应的。</li></ul><h3 id="1-数据结构"><a class="markdownIt-Anchor" href="#1-数据结构"></a> 1、数据结构</h3><p>Webpack 4.x 的 Dependency Graph 实现较简单，主要由 Dependence/Module 内置的系列属性记录引用、被引用关系。</p><p>而 Webpack 5.0 之后则实现了一套相对复杂的类结构记录模块间依赖关系，将模块依赖相关的逻辑从 Dependence/Module 解耦为一套独立的类型结构，主要类型有：</p><ul><li>ModuleGraph ：记录 Dependency Graph 信息的容器，一方面保存了构建过程中涉及到的所有 module 、dependency 对象，以及这些对象互相之间的引用；另一方面提供了各种工具方法，方便使用者迅速读取出 module 或 dependency 附加的信息</li><li>ModuleGraphConnection ：记录模块间引用关系的数据结构，内部通过 originModule 属性记录引用关系中的父模块，通过 module 属性记录子模块。此外还提供了一系列函数工具用于判断对应的引用关系的有效性</li><li>ModuleGraphModule ：Module 对象在 Dependency Graph 体系下的补充信息，包含模块对象的 incomingConnections —— 指向模块本身的 ModuleGraphConnection 集合，即谁引用了模块自己；outgoingConnections —— 该模块对外的依赖，即该模块引用了其他那些模块。</li></ul><p>之间关系大致为：</p><img src="/assets/webpack-dependency/01.png"><p>上面类图需要额外注意：</p><ul><li>ModuleGraph 对象通过 _dependencyMap 属性记录 Dependency 对象与 ModuleGraphConnection 连接对象之间的映射关系，后续的处理中可以基于这层映射迅速找到 Dependency 实例对应的引用与被引用者</li><li>ModuleGraph 对象通过 _moduleMap 在 module 基础上附加 ModuleGraphModule 信息，而 ModuleGraphModule 最大的作用就是记录了模块的引用与被引用关系，后续的处理可以基于该属性找到 module 实例的所有依赖与被依赖关系</li></ul><h3 id="2-依赖收集过程"><a class="markdownIt-Anchor" href="#2-依赖收集过程"></a> 2、依赖收集过程</h3><p>ModuleGraph、ModuleGraphConnection、ModuleGraphModule 三者协作，在 webpack 构建过程(make 阶段)中逐步收集模块间的依赖关系，webpack 整体构建流程图如下：</p><img src="/assets/webpack-dependency/02.png"><p>依赖关系收集过程主要发生在两个节点：</p><ul><li>addDependency ：webpack 从模块内容中解析出引用关系后，创建适当的 Dependency 子类并调用该方法记录到 module 实例</li><li>handleModuleCreation ：模块解析完毕后，webpack 遍历父模块的依赖集合，调用该方法创建 Dependency 对应的子模块对象，之后调用 compilation.moduleGraph.setResolvedModule 方法将父子引用信息记录到 moduleGraph 对象上</li></ul><p>setResolvedModule 方法的逻辑大致为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModuleGraph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">/** <span class="doctag">@type <span class="type">&#123;Map&lt;Dependency, ModuleGraphConnection&gt;&#125;</span> </span>*/</span></span><br><span class="line">        <span class="built_in">this</span>._dependencyMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">        <span class="comment">/** <span class="doctag">@type <span class="type">&#123;Map&lt;Module, ModuleGraphModule&gt;&#125;</span> </span>*/</span></span><br><span class="line">        <span class="built_in">this</span>._moduleMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Module&#125;</span> </span>originModule the referencing module</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Dependency&#125;</span> </span>dependency the referencing dependency</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Module&#125;</span> </span>module the referenced module</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="title">setResolvedModule</span>(<span class="params">originModule, dependency, <span class="built_in">module</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> connection = <span class="keyword">new</span> ModuleGraphConnection(</span><br><span class="line">            originModule,</span><br><span class="line">            dependency,</span><br><span class="line">            <span class="built_in">module</span>,</span><br><span class="line">            <span class="literal">undefined</span>,</span><br><span class="line">            dependency.weak,</span><br><span class="line">            dependency.getCondition(<span class="built_in">this</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">this</span>._dependencyMap.set(dependency, connection);</span><br><span class="line">        <span class="keyword">const</span> connections = <span class="built_in">this</span>._getModuleGraphModule(<span class="built_in">module</span>).incomingConnections;</span><br><span class="line">        connections.add(connection);</span><br><span class="line">        <span class="keyword">const</span> mgm = <span class="built_in">this</span>._getModuleGraphModule(originModule);</span><br><span class="line">        <span class="keyword">if</span> (mgm.outgoingConnections === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            mgm.outgoingConnections = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        mgm.outgoingConnections.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例代码主要更改了 _dependencyMap 及 moduleGraphModule 的出入 connections 属性，以此收集当前模块的上下游依赖关系。</p><h3 id="3-实例解析"><a class="markdownIt-Anchor" href="#3-实例解析"></a> 3、实例解析</h3><p>看个简单例子，对于下面的依赖关系：</p><img src="/assets/webpack-dependency/03.png" width="400"><p>Webpack 启动后，在构建阶段递归调用 compilation.handleModuleCreation 函数，逐步补齐 Dependency Graph 结构，最终可能生成如下数据结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ModuleGraph: &#123;</span><br><span class="line">    _dependencyMap: <span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span>&#123;</span><br><span class="line">        &#123; </span><br><span class="line">            EntryDependency&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; =&gt; ModuleGraphConnection&#123;</span><br><span class="line">                <span class="built_in">module</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125;, </span><br><span class="line">                <span class="comment">// 入口模块没有引用者，故设置为 null</span></span><br><span class="line">                originModule: <span class="literal">null</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; </span><br><span class="line">            HarmonyImportSideEffectDependency&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125; =&gt; ModuleGraphConnection&#123;</span><br><span class="line">                <span class="built_in">module</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125;, </span><br><span class="line">                originModule: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; </span><br><span class="line">            HarmonyImportSideEffectDependency&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125; =&gt; ModuleGraphConnection&#123;</span><br><span class="line">                <span class="built_in">module</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/b.js&quot;</span>&#125;, </span><br><span class="line">                originModule: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    _moduleMap: <span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span>&#123;</span><br><span class="line">        NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; =&gt; ModuleGraphModule&#123;</span><br><span class="line">            incomingConnections: <span class="built_in">Set</span>(<span class="number">1</span>) [</span><br><span class="line">                <span class="comment">// entry 模块，对应 originModule 为null</span></span><br><span class="line">                ModuleGraphConnection&#123; <span class="attr">module</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125;, <span class="attr">originModule</span>:<span class="literal">null</span> &#125;</span><br><span class="line">            ],</span><br><span class="line">            outgoingConnections: <span class="built_in">Set</span>(<span class="number">2</span>) [</span><br><span class="line">                <span class="comment">// 从 index 指向 a 模块</span></span><br><span class="line">                ModuleGraphConnection&#123; <span class="attr">module</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125;, <span class="attr">originModule</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; &#125;,</span><br><span class="line">                <span class="comment">// 从 index 指向 b 模块</span></span><br><span class="line">                ModuleGraphConnection&#123; <span class="attr">module</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/b.js&quot;</span>&#125;, <span class="attr">originModule</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125; =&gt; ModuleGraphModule&#123;</span><br><span class="line">            incomingConnections: <span class="built_in">Set</span>(<span class="number">1</span>) [</span><br><span class="line">                ModuleGraphConnection&#123; <span class="attr">module</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/a.js&quot;</span>&#125;, <span class="attr">originModule</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// a 模块没有其他依赖，故 outgoingConnections 属性值为 undefined</span></span><br><span class="line">            outgoingConnections: <span class="literal">undefined</span></span><br><span class="line">        &#125;,</span><br><span class="line">        NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/b.js&quot;</span>&#125; =&gt; ModuleGraphModule&#123;</span><br><span class="line">            incomingConnections: <span class="built_in">Set</span>(<span class="number">1</span>) [</span><br><span class="line">                ModuleGraphConnection&#123; <span class="attr">module</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/b.js&quot;</span>&#125;, <span class="attr">originModule</span>: NormalModule&#123;<span class="attr">request</span>: <span class="string">&quot;./src/index.js&quot;</span>&#125; &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// b 模块没有其他依赖，故 outgoingConnections 属性值为 undefined</span></span><br><span class="line">            outgoingConnections: <span class="literal">undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的 Dependency Graph 可以看出，本质上 ModuleGraph._moduleMap 已经形成了一个有向无环图结构，其中字典 _moduleMap 的 key 为图的节点，对应 value ModuleGraphModule 结构中的 outgoingConnections 属性为图的边，则上例中从起点 index.js 出发沿 outgoingConnections 向前可遍历出图的所有顶点。</p><h2 id="二-作用"><a class="markdownIt-Anchor" href="#二-作用"></a> 二、作用</h2><p>以 webpack@v5.16.0 为例，关键字 moduleGraph 出现了 1277 次，几乎覆盖了 webpack/lib 文件夹下的所有文件，其作用可见一斑。虽然出现的频率很高，但总的来说可以看出有两个主要作用：信息索引、转变为 ChunkGraph 以确定输出结构。</p><h3 id="1-信息索引"><a class="markdownIt-Anchor" href="#1-信息索引"></a> 1、信息索引</h3><p>ModuleGraph 类型提供了很多实现 module / dependency 信息查询的工具函数，例如：</p><ul><li>getModule(dep: Dependency) ：根据 dep 查找对应的 module 实例</li><li>getOutgoingConnections(module: Module) ：查找 module 实例的所有依赖</li><li>getIssuer(module: Module) ：查找 module 在何处被引用</li><li>等等。</li></ul><p>Webpack@v5.x 内部的许多插件、Dependency 子类、Module 子类的实现都需要用到这些工具函数查找特定模块、依赖的信息，例如：</p><ul><li>SplitChunksPlugin 在优化 chunks 处理中，需要使用 moduleGraph.getExportsInfo 查询各个模块的 exportsInfo 信息以确定如何分离 chunk。</li><li>在 compilation.seal 函数中，需要遍历 entry 对应的 dep 并调用 moduleGraph.getModule 获取完整的 module 定义</li><li>…</li></ul><p>那么，在您编写插件时，可以考虑适度参考 webpack/lib/ModuleGraph.js 中提供的方法，确认可以获取使用那些函数获取到您所需要的信息。</p><h3 id="2-构建chunkgraph"><a class="markdownIt-Anchor" href="#2-构建chunkgraph"></a> 2、构建ChunkGraph</h3><p>webpack 实现中，原始的资源模块以 Module 对象形式存在、流转、解析处理。而 Chunk 则是输出产物的基本组织单位，在生成阶段 webpack 按规则将 entry 及其它 Module 插入 Chunk 中，之后再由 SplitChunksPlugin 插件根据优化规则与 ChunkGraph 对 Chunk 做一系列的变化、拆解、合并操作，重新组织成一批性能(可能)更高的 Chunks 。运行完毕之后 webpack 继续将 chunk 一一写入物理文件中，完成编译工作。</p><p>综上，Module 主要作用在 webpack 编译过程的前半段，解决原始资源“「如何读」”的问题；而 Chunk 对象则主要作用在编译的后半段，解决编译产物“「如何写」”的问题，两者合作搭建起 webpack 搭建主流程。</p><p>Chunk 的编排规则非常复杂，涉及 entry、optimization 等诸多配置项，Webpack 主体流程中，make 构建阶段结束之后会进入 seal 阶段，开始梳理以何种方式组织输出内容。在 webpack@v4.x 时，seal 阶段主要围绕 Chunk 及 ChunkGroup 两个类型展开，而到了 5.0 之后，与 Dependency Graph 类似也引入了一套全新的基于 ChunkGraph 的图结构实现资源生成算法。</p><p>到了生成(seal) 阶段，webpack 会根据模块依赖图的内容组织分包 —— Chunk 对象，默认的分包规则有：</p><p>同一个 entry 下触达到的模块组织成一个 chunk<br />异步模块单独组织为一个 chunk<br />entry.runtime 单独组织成一个 chunk<br />默认规则集中在 compilation.seal 函数实现，seal 核心逻辑运行结束后会生成一系列的 Chunk、ChunkGroup、ChunkGraph 对象，后续如 SplitChunksPlugin 插件会在 Chunk 系列对象上做进一步的拆解、优化，最终反映到输出上才会表现出复杂的分包结果。</p><h4 id="1-entry-分包处理"><a class="markdownIt-Anchor" href="#1-entry-分包处理"></a> (1) Entry 分包处理</h4><p>在 compilation.seal 函数中，首先根据默认规则 —— 每个 entry 对应组织为一个 chunk ，之后调用 webpack/lib/buildChunkGraph.js 文件定义的 buildChunkGraph 方法，遍历 make 阶段生成的 moduleGraph 对象从而将 module 依赖关系转化为 chunkGraph 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">&quot;./src/main&quot;</span>,</span><br><span class="line">    home: <span class="string">&quot;./src/home&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于上述配置 Webpack 会遍历 entry 对象属性并创建出 <code>chunk[main]</code>、<code>chunk[home]</code> 两个对象，此时两个 chunk 分别包含 main 、home 模块：</p><img src="/assets/webpack-dependency/04.webp" width="600"><p>初始化完毕后，Webpack 会读取 ModuleDependencyGraph 的内容，将 entry 所对应的内容塞入对应的 chunk (发生在 webpack/lib/buildChunkGrap.js 文件)。比如对于如下文件依赖：</p><img src="/assets/webpack-dependency/05.png" width="700"><p>main.js 以同步方式直接或间接引用了 a/b/c/d 四个文件，分析 ModuleDependencyGraph 过程会逐步将 a/b/c/d 模块逐步添加到 chunk[main] 中，最终形成：</p><img src="/assets/webpack-dependency/06.png" width="600"><h4 id="2异步模块分包处理"><a class="markdownIt-Anchor" href="#2异步模块分包处理"></a> (2)异步模块分包处理</h4><p>Webpack 4 之后，只需要用异步语句 require.ensure(&quot;./xx.js&quot;) 或 import(&quot;./xx.js&quot;) 方式引入模块，就可以实现模块的动态加载，这种能力本质也是基于 Chunk 实现的。</p><p>Webpack 生成阶段中，遇到异步引入语句时会为该模块单独生成一个 chunk 对象，并将其子模块都加入这个 chunk 中。例如对于下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js, entry 文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;sync-a&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;sync-b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;async-c&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在 index.js 中，以同步方式引入 sync-a、sync-b；以异步方式引入 async-a 模块；同时，在 async-a 中以同步方式引入 sync-c 模块。对应的模块依赖如：</p><img src="/assets/webpack-dependency/07.png" width="600"><p>此时，webpack 会为入口 index.js、异步模块 async-a.js 分别创建分包，形成如下数据：</p><img src="/assets/webpack-dependency/08.png" width="600"><p>这里需要引入一个新的概念 —— Chunk 间的父子关系。由 entry 生成的 Chunk 之间相互孤立，没有必然的前后依赖关系，但异步生成的 Chunk 则不同，引用者(上例 index.js 块)需要在特定场景下使用被引用者(上例 async-a 块)，两者间存在单向依赖关系，在 webpack 中称引用者为 parent、被引用者为 child，分别存放在 <code>ChunkGroup._parents</code> 、<code>ChunkGroup._children</code> 属性中。</p><p>上述分包方案默认情况下会生成两个文件：</p><ul><li>入口 index 对应的 index.js</li><li>异步模块 async-a 对应的 src_async-a_js.js</li></ul><p>运行时，webpack 在 index.js 中使用 promise 及 <code>__webpack_require__.e</code> 方法异步载入并运行文件 src_async-a_js.js ，从而实现动态加载。</p><h4 id="3runtime-分包"><a class="markdownIt-Anchor" href="#3runtime-分包"></a> (3)Runtime 分包</h4><p>除了 entry、异步模块外，webpack 5之后还支持基于 runtime 的分包规则。除业务代码外，Webpack 编译产物中还需要包含一些用于支持 webpack 模块化、异步加载等特性的支撑性代码，这类代码在 webpack 中被统称为 runtime。举个例子，产物中通常会包含如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******/</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// webpackBootstrap</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="keyword">var</span> __webpack_modules__ = &#123;&#125;; <span class="comment">// The module cache</span></span><br><span class="line">  <span class="comment">/************************************************************************/</span></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">/******/</span> <span class="keyword">var</span> __webpack_module_cache__ = &#123;&#125;; <span class="comment">// The require function</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">/******/</span> <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">/******/</span> __webpack_modules__[moduleId](</span><br><span class="line">      <span class="built_in">module</span>,</span><br><span class="line">      <span class="built_in">module</span>.exports,</span><br><span class="line">      __webpack_require__</span><br><span class="line">    ); <span class="comment">// Return the exports of the module</span></span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/******/</span> <span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">    <span class="comment">/******/</span></span><br><span class="line">  &#125; <span class="comment">// expose the modules object (__webpack_modules__)</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/******/</span> <span class="comment">/******/</span> __webpack_require__.m = __webpack_modules__; <span class="comment">/* webpack/runtime/compat get default export */</span></span><br><span class="line">  <span class="comment">/******/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>编译时，Webpack 会根据业务代码决定输出那些支撑特性的运行时代码(基于 Dependency 子类)，例如：</p><ul><li>需要 <code>__webpack_require__.f</code>、<code>__webpack_require__.r</code> 等功能实现最起码的模块化支持</li><li>如果用到动态加载特性，则需要写入 <code>__webpack_require__.e</code> 函数</li><li>如果用到 Module Federation 特性，则需要写入 <code>__webpack_require__.o</code> 函数</li><li>等等</li></ul><p>虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 entry 应用，在每个入口都重复打包一份相似的运行时代码显得有点浪费，为此 webpack 5 专门提供了 entry.runtime 配置项用于声明如何打包运行时代码。用法上只需在 entry 项中增加字符串形式的 runtime 值，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: &#123; <span class="attr">import</span>: <span class="string">&quot;./src/index&quot;</span>, <span class="attr">runtime</span>: <span class="string">&quot;solid-runtime&quot;</span> &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Webpack 执行完 entry、异步模块分包后，开始遍历 entry 配置判断是否带有 runtime 属性，如果有则创建以 runtime 值为名的 Chunk，因此，上例配置将生成两个chunk：chunk[index.js] 、chunk[solid-runtime]，并据此最终产出两个文件：</p><ul><li>入口 index 对应的 index.js 文件</li><li>运行时配置对应的 solid-runtime.js 文件</li></ul><p>在多 entry 场景中，只要为每个 entry 都设定相同的 runtime 值，webpack 运行时代码最终就会集中写入到同一个 chunk，例如对于如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: &#123; <span class="attr">import</span>: <span class="string">&quot;./src/index&quot;</span>, <span class="attr">runtime</span>: <span class="string">&quot;solid-runtime&quot;</span> &#125;,</span><br><span class="line">    home: &#123; <span class="attr">import</span>: <span class="string">&quot;./src/home&quot;</span>, <span class="attr">runtime</span>: <span class="string">&quot;solid-runtime&quot;</span> &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>入口 index、home 共享相同的 runtime ，最终生成三个 chunk，分别为：</p><img src="/assets/webpack-dependency/09.png" width="600"><p>同时生成三个文件：</p><ul><li>入口 index 对应的 index.js</li><li>入口 index 对应的 home.js</li><li>运行时代码对应的 solid-runtime.js</li></ul><h4 id="4分包规则的问题"><a class="markdownIt-Anchor" href="#4分包规则的问题"></a> (4)分包规则的问题</h4><p>至此，webpack 分包规则的基本逻辑就介绍完毕了，实现上，大部分功能代码都集中在：</p><ul><li>webpack/lib/compilation.js 文件的 seal 函数</li><li>webpack/lib/buildChunkGraph.js 的 buildChunkGraph 函数</li></ul><p>默认分包规则最大的问题是无法解决模块重复，如果多个 chunk 同时包含同一个 module，那么这个 module 会被不受限制地重复打包进这些 chunk。比如假设我们有两个入口 main/index 同时依赖了同一个模块：</p><img src="/assets/webpack-dependency/10.png" width="600"><p>默认情况下，webpack 不会对此做额外处理，只是单纯地将 c 模块同时打包进 main/index 两个 chunk，最终形成：</p><img src="/assets/webpack-dependency/11.png" width="600"><p>可以看到 chunk 间互相孤立，模块 c 被重复打包，对最终产物可能造成不必要的性能损耗！</p><p>为了解决这个问题，webpack 3 引入 CommonChunkPlugin 插件试图将 entry 之间的公共依赖提取成单独的 chunk，但 CommonChunkPlugin 本质上是基于 Chunk 之间简单的父子关系链实现的，很难推断出提取出的第三个包应该作为 entry 的父 chunk 还是子 chunk，CommonChunkPlugin 统一处理为父 chunk，某些情况下反而对性能造成了不小的负面影响。在 webpack 4 之后则引入了更负责的设计 —— ChunkGroup 专门实现关系链管理，配合 SplitChunksPlugin 能够更高效、智能地实现「启发式分包」。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;非原创：原文地址&lt;a href=&quot;https://mp.weixin.qq.com/s/kr73Epnn6wAx9DH7KRVUaA&quot;&gt;有点难的 webpack 知识点：Dependency Graph 深度解析&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Dependency Graph 概念来自官网 Dependency Graph | webpack 一文，原文解释是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Any time one file depends on another, webpack treats this as a dependency. This allows webpack to take non-code assets, such as images or web fonts, and also provide them as dependencies for your application.&lt;br /&gt;
When webpack processes your application, it starts from a list of modules defined on the command line or in its configuration file. Starting from these entry points, webpack recursively builds a dependency graph that includes every module your application needs, then bundles all of those modules into a small number of bundles - often, just one - to be loaded by the browser.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来核心意思是：webpack 处理应用代码时，会从开发者提供的 entry 开始递归地组建起包含所有模块的 dependency graph，之后再将这些 module 打包为 bundles 。&lt;/p&gt;
&lt;p&gt;然而事实远不止官网描述的这么简单，Dependency Graph 贯穿 webpack 整个运行周期，从 make 阶段的模块解析，到 seal 阶段的 chunk 生成，以及 tree-shaking 功能都高度依赖于Dependency Graph ，是 webpack 资源构建的一个非常核心的数据结构&lt;/p&gt;
&lt;p&gt;本文将围绕 webpack@v5.x 的 Dependency Graph 实现，展开讨论三个方面的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dependency Graph 在 webpack 实现中以何种数据结构呈现&lt;/li&gt;
&lt;li&gt;Webpack 运行过程中如何收集模块间依赖关系，进而构建出 Dependency Graph&lt;/li&gt;
&lt;li&gt;Dependency Graph 构建完毕后，又是如何被消费的&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="前端工程化" scheme="http://kyleezhang.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="webpack" scheme="http://kyleezhang.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack构建打包优化</title>
    <link href="http://kyleezhang.com/2021/08/05/webpack-optimize/"/>
    <id>http://kyleezhang.com/2021/08/05/webpack-optimize/</id>
    <published>2021-08-05T10:37:42.000Z</published>
    <updated>2022-06-12T11:24:41.829Z</updated>
    
    <content type="html"><![CDATA[<p>在我的博客<a href="https://kyleezhang.github.io/2020/12/16/webpack-runtime/">Webpack运行机制</a>中介绍了 Webpack 的基本工作流程，并介绍了 Compiler 和 Compilation 两个核心模块中的生命周期 Hooks，那么在 Compiler 和 Compilation 的工作流程里，最耗时的阶段分别是哪个呢？</p><p>对于 Compiler 实例而言，耗时最长的显然是生成编译过程实例后的 make 阶段，在这个阶段里，会执行模块编译到优化的完整过程。而对于 Compilation 实例的工作流程来说，不同的项目和配置各有不同，但总体而言，编译模块和后续优化阶段的生成产物并压缩代码的过程都是比较耗时的。</p><p>实际上不同项目的构建，在整个流程的前期初始化阶段与最后的产物生成阶段的构建时间区别不大。真正影响整个构建效率的还是 Compilation 实例的处理过程，这一过程又可分为两个阶段：编译模块和优化处理，下面针对这两个阶段我们分别介绍对应的优化手段。</p><a id="more"></a><p>直接开搞！</p><img src="/assets/emoji/06.png" width="200" /><h2 id="一-编译提效"><a class="markdownIt-Anchor" href="#一-编译提效"></a> 一、编译提效</h2><p>编译模块阶段所耗的时间是从单个入口点开始，编译每个模块的时间的总和。要提升这一阶段的构建效率，大致可以分为三个方向：</p><ul><li>减少执行编译的模块。</li><li>提升单个模块构建的速度。</li><li>并行构建以提升总体效率。</li></ul><h3 id="1-减少执行编译的模块"><a class="markdownIt-Anchor" href="#1-减少执行编译的模块"></a> 1、减少执行编译的模块</h3><p>提升编译模块阶段效率的第一个方向就是减少执行编译的模块。显而易见，如果一个项目每次构建都需要编译 1000 个模块，但是通过分析后发现其中有 500 个不需要编译，显而易见，经过优化后，构建效率可以大幅提升。</p><h4 id="1ignoreplugin"><a class="markdownIt-Anchor" href="#1ignoreplugin"></a> (1)IgnorePlugin</h4><p>有的依赖包，除了项目所需的模块内容外，还会附带一些多余的模块。典型的例子是 moment 这个包，一般情况下在构建时会自动引入其 locale 目录下的多国语言包，这实际上是完全没有必要的，这种情形下我们就可以通过 IgnorePlugin 实现打包时对第三方包指定目录忽略。</p><p>使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resourceRegExp: A RegExp to test the resource against.</span></span><br><span class="line"><span class="comment">// contextRegExp: (optional) A RegExp to test the context (directory) against.</span></span><br><span class="line"><span class="keyword">new</span> webpack.IgnorePlugin(&#123; resourceRegExp, contextRegExp &#125;);</span><br><span class="line"><span class="comment">// Supported in webpack 4 and earlier, unsupported in webpack 5:</span></span><br><span class="line"><span class="keyword">new</span> webpack.IgnorePlugin(resourceRegExp, [contextRegExp]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkResource (resource, context): A Filter function that receives resource and context as arguments, must return boolean.</span></span><br><span class="line"><span class="keyword">new</span> webpack.IgnorePlugin(&#123;</span><br><span class="line">  <span class="function"><span class="title">checkResource</span>(<span class="params">resource</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// do something with resource</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> | <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以 moment 为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">new</span> webpack.IgnorePlugin(&#123;</span><br><span class="line">  resourceRegExp: <span class="regexp">/^\.\/locale$/</span>,</span><br><span class="line">  contextRegExp: <span class="regexp">/moment$/</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ***.js</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">&#x27;moment&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置语言</span></span><br><span class="line"><span class="comment">//手动引入所需要的语言包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;moment/locale/zh-cn&#x27;</span>;</span><br><span class="line"></span><br><span class="line">moment.locale(<span class="string">&#x27;zh-cn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = moment().endOf(<span class="string">&#x27;day&#x27;</span>).fromNow();</span><br></pre></td></tr></table></figure><p>在示例中我们通过 IgnorePlugin 忽略了包含 ’./locale/’ 该字段路径的文件目录，但是也使得我们使用的时候不能显示中文语言了，所以这个时候可以手动引入中文语言的目录，这样就实现了只引入必要文件，减少非必要的模块的编译。</p><h4 id="2按需引入类库模块"><a class="markdownIt-Anchor" href="#2按需引入类库模块"></a> (2)按需引入类库模块</h4><p>第二种典型的减少执行模块的方式是按需引入。这种方式一般适用于工具类库性质的依赖包的优化，典型例子是 lodash 依赖包。通常在项目里我们只用到了少数几个 lodash 的方法，但是构建时却发现构建时引入了整个依赖包，要解决这个问题，效果最佳的方式是在导入声明时只导入依赖包内的特定模块，这样就可以大大减少构建时间，以及产物的体积，除了在导入时声明特定模块之外，还可以使用 babel-plugin-lodash 或 babel-plugin-import 等插件达到同样的效果。</p><p>另外，有同学也许会想到 Tree Shaking，这一特性也能减少产物包的体积，但是这里有两点需要注意：</p><ul><li>Tree Shaking 需要相应导入的依赖包使用 ES6 模块化，而 lodash 还是基于 CommonJS ，需要替换为 lodash-es 才能生效。</li><li>相应的操作是在优化阶段进行的，换句话说，Tree Shaking 并不能减少模块编译阶段的构建时间。</li></ul><h4 id="3dllplugin"><a class="markdownIt-Anchor" href="#3dllplugin"></a> (3)DllPlugin</h4><p>“DLL” 一词代表微软最初引入的动态链接库。在一个动态链接库中可以包含给其他模块调用的函数和数据。</p><p>要给 Web 项目构建接入动态链接库的思想，需要完成以下事情：</p><ul><li>把网页依赖的基础模块抽离出来，打包到一个个单独的动态链接库中去。一个动态链接库中可以包含多个模块。</li><li>当需要导入的模块存在于某个动态链接库中时，这个模块不能被再次被打包，而是去动态链接库中获取。</li><li>页面依赖的所有动态链接库需要被加载。</li></ul><p>为什么给 Web 项目构建接入动态链接库的思想后，会大大提升构建速度呢？ 原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码。 由于动态链接库中大多数包含的是常用的第三方模块，例如 react、react-dom，只要不升级这些模块的版本，动态链接库就不用重新编译。</p><p>Webpack 已经内置了对动态链接库的支持，需要通过2个内置的插件接入，它们分别是：</p><ul><li>DllPlugin 插件：用于打包出一个个单独的动态链接库文件。</li><li>DllReferencePlugin 插件：用于在主要配置文件中去引入 DllPlugin 插件打包好的动态链接库文件。</li></ul><p>下面以基本的 React 项目为例，为其接入 DllPlugin，在开始前先来看下最终构建出的目录结构：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── main.js</span><br><span class="line">├── polyfill.dll.js</span><br><span class="line">├── polyfill.manifest.json</span><br><span class="line">├── react.dll.js</span><br><span class="line">└── react.manifest.json</span><br></pre></td></tr></table></figure><p>其中包含两个动态链接库文件，分别是：</p><ul><li>polyfill.dll.js 里面包含项目所有依赖的 polyfill，例如 Promise、fetch 等 API。</li><li>react.dll.js 里面包含 React 的基础运行环境，也就是 react 和 react-dom 模块。</li></ul><p>以 react.dll.js 文件为例，其文件内容大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _dll_react = (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... 此处省略 webpackBootstrap 函数代码</span></span><br><span class="line">&#125;([</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块 ID 为 0 的模块对应的代码</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块 ID 为 1 的模块对应的代码</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... 此处省略剩下的模块对应的代码 </span></span><br><span class="line">]));</span><br></pre></td></tr></table></figure><p>可见一个动态链接库文件中包含了大量模块的代码，这些模块存放在一个数组里，用数组的索引号作为 ID。 并且还通过 _dll_react 变量把自己暴露在了全局中，也就是可以通过 window._dll_react 可以访问到它里面包含的模块。</p><p>其中 polyfill.manifest.json 和 react.manifest.json 文件也是由 DllPlugin 生成出，用于描述动态链接库文件中包含哪些模块， 以 react.manifest.json 文件为例，其文件内容大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 描述该动态链接库文件暴露在全局的变量名称</span><br><span class="line">  &quot;name&quot;: &quot;_dll_react&quot;,</span><br><span class="line">  &quot;content&quot;: &#123;</span><br><span class="line">    &quot;.&#x2F;node_modules&#x2F;process&#x2F;browser.js&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: 0,</span><br><span class="line">      &quot;meta&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; ... 此处省略部分模块</span><br><span class="line">    &quot;.&#x2F;node_modules&#x2F;react-dom&#x2F;lib&#x2F;ReactBrowserEventEmitter.js&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: 42,</span><br><span class="line">      &quot;meta&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;.&#x2F;node_modules&#x2F;react&#x2F;lib&#x2F;lowPriorityWarning.js&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: 47,</span><br><span class="line">      &quot;meta&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; ... 此处省略部分模块</span><br><span class="line">    &quot;.&#x2F;node_modules&#x2F;react-dom&#x2F;lib&#x2F;SyntheticTouchEvent.js&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: 210,</span><br><span class="line">      &quot;meta&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;.&#x2F;node_modules&#x2F;react-dom&#x2F;lib&#x2F;SyntheticTransitionEvent.js&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: 211,</span><br><span class="line">      &quot;meta&quot;: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 manifest.json 文件清楚地描述了与其对应的 dll.js 文件中包含了哪些模块，以及每个模块的路径和 ID。</p><p>main.js 文件是编译出来的执行入口文件，当遇到其依赖的模块在 dll.js 文件中时，会直接通过 dll.js 文件暴露出的全局变量去获取打包在 dll.js 文件的模块。 所以在 index.html 文件中需要把依赖的两个 dll.js 文件给加载进去，index.html 内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入依赖的动态链接库文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/polyfill.dll.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/react.dll.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入执行入口文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上就是所有接入 DllPlugin 后最终编译出来的代码，接下来教你如何实现。</p><p><strong>构建出动态链接库文件</strong></p><p>构建输出的以下这四个文件</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── polyfill.dll.js</span><br><span class="line">├── polyfill.manifest.json</span><br><span class="line">├── react.dll.js</span><br><span class="line">└── react.manifest.json</span><br></pre></td></tr></table></figure><p>和以下这一个文件</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">├── main.js</span><br></pre></td></tr></table></figure><p>是由两份不同的构建分别输出的。</p><p>动态链接库文件相关的文件需要由一份独立的构建输出，用于给主构建使用。新建一个 Webpack 配置文件 webpack_dll.config.js 专门用于构建它们，文件内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> DllPlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack/lib/DllPlugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// JS 执行入口文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 把 React 相关模块的放到一个单独的动态链接库</span></span><br><span class="line">    react: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>],</span><br><span class="line">    <span class="comment">// 把项目需要所有的 polyfill 放到一个单独的动态链接库</span></span><br><span class="line">    polyfill: [<span class="string">&#x27;core-js/fn/object/assign&#x27;</span>, <span class="string">&#x27;core-js/fn/promise&#x27;</span>, <span class="string">&#x27;whatwg-fetch&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 输出的动态链接库的文件名称，[name] 代表当前动态链接库的名称，</span></span><br><span class="line">    <span class="comment">// 也就是 entry 中配置的 react 和 polyfill</span></span><br><span class="line">    filename: <span class="string">&#x27;[name].dll.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 输出的文件都放到 dist 目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="comment">// 存放动态链接库的全局变量名称，例如对应 react 来说就是 _dll_react</span></span><br><span class="line">    <span class="comment">// 之所以在前面加上 _dll_ 是为了防止全局变量冲突</span></span><br><span class="line">    library: <span class="string">&#x27;_dll_[name]&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 接入 DllPlugin</span></span><br><span class="line">    <span class="keyword">new</span> DllPlugin(&#123;</span><br><span class="line">      <span class="comment">// 动态链接库的全局变量名称，需要和 output.library 中保持一致</span></span><br><span class="line">      <span class="comment">// 该字段的值也就是输出的 manifest.json 文件 中 name 字段的值</span></span><br><span class="line">      <span class="comment">// 例如 react.manifest.json 中就有 &quot;name&quot;: &quot;_dll_react&quot;</span></span><br><span class="line">      name: <span class="string">&#x27;_dll_[name]&#x27;</span>,</span><br><span class="line">      <span class="comment">// 描述动态链接库的 manifest.json 文件输出时的文件名称</span></span><br><span class="line">      path: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;[name].manifest.json&#x27;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用动态链接库文件</strong></p><p>构建出的动态链接库文件用于给其它地方使用，在这里也就是给执行入口使用。</p><p>用于输出 main.js 的主 Webpack 配置文件内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> DllReferencePlugin = <span class="built_in">require</span>(<span class="string">&#x27;webpack/lib/DllReferencePlugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 定义入口 Chunk</span></span><br><span class="line">    main: <span class="string">&#x27;./main.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 输出文件的名称</span></span><br><span class="line">    filename: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 输出文件都放到 dist 目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 项目源码使用了 ES6 和 JSX 语法，需要使用 babel-loader 转换</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">        exclude: path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 告诉 Webpack 使用了哪些动态链接库</span></span><br><span class="line">    <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">      <span class="comment">// 描述 react 动态链接库的文件内容</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">&#x27;./dist/react.manifest.json&#x27;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">      <span class="comment">// 描述 polyfill 动态链接库的文件内容</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">&#x27;./dist/polyfill.manifest.json&#x27;</span>),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  devtool: <span class="string">&#x27;source-map&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：在 webpack_dll.config.js 文件中，DllPlugin 中的 name 参数必须和 output.library 中保持一致。 原因在于 DllPlugin 中的 name 参数会影响输出的 manifest.json 文件中 name 字段的值， 而在 webpack.config.js 文件中 DllReferencePlugin 会去 manifest.json 文件读取 name 字段的值， 把值的内容作为在从全局变量中获取动态链接库中内容时的全局变量名。</p><p><strong>执行构建</strong></p><p>在修改好以上两个 Webpack 配置文件后，需要重新执行构建。 重新执行构建时要注意的是需要先把动态链接库相关的文件编译出来，因为主 Webpack 配置文件中定义的 DllReferencePlugin 依赖这些文件。执行构建时流程如下：</p><ul><li>如果动态链接库相关的文件还没有编译出来，就需要先把它们编译出来。方法是执行 webpack --config webpack_dll.config.js 命令。</li><li>在确保动态链接库存在时，才能正常的编译出入口执行文件。方法是执行 webpack 命令。这时你会发现构建速度有了非常大的提升。</li></ul><h4 id="4externals"><a class="markdownIt-Anchor" href="#4externals"></a> (4)Externals</h4><p>Webpack 配置中的 externals 和 DllPlugin 解决的是同一类问题：将依赖的框架等模块从构建过程中移除。它们的区别在于：</p><ul><li>在 Webpack 的配置方面，externals 更简单，而 DllPlugin 需要独立的配置文件。</li><li>DllPlugin 包含了依赖包的独立构建流程，而 externals 配置中不包含依赖框架的生成方式，通常使用已传入 CDN 的依赖包。</li><li>externals 配置的依赖包需要单独指定依赖模块的加载方式：全局对象、CommonJS、AMD 等。</li><li>在引用依赖包的子模块时，DllPlugin 无须更改，而 externals 则会将子模块打入项目包中。</li></ul><p>使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">externals: string | [string] | object | <span class="function"><span class="keyword">function</span> | <span class="title">RegExp</span></span></span><br></pre></td></tr></table></figure><ol><li><strong>字符串</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  externals: &#123;</span><br><span class="line">    jquery: <span class="string">&#x27;jQuery&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.1.0.js&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">integrity</span>=<span class="string">&quot;sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们以上述示例为例，externals 属性名称是 jquery，表示应该排除 <code>import $ from 'jquery'</code> 中的 jquery 模块。为了替换这个模块，jQuery 的值将被用来检索一个全局的 jQuery 变量。换句话说，当设置为一个字符串时，它将被视为全局的（定义在上面和下面）。</p><p>如果想将一个符合 CommonJS 模块化规则的类库外部化，我们可以提供外联类库的类型以及类库的名称。举个例子，如果你想将 fs-extra 从输出的 bundle 中剔除并在运行时中引入它，你可以如下定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="string">&#x27;fs-extra&#x27;</span>: <span class="string">&#x27;commonjs2 fs-extra&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样的做法会让任何依赖的模块都不变，正如以下所示的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs-extra&#x27;</span>;</span><br></pre></td></tr></table></figure><p>会将代码编译成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>字符串数组</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  externals: &#123;</span><br><span class="line">    subtract: [<span class="string">&#x27;./math&#x27;</span>, <span class="string">&#x27;subtract&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>subtract: ['./math', 'subtract']</code> 转换为父子结构，其中 ./math 是父模块，而 bundle 只引用 subtract 变量下的子集。该例子会编译成 require(’./math’).subtract;</p><ol start="3"><li><strong>对象</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  externals: &#123;</span><br><span class="line">    react: <span class="string">&#x27;react&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">  externals: &#123;</span><br><span class="line">    lodash: &#123;</span><br><span class="line">      commonjs: <span class="string">&#x27;lodash&#x27;</span>,</span><br><span class="line">      amd: <span class="string">&#x27;lodash&#x27;</span>,</span><br><span class="line">      root: <span class="string">&#x27;_&#x27;</span>, <span class="comment">// 指向全局变量</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">  externals: &#123;</span><br><span class="line">    subtract: &#123;</span><br><span class="line">      root: [<span class="string">&#x27;math&#x27;</span>, <span class="string">&#x27;subtract&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此语法用于描述外部 library 所有可用的访问方式。这里 lodash 这个外部 library 可以在 AMD 和 CommonJS 模块系统中通过 lodash 访问，但在全局变量形式下用 _ 访问。subtract 可以通过全局 math 对象下的属性 subtract 访问（例如 window[‘math’][‘subtract’]）。</p><p>注：一个形如 { root, amd, commonjs, … } 的对象仅允许用于 libraryTarget: ‘umd’ 这样的配置.它不被允许 用于其它的 library targets 配置值.</p><ol start="4"><li><strong>函数</strong></li></ol><ul><li>function ({ context, request, contextInfo, getResolve }, callback)</li><li>function ({ context, request, contextInfo, getResolve }) =&gt; promise // 5.15.0+</li></ul><p>对于 webpack 外部化，通过定义函数来控制行为，可能会很有帮助。例如，webpack-node-externals 能够排除 node_modules 目录中所有模块，还提供一些选项，比如白名单 package(whitelist package)。</p><p>函数接收两个入参：</p><ul><li>ctx (object)：包含文件详情的对象。<ul><li>ctx.context (string): 包含引用的文件目录。</li><li>ctc.request (string): 被请求引入的路径。</li><li>ctx.contextInfo (string): 包含 issuer 的信息（如，layer）</li><li>ctx.getResolve 5.15.0+: 获取当前解析器选项的解析函数。</li></ul></li><li>callback (function (err, result, type)): 用于指明模块如何被外部化的回调函数</li></ul><p>回调函数接收三个入参：</p><ul><li>err (Error): 被用于表明在外部外引用的时候是否会产生错误。如果有错误，这将会是唯一被用到的参数。</li><li>result (string [string] object): 描述外部化的模块。可以接受形如 ${type} ${path} 格式的字符串，或者其它标准化外部化模块格式，(string, [string]，或 object)。</li><li>type (string): 可选的参数，用于指明模块的类型（如果它没在 result 参数中被指明）。</li></ul><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  externals: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">ctx, callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 该外部化模块是一个全局变量叫作 `nameOfGlobal`.</span></span><br><span class="line">      callback(<span class="literal">null</span>, <span class="string">&#x27;nameOfGlobal&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">&#123; context, request &#125;, callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/^yourregex$/</span>.test(request)) &#123;</span><br><span class="line">        <span class="comment">// 使用 request 路径，将一个 commonjs 模块外部化</span></span><br><span class="line">        <span class="keyword">return</span> callback(<span class="literal">null</span>, <span class="string">&#x27;commonjs &#x27;</span> + request);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 继续下一步且不外部化引用</span></span><br><span class="line">      callback();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">ctx, callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 该外部化模块是一个在`@scope/library`模块里的命名导出（named export）。</span></span><br><span class="line">      callback(<span class="literal">null</span>, [<span class="string">&#x27;@scope/library&#x27;</span>, <span class="string">&#x27;namedexport&#x27;</span>], <span class="string">&#x27;commonjs&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">ctx, callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 外部化模块是一个 UMD 模块</span></span><br><span class="line">      callback(<span class="literal">null</span>, &#123;</span><br><span class="line">        root: <span class="string">&#x27;componentsGlobal&#x27;</span>,</span><br><span class="line">        commonjs: <span class="string">&#x27;@scope/components&#x27;</span>,</span><br><span class="line">        commonjs2: <span class="string">&#x27;@scope/components&#x27;</span>,</span><br><span class="line">        amd: <span class="string">&#x27;components&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>RegExp</strong></li></ol><p>匹配给定正则表达式的每个依赖，都将从输出 bundle 中排除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  externals: <span class="regexp">/^(jquery|\$)$/i</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个示例中，所有名为 jQuery 的依赖（忽略大小写），或者 $，都会被外部化。</p><h3 id="2-提升单个模块构建的速度"><a class="markdownIt-Anchor" href="#2-提升单个模块构建的速度"></a> 2、提升单个模块构建的速度</h3><p>提升编译阶段效率的第二个方向，是在保持构建模块数量不变的情况下，提升单个模块构建的速度。具体来说，是通过减少构建单个模块时的一些处理逻辑来提升速度。这个方向的优化主要有以下几种：</p><h4 id="1includeexclude"><a class="markdownIt-Anchor" href="#1includeexclude"></a> (1)include/exclude</h4><p>include 的用途是只对符合条件的模块使用指定 Loader 进行转换处理。而 exclude 则相反，不对特定条件的模块使用该 Loader。举个例子我们不使用 babel-loader 处理 node_modules 中的模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      include: <span class="regexp">/src|jquery/</span>, <span class="comment">//这里的include jquery将不生效，因为exclude优先级更高</span></span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      use: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这儿需要注意通过 include/exclude 排除的模块，并非不进行编译，只是不通过 babel-loader 而是使用 Webpack 默认的 js 模块编译器进行编译（例如推断依赖包的模块类型，加上装饰代码等）。</p><h4 id="2noparse"><a class="markdownIt-Anchor" href="#2noparse"></a> (2)noParse</h4><p>Webpack 配置中的 module.noParse 则是在上述 include/exclude 的基础上，进一步省略了使用默认 js 模块编译器进行编译的时间，忽略的文件中 不应该含有 import, require, define 的调用，或任何其他导入机制。忽略大型的 library 可以提高构建性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="function">(<span class="params">content</span>) =&gt;</span> <span class="regexp">/jquery|lodash/</span>.test(content),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="regexp">/jquery|lodash/</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3sourcemap"><a class="markdownIt-Anchor" href="#3sourcemap"></a> (3)SourceMap</h4><p>SourceMap 的不同配置对于项目的构建时间都是不同的，对于生产环境的代码构建而言，会根据项目实际情况判断是否开启 Source Map。在开启 Source Map 的情况下，优先选择与源文件分离的类型，例如 “source-map”。有条件也可以配合错误监控系统，将 Source Map 的构建和使用在线下监控后台中进行，以提升普通构建部署流程的速度。</p><h4 id="4typescript编译优化"><a class="markdownIt-Anchor" href="#4typescript编译优化"></a> (4)TypeScript编译优化</h4><p>Webpack 中编译 TS 有两种方式：使用 ts-loader 或使用 babel-loader。其中，在使用 ts-loader 时，由于 ts-loader 默认在编译前进行类型检查，因此编译时间往往比较慢，通过加上配置项 transpileOnly: true，可以在编译时忽略类型检查，从而大大提升 TS 模块的编译速度，而 babel-loader 则需要单独安装 @babel/preset-typescript 来支持编译 TS（Babel 7 之前的版本则还是需要使用 ts-loader）。babel-loader 的编译效率与上述 ts-loader 优化后的效率相当。</p><p>不过单独使用这一功能就丧失了 TS 中重要的类型检查功能，因此在许多脚手架中往往配合 ForkTsCheckerWebpackPlugin 一同使用。</p><h4 id="5resolve"><a class="markdownIt-Anchor" href="#5resolve"></a> (5)Resolve</h4><p>Webpack 中的 resolve 配置制定的是在构建时指定查找模块文件的规则，例如：</p><ul><li>resolve.modules：指定查找模块的目录范围。</li><li>resolve.extensions：指定查找模块的文件类型范围。</li><li>resolve.mainFields：指定查找模块的 package.json 中主文件的属性名。</li><li>resolve.symlinks：指定在查找模块时是否处理软连接。</li><li>resolve.alias：创建 import 或 require 的别名，来确保模块引入变得更简单</li></ul><p>这些规则在处理每个模块时都会有所应用，因此尽管对小型项目的构建速度来说影响不大，但对于大型的模块众多的项目而言，这些配置的变化就可能产生客观的构建时长区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      react: path.resolve(__dirname, <span class="string">&#x27;./node_modules/react/dist/react.min.js&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    modules: [path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>)],</span><br><span class="line">    mainFields: [<span class="string">&#x27;main&#x27;</span>],</span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-并行构建以提升"><a class="markdownIt-Anchor" href="#3-并行构建以提升"></a> 3、并行构建以提升</h3><p>第三个编译阶段提效的方向是使用并行的方式来提升构建的效率。并行构建的方案早在 Webpack 2 时代已经出现，随着目前最新稳定版本 Webpack 4 的发布，人们发现在一般项目的开发阶段和小型项目的各构建流程中已经用不到这种并发的思路了，因为在这些情况下，并发所需要的多进程管理与通信所带来的额外时间成本可能会超过使用工具带来的收益。但是在大中型项目的生产环境构建时，这类工具仍有发挥作用的空间。这里我们介绍两类并行构建的工具： HappyPack 与 thread-loader，以及 parallel-webpack。</p><h4 id="1happypack-与-thread-loader"><a class="markdownIt-Anchor" href="#1happypack-与-thread-loader"></a> (1)HappyPack 与 thread-loader</h4><p>这两种工具的本质作用相同，都作用于模块编译的 Loader 上，每次 webpack 解析一个模块，它们都会将该模块及该模块的依赖分配给 worker 进程中，以开启多进程的方式加速编译。HappyPack 诞生较早，在 webpack 3 的版本中使用比较广泛，但是 webpack 4 的版本中官方推出了 thread-loader，并且 thread-loader 参照 HappyPack 的效果实现了更符合 Webpack 中 Loader 的编写方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意如果 webpack 的版本为 4 的话必须保证 HappyPack 的版本在 5 以上</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="string">&#x27;/.js$/&#x27;</span>,</span><br><span class="line">        include: path.resolve(<span class="string">&quot;src&quot;</span>),</span><br><span class="line">        use: [<span class="string">&#x27;happypack/loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      loaders: [<span class="string">&#x27;babel-loader&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意如果 webpack 的版本为 4 的话必须保证 HappyPack 的版本在 5 以上</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="string">&#x27;/.js$/&#x27;</span>,</span><br><span class="line">        include: path.resolve(<span class="string">&quot;src&quot;</span>),</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              workers: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2parallel-webpack"><a class="markdownIt-Anchor" href="#2parallel-webpack"></a> (2)parallel-webpack</h4><p>并发构建的第二种场景是针对与多配置构建。Webpack 的配置文件可以是一个包含多个子配置对象的数组，在执行这类多配置构建时，默认串行执行，而通过 parallel-webpack，就能实现相关配置的并行处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> config1 = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.ignore.config&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> config2 = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.inexclude.config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [config1, config2]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.ignore.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">&#x27;example-ignore&#x27;</span>: <span class="string">&#x27;./src/example-ignore.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.IgnorePlugin(&#123;</span><br><span class="line">      resourceRegExp: <span class="regexp">/^\.\/locale$/</span>,</span><br><span class="line">      contextRegExp: <span class="regexp">/moment$/</span>,</span><br><span class="line">    &#125;),,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.inexclude.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">&#x27;example-inexclude&#x27;</span>: <span class="string">&#x27;./src/example-inexclude.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        include: <span class="regexp">/src|jquery/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-优化提效"><a class="markdownIt-Anchor" href="#二-优化提效"></a> 二、优化提效</h2><p>在文件生成的前的优化阶段可以细分为 12 个子任务，每个任务依次对数据进行一定的处理，并将结果传递给下一任务：</p><img src="/assets/webpack-optimize/01.png"><p>因此，这一阶段的优化也可以分为两个不同的方向：</p><ol><li>针对某些任务，使用效率更高的工具或配置项，从而提升当前任务的工作效率。</li><li>提升特定任务的优化效果，以减少传递给下一任务的数据量，从而提升后续环节的工作效率。</li></ol><h3 id="1-以提升当前任务工作效率为目标的方案"><a class="markdownIt-Anchor" href="#1-以提升当前任务工作效率为目标的方案"></a> 1、以提升当前任务工作效率为目标的方案</h3><p>一般在项目的优化阶段，主要耗时的任务有两个：一个是生成 ChunkAssets，即根据 Chunk 信息生成 Chunk 的产物代码；另一个是优化 Assets，即压缩 Chunk 产物代码。</p><p>第一个任务主要在 Webpack 引擎内部的模块中处理，相对而言优化手段较少，主要集中在利用缓存方面。而在压缩 Chunk 产物代码的过程中会用到一些第三方插件，选择不同的插件，以及插件中的不同配置都可能会对其中的效率产生影响。</p><h4 id="1代码压缩"><a class="markdownIt-Anchor" href="#1代码压缩"></a> (1)代码压缩</h4><p><strong>面向 JS 的压缩工具：</strong></p><p>Webpack 4 中内置了 TerserWebpackPlugin 作为默认的 JS 压缩工具，之前的版本则需要在项目配置中单独引入，早期主要使用的是 UglifyJSWebpackPlugin。这两个 Webpack 插件内部的压缩功能分别基于 Terser 和 UglifyJS。</p><p>从<a href="https://github.com/babel/minify#benchmarks">第三方的测试结果</a>看，两者在压缩效率与质量方面差别不大，但 Terser 整体上略胜一筹。</p><p>Terser 原本是 Fork 自 uglify-es 的项目，其绝大部分的 API 和参数都与 uglify-es 和 uglify-js@3 兼容。因此，两者对应参数的作用与优化方式也基本相同，这里就以 Terser 为例来分析其中的优化方向。</p><p>在作为 Webpack 插件的 TerserWebpackPlugin 中，对执行效率产生影响的配置主要分为 3 个方面：</p><ul><li>Cache 选项：默认开启，使用缓存能够极大程度上提升再次构建时的工作效率。</li><li>Parallel 选项：默认开启，并发选项在大多数情况下能够提升该插件的工作效率，但具体提升的程度则因项目而异。在小型项目中，多进程通信的额外消耗可能会抵消其带来的益处。</li><li>terserOptions 选项：即 Terser 工具中的 <a href="https://github.com/terser/terser#minify-options">minify 选项集合</a>。这些选项是对具体压缩处理过程产生影响的配置项。我们主要来看其中的compress和mangle选项，不同选项的压缩结果如下面的代码所示：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码./src/example-terser-opts.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = <span class="string">&#x27;1234&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(HelloWorld, foo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloWorld()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认配置项compress=&#123;&#125;, mangle=true的压缩后代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">e,t</span>)</span>&#123;!<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(e,<span class="string">&quot;1234&quot;</span>)&#125;()&#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compress=false的压缩后代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">e,r</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> e=<span class="string">&quot;1234&quot;</span>;<span class="built_in">console</span>.log(t,e)&#125;t()&#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mangle=false的压缩代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>,<span class="built_in">exports</span></span>)</span>&#123;!<span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(HelloWorld,<span class="string">&quot;1234&quot;</span>)&#125;()&#125;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compress=false，mangle=false的压缩后代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>,<span class="built_in">exports</span></span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> foo=<span class="string">&quot;1234&quot;</span>;<span class="built_in">console</span>.log(HelloWorld,foo)&#125;HelloWorld()&#125;&#125;);</span><br></pre></td></tr></table></figure><p>从上面的例子中可以看到：</p><ul><li>compress 参数的作用是执行特定的压缩策略，例如省略变量赋值的语句，从而将变量的值直接替换到引入变量的位置上，减小代码体积。而当 compress 参数为 false 时，这类压缩策略不再生效，示例代码压缩后的体积从 1.16KB 增加到 1.2KB，对压缩质量的影响有限。</li><li>mangle 参数的作用是对源代码中的变量与函数名称进行压缩，当参数为 false 时，示例代码压缩后的体积从 1.16KB 增加到 1.84KB，对代码压缩的效果影响非常大。</li></ul><p><strong>面向CSS的压缩工具</strong></p><p>CSS 同样有几种压缩工具可供选择：OptimizeCSSAssetsPlugin（在 Create-React-App 中使用）、OptimizeCSSNanoPlugin（在 VUE-CLI 中使用），以及 CSSMinimizerWebpackPlugin（2020 年 Webpack 社区新发布的 CSS 压缩插件）。</p><p>这三个插件在压缩 CSS 代码功能方面，都默认基于 cssnano 实现，因此在压缩质量方面没有什么差别。</p><p>在压缩效率方面，首先值得一提的是最新发布的 CSSMinimizerWebpackPlugin，它支持缓存和多进程，这是另外两个工具不具备的。而在非缓存的普通压缩过程方面，整体上 3 个工具相差不大，不同的参数结果略有不同，但考虑到只有这一新发布的插件支持缓存和多进程等对项目构建效率影响明显的功能，因此比较推荐使用它。</p><h4 id="2缓存优化"><a class="markdownIt-Anchor" href="#2缓存优化"></a> (2)缓存优化</h4><p>缓存优化我们分别根据编译阶段和缓存优化阶段来分别进行梳理：</p><h5 id="1-编译阶段的缓存优化"><a class="markdownIt-Anchor" href="#1-编译阶段的缓存优化"></a> 1&gt; 编译阶段的缓存优化</h5><p>编译过程的耗时点主要在使用不同加载器（Loader）来编译模块的过程。下面我们来分别看下几个典型 Loader 中的缓存处理：</p><p><strong>Babel-loader</strong></p><p>Babel-loader 是绝大部分项目中会使用到的 JS/JSX/TS 编译器。在 Babel-loader 中，与缓存相关的设置主要有：</p><ul><li>cacheDirectory：默认为 false，即不开启缓存。当值为 true 时开启缓存并使用默认缓存目录（./node_modules/.cache/babel-loader/），也可以指定其他路径值作为缓存目录。</li><li>cacheIdentifier：用于计算缓存标识符。默认使用 Babel 相关依赖包的版本、babelrc 配置文件的内容，以及环境变量等与模块内容一起参与计算缓存标识符。如果上述内容发生变化，即使模块内容不变，也不能命中缓存。</li><li>cacheCompression：默认为 true，将缓存内容压缩为 gz 包以减小缓存目录的体积。在设为 false 的情况下将跳过压缩和解压的过程，从而提升这一阶段的速度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            cacheDirectory: <span class="literal">true</span>,</span><br><span class="line">            sourceMaps: <span class="literal">false</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cache-loader</strong></p><p>在编译过程中利用缓存的第二种方式是使用 Cache-loader。在使用时，需要将 cache-loader 添加到对构建效率影响较大的 Loader（如 babel-loader 等）之前，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.cache.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;cache-loader&#x27;</span>, <span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际编译时我们发现使用 cache-loader 后，比使用 babel-loader 的开启缓存选项后的构建时间更短，主要原因是 babel-loader 中的缓存信息较少，而 cache-loader 中存储的Buffer 形式的数据处理效率更高。下面的示例代码，是 babel-loader 和 cache-loader 入口模块的缓存信息对比：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//babel-loader中的缓存数据</span></span><br><span class="line">&#123;<span class="string">&quot;ast&quot;</span>:<span class="literal">null</span>,<span class="string">&quot;code&quot;</span>:<span class="string">&quot;import _ from &#x27;lodash&#x27;;&quot;</span>,<span class="string">&quot;map&quot;</span>:<span class="literal">null</span>,<span class="string">&quot;metadata&quot;</span>:&#123;&#125;,<span class="string">&quot;sourceType&quot;</span>:<span class="string">&quot;module&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cache-loader中的缓存数据</span></span><br><span class="line">&#123;<span class="string">&quot;remainingRequest&quot;</span>:<span class="string">&quot;...lessons_fe_efficiency/13_cache/node_modules/babel-loader/lib/index.js!.../lessons_fe_efficiency/13_cache/src/example-basic.js&quot;</span>,<span class="string">&quot;dependencies&quot;</span>:[&#123;<span class="string">&quot;path&quot;</span>:<span class="string">&quot;...lessons_fe_efficiency/13_cache/src/example-basic.js&quot;</span>,<span class="string">&quot;mtime&quot;</span>:<span class="number">1599191174705</span>&#125;,&#123;<span class="string">&quot;path&quot;</span>:<span class="string">&quot;...lessons_fe_efficiency/13_cache/node_modules/cache-loader/dist/cjs.js&quot;</span>,<span class="string">&quot;mtime&quot;</span>:<span class="number">499162500000</span>&#125;,&#123;<span class="string">&quot;path&quot;</span>:<span class="string">&quot;.../lessons_fe_efficiency/13_cache/node_modules/babel-loader/lib/index.js&quot;</span>,<span class="string">&quot;mtime&quot;</span>:<span class="number">499162500000</span>&#125;],<span class="string">&quot;contextDependencies&quot;</span>:[],<span class="string">&quot;result&quot;</span>:[&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;Buffer&quot;</span>,<span class="string">&quot;data&quot;</span>:<span class="string">&quot;base64:aW1wb3J0IF8gZnJvbSAnbG9kYXNoJzs=&quot;</span>&#125;,<span class="literal">null</span>]&#125;</span><br></pre></td></tr></table></figure><h5 id="2-优化打包阶段的缓存优化"><a class="markdownIt-Anchor" href="#2-优化打包阶段的缓存优化"></a> 2&gt; 优化打包阶段的缓存优化</h5><p><strong>生成 ChunkAsset 时的缓存优化</strong></p><p>在 Webpack 4 中，生成 ChunkAsset 过程中的缓存优化是受限制的：只有在 watch 模式下，且配置中开启 cache 时（development 模式下自动开启）才能在这一阶段执行缓存的逻辑。这是因为，在 Webpack 4 中，缓存插件是基于内存的，只有在 watch 模式下才能在内存中获取到相应的缓存数据对象，在 Webpack 5 中这一问题得到解决，这个我们在后文中会详细介绍。</p><p><strong>代码压缩时的缓存优化</strong></p><p>前文提到在代码压缩阶段，对于 JS 的压缩，TerserWebpackPlugin 和 UglifyJSPlugin 都是支持缓存设置的。而对于 CSS 的压缩，目前最新发布的 CSSMinimizerWebpackPlugin 支持且默认开启缓存，其他的插件如 OptimizeCSSAssetsPlugin 和 OptimizeCSSNanoPlugin 目前还不支持使用缓存。</p><p>Webpack 4 内置了压缩插件 TerserWebpackPlugin，且默认开启了缓存参数，这里再来看一下 CSSMinimizerWebpackPlugin：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> CssMinimizerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123; <span class="attr">loader</span>: MiniCssExtractPlugin.loader &#125;,</span><br><span class="line">          <span class="string">&#x27;cache-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [<span class="keyword">new</span> CssMinimizerPlugin()],</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-编译阶段的缓存失效"><a class="markdownIt-Anchor" href="#3-编译阶段的缓存失效"></a> 3&gt; 编译阶段的缓存失效</h5><p>编译阶段的执行时间由每个模块的编译时间相加而成。在开启缓存的情况下，代码发生变化的模块将被重新编译，但不影响它所依赖的及依赖它的其他模块，其他模块将继续使用缓存。因此，这一阶段不需要考虑缓存失效扩大化的问题。</p><h5 id="4-优化打包阶段的缓存失效"><a class="markdownIt-Anchor" href="#4-优化打包阶段的缓存失效"></a> 4&gt; 优化打包阶段的缓存失效</h5><p>优化打包阶段的缓存失效问题则需要引起注意。在使用缓存快速构建后，当我们任意修改入口文件的代码后会发现，代码压缩阶段的时间再次变为和初次构建时相近，也就是说，这一 Chunk 的 Terser 插件的缓存完全失效了，之所以会出现这样的结果，是因为，尽管在模块编译阶段每个模块是单独执行编译的，但是当进入到代码压缩环节时，各模块已经被组织到了相关联的 Chunk 中，任何一个模块发生变化都会导致整个 Chunk 的内容发生变化，而使之前保存的缓存失效。</p><p>在知道了失效原因后，对应的优化思路也就显而易见了：尽可能地把那些不变的处理成本高昂的模块打入单独的 Chunk 中。这就涉及了 Webpack 中的分包配置——splitChunks。</p><h5 id="5-其他使用缓存的注意事项"><a class="markdownIt-Anchor" href="#5-其他使用缓存的注意事项"></a> 5&gt; 其他使用缓存的注意事项</h5><p><strong>CI/CD 中的缓存目录问题</strong></p><p>在许多自动化集成的系统中，项目的构建空间会在每次构建执行完毕后，立即回收清理。在这种情况下，默认的项目构建缓存目录（node_mo dules/.cache）将无法留存，导致即使项目中开启了缓存设置，也无法享受缓存的便利性，反而因为需要写入缓存文件而浪费额外的时间。因此，在集成化的平台中构建部署的项目，如果需要使用缓存，则需要根据对应平台的规范，将缓存设置到公共缓存目录下。</p><p><strong>缓存的清理</strong></p><p>缓存的便利性本质在于用磁盘空间换取构建时间。对于一个大量使用缓存的项目，随着时间的流逝，缓存空间会不断增大。这在只有少数项目的个人电脑中还不是非常大的问题，但对于上述多项目的集成环境而言，则需要考虑对缓存区域的定期清理。</p><p><strong>与产物的持久化缓存相区别</strong></p><p>如何在 Webpack 中生成产物的持久化缓存方法（即那些我们比较熟悉的 hash、chunkhash、contenthash），但是它们影响的主要所影响的是项目访问的性能，而对构建的效率没有影响。</p><h3 id="2-已提升后续环节工作效率为目标的方案"><a class="markdownIt-Anchor" href="#2-已提升后续环节工作效率为目标的方案"></a> 2、已提升后续环节工作效率为目标的方案</h3><p>优化阶段的另一类优化方向是通过对本环节的处理减少后续环节处理内容，以便提升后续环节的工作效率。最主要的两个手段分别是 Split Chunks 和 Tree Shaking。</p><h4 id="1split-chunks"><a class="markdownIt-Anchor" href="#1split-chunks"></a> (1)Split Chunks</h4><p>Split Chunks是指在 Chunk 生成之后，将原先以入口点来划分的 Chunks 根据一定的规则（例如异步引入或分离公共依赖等原则），分离出子 Chunk 的过程，详情可见我的博客<a href="https://kyleezhang.github.io/2021/01/03/webpack-codesplitting/">Webpack中的CodeSplitting</a>。</p><p>Split Chunks 有诸多优点，例如有利于缓存命中、有利于运行时的持久化文件缓存等。其中有一类情况能提升后续环节的工作效率，即通过分包来抽离多个入口点引用的公共依赖:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/example-split1.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; slice &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;slice&#x27;</span>, slice([<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/example-split2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; join &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;join&#x27;</span>, join([<span class="number">1</span>], [<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./webpack.split.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">    optimization: &#123;</span><br><span class="line">      splitChunks: &#123;</span><br><span class="line">        chunks: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，有两个入口文件引入了相同的依赖包 lodash，在没有额外设置分包的情况下， lodash 被同时打入到两个产物文件中，在后续的压缩代码阶段耗时 1740ms。而在设置分包规则为 chunks:‘all’ 的情况下，通过分离公共依赖到单独的 Chunk，使得在后续压缩代码阶段，只需要压缩一次 lodash 的依赖包代码，从而减少了压缩时长，总耗时为 1036ms。</p><p>这里起作用的是 Webpack 4 中内置的 SplitChunksPlugin，该插件在 production 模式下默认启用。其默认的分包规则为 <code>chunks: 'async'</code>，作用是分离动态引入的模块 <code>(import('...'))</code>，在处理动态引入的模块时能够自动分离其中的公共依赖。</p><p>但是对于示例中多入口静态引用相同依赖包的情况，则不会处理分包。而设置为 chunks: ‘all’，则能够将所有的依赖情况都进行分包处理，从而减少了重复引入相同模块代码的情况。SplitChunksPlugin 的工作阶段是在optimizeChunks 阶段（Webpack 4 中是在 optimizeChunksAdvanced，在 Webpack 5 中去掉了 basic 和 advanced，合并为 optimizeChunks），而压缩代码是在 optimizeChunkAssets 阶段，从而起到提升后续环节工作效率的作用。</p><h4 id="2tree-shaking"><a class="markdownIt-Anchor" href="#2tree-shaking"></a> (2)Tree Shaking</h4><p>Tree Shaking 是指在构建打包过程中，移除那些引入但未被使用的无效代码（Dead-code elimination）。这种优化手段最早应用于在 Rollup 工具中，而在 Webpack 2 之后的版本中， Webpack 开始内置这一功能。不过 Tree Shaking 的使用需要注意以下几点：</p><ul><li><p>ES6 模块： 首先，只有 ES6 类型的模块才能进行Tree Shaking。因为 ES6 模块的依赖关系是确定的，因此可以进行不依赖运行时的静态分析，而 CommonJS 类型的模块则不能。因此，CommonJS 类型的模块 lodash，在无论哪种引入方式下都不能实现 Tree Shaking，而需要依赖第三方提供的插件（例如 babel-plugin-lodash 等）才能实现动态删除无效代码。而 ES6 风格的模块 lodash-es，则可以进行 Tree Shaking 优化。</p></li><li><p>引入方式：以 default 方式引入的模块，无法被 Tree Shaking；而引入单个导出对象的方式，无论是使用 import * as xxx 的语法，还是 import {xxx} 的语法，都可以进行 Tree Shaking。</p></li><li><p>sideEffects：在 Webpack 4 中，会根据依赖模块 package.json 中的 sideEffects 属性来确认对应的依赖包代码是否会产生副作用。只有 sideEffects 为 false 的依赖包（或不在 sideEffects 对应数组中的文件），才可以实现安全移除未使用代码的功能。在上面的例子中，如果我们查看 lodash-es 的 package.json 文件，可以看到其中包含了 “sideEffects”:false 的描述。此外，在 Webpack 配置的加载器规则和优化配置项中，分别有 rule.sideEffects（默认为 false）和 optimization.sideEffects（默认为 true）选项，前者指代在要处理的模块中是否有副作用，后者指代在优化过程中是否遵循依赖模块的副作用描述。尤其前者，常用于对 CSS 文件模块开启副作用模式，以防止被移除。</p></li><li><p>Babel：在 Babel 7 之前的babel-preset-env中，modules 的默认选项为 ‘commonjs’，因此在使用 babel 处理模块时，即使模块本身是 ES6 风格的，也会在转换过程中，因为被转换而导致无法在后续优化阶段应用 Tree Shaking。而在 Babel 7 之后的 @babel/preset-env 中，modules 选项默认为 ‘auto’，它的含义是对 ES6 风格的模块不做转换（等同于 modules: false），而将其他类型的模块默认转换为 CommonJS 风格。因此我们会看到，后者即使经过 babel 处理，也能应用 Tree Shaking。</p></li></ul><h2 id="三-增量构建"><a class="markdownIt-Anchor" href="#三-增量构建"></a> 三、增量构建</h2><p>虽然前面我们介绍了很多 webpack 构建优化的办法，但是我们发现一个问题却迟迟没有得到解决，那就是尽管只改动了一行代码，但是在执行构建时，要完整执行所有模块的编译、优化和生成产物的处理过程，而不是只需要处理所改动的文件。那么如何实现只编译打包我们所改动的文件呢？</p><p>在开启 devServer的时候，当我们执行 webpack-dev-server 命令后，Webpack 会进行一次初始化的构建，构建完成后启动服务并进入到等待更新的状态。当本地文件有变更时，Webpack 几乎瞬间将变更的文件进行编译，并将编译后的代码内容推送到浏览器端。你会发现，这个文件变更后的处理过程就符合上面所说的只编译打包改动的文件的操作，这也被称为“增量构建”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">&#x27;./dist&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为什么在开发服务模式下可以实现增量构建的效果，而在生产环境下不行呢？</p><h3 id="1-增量构建的影响因素"><a class="markdownIt-Anchor" href="#1-增量构建的影响因素"></a> 1、增量构建的影响因素</h3><h4 id="1watch配置"><a class="markdownIt-Anchor" href="#1watch配置"></a> (1)watch配置</h4><p>在上面的增量构建过程中，第一个想到的就是需要监控文件的变化。显然，只有得知变更的是哪个文件后，才能进行后续的针对性处理。要实现这一点也很简单，在 Webpack 中启用 watch 配置即可，此外在使用 devServer 的情况下，该选项会默认开启。那么，如果在生产模式下开启 watch 配置，是不是再次构建时，就会按增量的方式执行呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  watch: <span class="literal">true</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">&#x27;example_dll&#x27;</span>: <span class="string">&#x27;./src/index.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;[name]-[contenthash:8].js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现在生产模式下开启 watch 配置后，相比初次构建，再次构建所编译的模块数量并未减少，即使只改动了一个文件，也仍然会对所有模块进行编译。因此可以得出结论，在生产环境下只开启 watch 配置后的再次构建并不能实现增量构建。</p><h4 id="2cache配置"><a class="markdownIt-Anchor" href="#2cache配置"></a> (2)cache配置</h4><p>仔细查阅 Webpack 的配置项文档，会在菜单最下方的“其他选项”一栏中找到 cache 选项（需要注意是 Webpack 4 版本的文档，Webpack 5 中这一选项会有大的改变）。这一选项的值有两种类型：布尔值和对象类型。一般情况下默认为false，即不使用缓存，但在开发模式开启 watch 配置的情况下，cache 的默认值变更为true。此外，如果 cache 传值为对象类型，则表示使用该对象来作为缓存对象，这往往用于多个编译器 compiler 的调用情况。</p><p>下面我们就来看一下，在生产模式下，如果watch 和 cache 都为 true，结果会如何？</p><img src="/assets/02.png"><p>正如我们所期望的，再次构建时，在编译模块阶段只对有变化的文件进行了重新编译，实现了增量编译的效果。</p><p>但是美中不足的是，在优化阶段压缩代码时仍然耗费了较多的时间。这一点很容易理解：我们将提及较大的依赖模块和入口模块打入了同一个 Chunk 中，即使修改的模块是单独分离的 bar.js，但它的产物名称的变化仍然需要反映在入口 Chunk 的 runtime 模块中。因此入口 Chunk 也需要跟着重新压缩而无法复用压缩缓存数据。因此我们还可以通过 split chunks 进一步优化构建速度。</p><h3 id="2-增量构建的实现原理"><a class="markdownIt-Anchor" href="#2-增量构建的实现原理"></a> 2、增量构建的实现原理</h3><h4 id="1watch-配置的作用"><a class="markdownIt-Anchor" href="#1watch-配置的作用"></a> (1)watch 配置的作用</h4><p>watch 配置的具体逻辑在 Webpack 的 Watching.js 中。查看源码可以看到，在它构建相关的 _go 方法中，执行的依然是 compiler实例的 compile 方法，这一点与普通构建流程并无区别。真正的区别在于，在 watch 模式下，构建完成后并不自动退出，因此构建上下文的对象（包括前一次构建后的缓存数据对象）都可以保留在内存中，并在 rebuild 时重复使用，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/Watching.js</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="title">_go</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">this</span>.compiler.hooks.watchRun.callAsync(<span class="built_in">this</span>.compiler, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> onCompiled = <span class="function">(<span class="params">err, compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.compiler.compile(onCompiled);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2cache-配置的作用"><a class="markdownIt-Anchor" href="#2cache-配置的作用"></a> (2)cache 配置的作用</h4><p>cache 配置的源码逻辑主要涉及两个文件：CachePlugin.js 和 Compilation.js。其中 CachePlugin.js 的核心作用是将该插件实例的 cache 属性传入 compilation 实例中，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/CachePlugin.js</span></span><br><span class="line">...</span><br><span class="line">compiler.hooks.thisCompilation.tap(<span class="string">&quot;CachePlugin&quot;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">  compilation.cache = cache;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 Compilation.js 中，运用 cache 的地方有两处：</p><ul><li>在编译阶段添加模块时，若命中缓存module，则直接跳过该模块的编译过程（与 cache-loader 等作用于加载器的缓存不同，此处的缓存可直接跳过 Webpack 内置的编译阶段）。</li><li>在创建 Chunk 产物代码阶段，若命中缓存Chunk，则直接跳过该 Chunk 的产物代码生成过程。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/Compilation.js</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="title">addModule</span>(<span class="params"><span class="built_in">module</span>, cacheGroup</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.cache &amp;&amp; <span class="built_in">this</span>.cache[cacheName]) &#123;</span><br><span class="line">    <span class="keyword">const</span> cacheModule = <span class="built_in">this</span>.cache[cacheName];</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//缓存模块存在情况下判断是否需要rebuild</span></span><br><span class="line">    rebuild = ...</span><br><span class="line">    <span class="keyword">if</span> (!rebuild) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//无须rebuild情况下返回cacheModule，并标记build:false</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>: cacheModule,</span><br><span class="line">        issuer: <span class="literal">true</span>,</span><br><span class="line">    build: <span class="literal">false</span>,</span><br><span class="line">    dependencies: <span class="literal">true</span></span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.cache) &#123;</span><br><span class="line">    <span class="built_in">this</span>.cache[cacheName] = <span class="built_in">module</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//无缓存或需要rebuild情况下返回module，并标记build:true</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>: <span class="built_in">module</span>,</span><br><span class="line">  issuer: <span class="literal">true</span>,</span><br><span class="line">  build: <span class="literal">true</span>,</span><br><span class="line">  dependencies: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="title">createChunkAssets</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">this</span>.cache &amp;&amp; <span class="built_in">this</span>.cache[cacheName] &amp;&amp; <span class="built_in">this</span>.cache[cacheName].hash === usedHash ) &#123;</span><br><span class="line">    source = <span class="built_in">this</span>.cache[cacheName].source;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">source = fileManifest.render();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 Webpack 4 中 watch 和 cache 配置的作用原理。通过 Webpack 内置的 cache 插件，将整个构建中相对耗时的两个内部处理环节——编译模块和生成产物，进行缓存的读写处理，从而实现增量构建处理。那么我们是不是就可以在生产环境下直接使用这个方案呢？</p><h3 id="3-生产环境下使用增量构建的阻碍"><a class="markdownIt-Anchor" href="#3-生产环境下使用增量构建的阻碍"></a> 3、生产环境下使用增量构建的阻碍</h3><p>增量构建之所以快是因为将构建所需的数据（项目文件、node_modules 中的文件数据、历史构建后的缓存数据等）都保留在内存中。在 watch 模式下保留着构建使用的 Node 进程，使得下一次构建时可以直接读取内存中的数据。</p><p>而生产环境下的构建通常在集成部署系统中进行。对于管理多项目的构建系统而言，构建过程是任务式的：任务结束后即结束进程并回收系统资源。对于这样的系统而言，增量构建所需的保留进程与长时间占用内存，通常都是不可接受的。</p><p>因此，基于内存的缓存数据注定无法运用到生产环境中。要想在生产环境下提升构建速度，首要条件是将缓存写入到文件系统中。只有将文件系统中的缓存数据持久化，才能脱离对保持进程的依赖，你只需要在每次构建时将缓存数据读取到内存中进行处理即可。事实上，这也是上一课时中讲到的那些 Loader 与插件中的缓存数据的存储方式。</p><p>遗憾的是，Webpack 4 中的 cache 配置只支持基于内存的缓存，并不支持文件系统的缓存。因此，我们只能通过一些支持缓存的第三方处理插件将局部的构建环节应用“增量处理”。</p><p>不过好消息是 Webpack 5 中正式支持基于文件系统的持久化缓存（Persistent Cache）。</p><h2 id="四-webpack-5的优化"><a class="markdownIt-Anchor" href="#四-webpack-5的优化"></a> 四、Webpack 5的优化</h2><p>Webpack 5 中的变化有很多，完整的功能变更清单参见<a href="https://github.com/webpack/changelog-v5">官方文档</a>，这里我们介绍其中与构建效率相关的几个主要功能点：</p><ul><li>Persistent Caching</li><li>Tree Shaking</li><li>Logs</li></ul><h3 id="1-persistent-caching"><a class="markdownIt-Anchor" href="#1-persistent-caching"></a> 1、Persistent Caching</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  cache: &#123;</span><br><span class="line">    type: <span class="string">&#x27;filesystem&#x27;</span>,</span><br><span class="line">    cacheLocation: path.resolve(__dirname, <span class="string">&#x27;.appcache&#x27;</span>),</span><br><span class="line">    buildDependencies: &#123;</span><br><span class="line">      config: [__filename],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1cache基本配置"><a class="markdownIt-Anchor" href="#1cache基本配置"></a> (1)Cache基本配置</h4><p>在 Webpack 4 中，cache 只是单个属性的配置，所对应的赋值为 true 或 false，用来代表是否启用缓存，或者赋值为对象来表示在构建中使用的缓存对象。而在 Webpack 5 中，cache 配置除了原本的 true 和 false 外，还增加了许多子配置项，例如：</p><ul><li>cache.type：缓存类型。值为 'memory’或‘filesystem’，分别代表基于内存的临时缓存，以及基于文件系统的持久化缓存。在选择 filesystem 的情况下，下面介绍的其他属性生效。</li><li>cache.cacheDirectory：缓存目录。默认目录为 node_modules/.cache/webpack。</li><li><a href="http://cache.name">cache.name</a>：缓存名称。同时也是 cacheDirectory 中的子目录命名，默认值为 Webpack 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>f</mi><mi>i</mi><mi>g</mi><mi mathvariant="normal">.</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow><mo>−</mo></mrow><annotation encoding="application/x-tex">{config.name}-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">.</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span></span><span class="mord">−</span></span></span></span>{config.mode}。</li><li>cache.cacheLocation：缓存真正的存放地址。默认使用的是上述两个属性的组合：path.resolve(cache.cacheDirectory, <a href="http://cache.name">cache.name</a>)。该属性在赋值情况下将忽略上面的 cacheDirectory 和 name 属性。</li></ul><h4 id="2单个模块的缓存失效"><a class="markdownIt-Anchor" href="#2单个模块的缓存失效"></a> (2)单个模块的缓存失效</h4><p>Webpack 5 会跟踪每个模块的依赖项：fileDependencies、contextDependencies、missingDependencies。当模块本身或其依赖项发生变更时，Webpack 能找到所有受影响的模块，并重新进行构建处理。</p><p>这里需要注意的是，对于 node_modules 中的第三方依赖包中的模块，出于性能考虑，Webpack 不会跟踪具体模块文件的内容和修改时间，而是依据依赖包里package.json 的 name 和 version 字段来判断模块是否发生变更。因此，单纯修改 node_modules 中的模块内容，在构建时不会触发缓存的失效。</p><h4 id="3全局的缓存失效"><a class="markdownIt-Anchor" href="#3全局的缓存失效"></a> (3)全局的缓存失效</h4><p>当模块代码没有发生变化，但是构建处理过程本身发生变化时（例如升级了 Webpack 版本、修改了配置文件、改变了环境变量等），也可能对构建后的产物代码产生影响。因此在这种情况下不能复用之前缓存的数据，而需要让全局缓存失效，重新构建并生成新的缓存。在 Webpack 5 中共提供了 3 种不同维度的全局缓存失效配置。</p><p><strong>buildDependencies</strong></p><p>第一种配置是cache.buildDependencies，用于指定可能对构建过程产生影响的依赖项。</p><p>它的默认选项是<code>&#123;defaultWebpack: [&quot;webpack/lib&quot;]&#125;</code>。这一选项的含义是，当 node_modules 中的 Webpack 或 Webpack 的依赖项（例如 watchpack 等）发生变化时，当前的构建缓存即失效。</p><p>上述选项是默认内置的，无须写在项目配置文件中。配置文件中的 buildDenpendencies 还支持增加另一种选项 <code>&#123;config: [__filename]&#125;</code>，它的作用是当配置文件内容或配置文件依赖的模块文件发生变化时，当前的构建缓存即失效。</p><p><strong>version</strong></p><p>第二种配置是 cache.version。当配置文件和代码都没有发生变化，但是构建的外部依赖（如环境变量）发生变化时，预期的构建产物代码也可能不同。这时就可以使用 version 配置来防止在外部依赖不同的情况下混用了相同的缓存。例如，可以传入 <code>cache: &#123;version: process.env.NODE_ENV&#125;</code>，达到当不同环境切换时彼此不共用缓存的效果。</p><p><strong>name</strong></p><p>缓存的名称除了作为默认的缓存目录下的子目录名称外，也起到区分缓存数据的作用。例如，可以传入 <code>cache: &#123;name: process.env.NODE_ENV&#125;</code>。这里有两点需要补充说明：</p><p>name 的特殊性：与 version 或 buildDependencies 等配置不同，name 在默认情况下是作为缓存的子目录名称存在的，因此可以利用 name 保留多套缓存。在 name 切换时，若已存在同名称的缓存，则可以复用之前的缓存。与之相比，当其他全局配置发生变化时，会直接将之前的缓存失效，即使切换回之前已缓存过的设置，也会当作无缓存处理。</p><p>当 cacheLocation 配置存在时，将忽略 name 的缓存目录功能，上述多套缓存复用的功能也将失效。</p><p><strong>其他</strong></p><p>除了上述介绍的配置项外，cache 还支持其他属性：managedPath、hashAlgorithm、store、idleTimeout 等，具体功能可以通过官方文档进行查询。</p><p>此外，在 Webpack 4 中，部分插件是默认启用缓存功能的（例如压缩代码的 Terser 插件等），项目在生产环境下构建时，可能无意识地享受缓存带来的效率提升，但是在 Webpack 5 中则不行。无论是否设置 cache 配置，Webpack 5 都将忽略各插件的缓存设置（例如 TerserWebpackPlugin），而由引擎自身提供构建各环节的缓存读写逻辑。因此，项目在迁移到 Webpack 5 时都需要通过上面介绍的 cache 属性来单独配置缓存。</p><p>除此之外通过对 compiler.cache.hook.get 的追踪不难发现：持久化缓存一共影响下面这些环节与内置的插件：</p><ul><li>编译模块：ResolverCachePlugin、Compilation/modules。</li><li>优化模块：FlagDependencyExportsPlugin、ModuleConcatenationPlugin。</li><li>生成代码：Compilation/codeGeneration、Compilation/assets。</li><li>优化产物：TerserWebpackPlugin、RealContentHashPlugin。</li></ul><p>正是通过这样多环节的缓存读写控制，才打造出 Webpack 5 高效的持久化缓存功能。</p><h3 id="2-tree-shaking"><a class="markdownIt-Anchor" href="#2-tree-shaking"></a> 2、Tree Shaking</h3><p>Webpack 5 中的另一项优化体现在 Tree Shaking 功能方面。Webpack 4 中的 Tree Shaking 功能在使用上存在限制：只支持 ES6 类型的模块代码分析，且需要相应的依赖包或需要函数声明为无副作用等。这使得在实际项目构建过程中 Tree Shaking 的优化效果往往不尽如人意。而这一问题在 Webpack 5 中得到了不少改善。</p><h4 id="1nested-tree-shaking"><a class="markdownIt-Anchor" href="#1nested-tree-shaking"></a> (1)Nested Tree Shaking</h4><p>Webpack 5 增加了对嵌套模块的导出跟踪功能，能够找到那些嵌套在最内层而未被使用的模块属性。例如下面的示例代码，在构建后的结果代码中只包含了引用的内部模块的一个属性，而忽略了不被引用的内部模块和中间模块的其他属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/inner-module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="string">&#x27;inner_a&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="string">&#x27;inner_b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .src/nested-module.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> inner <span class="keyword">from</span> <span class="string">&#x27;./inner-module&#x27;</span></span><br><span class="line"><span class="keyword">const</span> nested = <span class="string">&#x27;nested&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; inner, nested &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./src/example-tree-nested.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> nested <span class="keyword">from</span> <span class="string">&#x27;./nested-module&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(nested.inner.a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//./dist/tree-nest.js</span></span><br><span class="line">(<span class="function">()=&gt;</span>&#123;<span class="string">&quot;use strict&quot;</span>;<span class="built_in">console</span>.log(<span class="string">&quot;inner_a&quot;</span>)&#125;)();</span><br></pre></td></tr></table></figure><h4 id="2inner-module-tree-shaking"><a class="markdownIt-Anchor" href="#2inner-module-tree-shaking"></a> (2)Inner Module Tree Shaking</h4><p>除了上面对嵌套引用模块的依赖分析优化外，Webpack 5 中还增加了分析模块中导出项与导入项的依赖关系的功能。通过 optimization.innerGraph（生产环境下默认开启）选项，Webpack 5 可以分析特定类型导出项中对导入项的依赖关系，从而找到更多未被使用的导入模块并加以移除。例如下面的示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//./src/inner-module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="string">&#x27;inner_a&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="string">&#x27;inner_b&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> c = <span class="string">&#x27;inner_c&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//./src/example-tree-nested.js 同上面示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.src/nested-module.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> useB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> inner.b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> usingB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> useB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//./dist/tree-nest.js (默认optimization.innerGraph = true)</span></span><br><span class="line">... <span class="keyword">const</span> t=<span class="string">&quot;inner_a&quot;</span>,n=<span class="string">&quot;inner_b&quot;</span>&#125; ...</span><br><span class="line"></span><br><span class="line"><span class="comment">//./dist/tree-nest.js (optimization.innerGraph = false)</span></span><br><span class="line">... <span class="keyword">const</span> t=<span class="string">&quot;inner_a&quot;</span>&#125; ...</span><br></pre></td></tr></table></figure><p>在 nested-module.js 中新增了导出项 usingB，该导出项间接依赖导入项 inner.b，而这一导出项在入口模块中并未使用。在默认情况下，构建完成后只保留真正被使用的 inner.a。但是如果将优化项 innerGraph 关闭（且需要同时设置 concatenateModules:false），构建后会发现间接引用的导出项没有被移除，该导出项间接引用的 inner.b 也被保留到了产物代码中。</p><h4 id="3commonjs-tree-shaking"><a class="markdownIt-Anchor" href="#3commonjs-tree-shaking"></a> (3)CommonJS Tree Shaking</h4><p>Webpack 5 中增加了对一些 CommonJS 风格模块代码的静态分析功功能：</p><ul><li>支持 <a href="http://exports.xxx">exports.xxx</a>、<a href="http://this.exports.xxx">this.exports.xxx</a>、<a href="http://module.exports.xxx">module.exports.xxx</a> 语法的导出分析。</li><li>支持 object.defineProperty(exports, “xxxx”, …) 语法的导出分析。</li><li>支持 require(‘xxxx’).xxx 语法的导入分析。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//./src/commonjs-module.js</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">11</span></span><br><span class="line"><span class="built_in">this</span>.exports.b = <span class="number">22</span></span><br><span class="line"><span class="built_in">module</span>.exports.c = <span class="number">33</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;module&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//./src/example-tree-commonjs.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./commonjs-module&#x27;</span>).a</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//./dist/tree-commonjs.js</span></span><br><span class="line">()=&gt;&#123;<span class="keyword">var</span> o=&#123;<span class="number">263</span>:<span class="function"><span class="keyword">function</span>(<span class="params">o,r</span>)</span>&#123;r.a=<span class="number">11</span>,<span class="built_in">console</span>.log(<span class="string">&quot;module&quot;</span>)&#125;&#125;...</span><br></pre></td></tr></table></figure><p>可以看到产物代码中只有被引入的属性 a 和 console 语句，而其他两个导出属性 b 和 c 已经在产物中被排除了。</p><h3 id="3-logs"><a class="markdownIt-Anchor" href="#3-logs"></a> 3、Logs</h3><p>第三个要提到的 Webpack 5 的效率优化点是，它增加了许多内部处理过程的日志，可以通过 stats.logging 来访问。下面两张图是使用相同配置 <code>stats: &#123;logging: &quot;verbose&quot;&#125;</code> 的情况下，Webpack 4 和 Webpack 5 构建输出的日志：</p><img src="/assets/webpack-optimize/03.png"><p>可以看到，Webpack 5 构建输出的日志要丰富完整得多。通过这些日志能够很好地反映构建各阶段的处理过程、耗费时间，以及缓存使用的情况。在大多数情况下，它已经能够代替之前人工编写的统计插件功能。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>拉勾教育专栏《前端工程化精讲》</p><p>极客时间《玩转Webpack》</p><p><a href="https://webpack.docschina.org/">webpack官网</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我的博客&lt;a href=&quot;https://kyleezhang.github.io/2020/12/16/webpack-runtime/&quot;&gt;Webpack运行机制&lt;/a&gt;中介绍了 Webpack 的基本工作流程，并介绍了 Compiler 和 Compilation 两个核心模块中的生命周期 Hooks，那么在 Compiler 和 Compilation 的工作流程里，最耗时的阶段分别是哪个呢？&lt;/p&gt;
&lt;p&gt;对于 Compiler 实例而言，耗时最长的显然是生成编译过程实例后的 make 阶段，在这个阶段里，会执行模块编译到优化的完整过程。而对于 Compilation 实例的工作流程来说，不同的项目和配置各有不同，但总体而言，编译模块和后续优化阶段的生成产物并压缩代码的过程都是比较耗时的。&lt;/p&gt;
&lt;p&gt;实际上不同项目的构建，在整个流程的前期初始化阶段与最后的产物生成阶段的构建时间区别不大。真正影响整个构建效率的还是 Compilation 实例的处理过程，这一过程又可分为两个阶段：编译模块和优化处理，下面针对这两个阶段我们分别介绍对应的优化手段。&lt;/p&gt;</summary>
    
    
    
    <category term="前端工程化" scheme="http://kyleezhang.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="webpack" scheme="http://kyleezhang.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>《深入浅出NodeJS》读书笔记（一）</title>
    <link href="http://kyleezhang.com/2021/07/17/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS-01/"/>
    <id>http://kyleezhang.com/2021/07/17/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS-01/</id>
    <published>2021-07-17T16:53:05.000Z</published>
    <updated>2022-06-12T11:24:41.829Z</updated>
    
    <content type="html"><![CDATA[<p>之前在微信读书零零散散看了一些章节，这次特意买了实体书认真全部看一遍，希望能用这篇博客去做一个记录和思考。</p><h2 id="一-node-简介"><a class="markdownIt-Anchor" href="#一-node-简介"></a> 一、Node 简介</h2><h3 id="1-node-的特点"><a class="markdownIt-Anchor" href="#1-node-的特点"></a> 1、Node 的特点</h3><ul><li>异步IO: Node 在底层构建了很多异步 I/O 的 API，从文件的读取到网络请求等，这样的意义在于在 Node 中我们可以从语言层面很自然地进行并行 I/O 操作而无须等待之前的调用结束，在编程模型上可以极大的提升效率。</li><li>事件与回调函数: 事件的编程方式具有轻量级、松耦合、只关注事务点等优势，Node 将前端浏览器中应用广泛且成熟的事件引入后端，配合异步 I/O，将事件点暴露给业务逻辑，极大程度上方便了业务层的编码处理。但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是个主要的问题，Node 为此提供了回调函数，而且纵观下来回调函数也是最好的接受异步调用返回数据的方式。</li><li>单线程: Node 保持了 JavaScript 在浏览器中单线程的特点，而且在 Node 中 JavaScript 与其他线程是无法共享任何状态的，单线程最大的好处是不用在线线程间的状态同步问题，没有频繁切换线程上下文所带来的性能损耗，缺点在于无法利用多核 CPU、错误会引起整个应用退出、CPU 阻塞会导致无法继续调用异步 I/O。</li><li>跨平台: Node 借助 libuv 成功在操作系统与上层 Node 模块之间构建了一层平台层架构，因此借助 libuv 良好的架构设计 Node 实现了跨平台开发。</li></ul><a id="more"></a><h3 id="2-node-的应用场景"><a class="markdownIt-Anchor" href="#2-node-的应用场景"></a> 2、Node 的应用场景</h3><ul><li>Node 本身面向网络的设计且擅长并行 I/O，因此能够有效地组织起更多的硬件资源，并且其基于事件循环强大的处理能力其非常适合 I/O 密集型的应用场景。</li><li>虽然由于 JavaScript 是单线程的原因并不能完美释放多核 CPU 的计算能力，但是由于 V8 实现的深度优化，同时借助 C/C++ 扩展模块或子进程的方式同样适用于处理 CPU 密集型场景</li><li>与遗留系统和平相处</li><li>分布式应用对于可伸缩性的要求非常高，借用 Node 并行 I/O 的能力可加速数据的获取流程。</li></ul><h2 id="二-模块机制"><a class="markdownIt-Anchor" href="#二-模块机制"></a> 二、模块机制</h2><h3 id="1-node-的模块实现"><a class="markdownIt-Anchor" href="#1-node-的模块实现"></a> 1、Node 的模块实现</h3><p>在 Node 中引入模块需要经历如下三步：</p><ul><li>路径分析</li><li>文件定位</li><li>编译执行</li></ul><p>在 Node 中模块分为两类：一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。核心模块在 Node 源码编译的过程中编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就被直接加载进内存中，因此核心模块引入时会忽略掉文件定位与编译执行的两步，而且路径分析的优先级也是最高的，因此其加载速度要比文件模块快很多。文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程。</p><p>详细的模块加载过程如下：</p><h4 id="1优先从缓存加载"><a class="markdownIt-Anchor" href="#1优先从缓存加载"></a> (1)<strong>优先从缓存加载</strong></h4><p>需要注意以下两点：</p><ul><li>浏览器仅仅缓存文件而 Node 缓存的是编译和执行后的对象；</li><li>核心模块的缓存检查会优于文件模块。</li></ul><h4 id="2路径分析"><a class="markdownIt-Anchor" href="#2路径分析"></a> (2)<strong>路径分析</strong></h4><ul><li>核心模块：优先级仅次于缓存加载，加载过程最快</li><li>路径形式的文件模块：require 方法会将路径转换为真实路径，并以真实路径为索引将编译结果存放到缓存中，由于指明了确切的文件位置，因此加载速度仅次于核心模块</li><li>自定义模块：指的是非核心模块也不是路径形式的标识符，是一种特殊的文件模块，由于其在加载过程中 Node 会逐个尝试<strong>模块路径</strong>中的路径，直到找到目标文件为止，因此其加载速度也是最慢的</li></ul><blockquote><p>注：模块路径是 Node 在定位文件模块的具体文件时指定的查找策略，具体表现为一个路径组成的数组，在代码中我们可以通过 module.paths 属性查看。</p></blockquote><h4 id="3文件定位"><a class="markdownIt-Anchor" href="#3文件定位"></a> (3)<strong>文件定位</strong></h4><ul><li>文件扩展名分析：CommonJS 模块规范允许标识符中不包含文件扩展名的情况，这时 Node 会按照 .js、.json、.node 的次序补足扩展名并调用 fs 模块同步阻塞式地判断文件是否存在。</li><li>目录分析和包：Node 会首先在当前目录下查找 package.json 文件并通过 JSON.parse 方法解析，获取到包描述对象后会根据 main 属性指定的文件名进行定位。</li></ul><h4 id="4模块编译"><a class="markdownIt-Anchor" href="#4模块编译"></a> (4)<strong>模块编译</strong></h4><p>在定位到文件后首先是文件的读取，对于不同的文件扩展名其载入方式也有很大的不同：</p><ul><li>.js 文件：通过 fs 模块同步读取文件后编译执行</li><li>.node 文件：C/C++ 编写的扩展文件，通过 dlopen 方法加载最后编译生成的文件</li><li>.json 文件：通过 fs 模块同步读取文件后，用 JSON.parse 解析返回的结果</li><li>其余扩展名文件：都被当作 .js 文件载入</li></ul><blockquote><p>注：通过 require.extensions 属性可知道系统中已有的扩展加载方式，我们也可通过类似 <code>require.extensions['.ext'] = function(module, filename) &#123; ... &#125;</code> 的方式来实现加载，但是官方更支持先将其他语言编译成 js 文件后再加载，这样可避免将繁琐的编译加载等过程引入 Node 的执行过程中。</p></blockquote><p>在读取到文件内容后紧接着就是根据不同的文件扩展名进行对应模块的编译：</p><p><strong>JavaScript 文件</strong>：</p><p>Node 会首先对获取到的 JavaScript 文件内容进行头尾包装，一个正常的 JavaScript 文件会被包装成如下的样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="built_in">module</span>, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就对每个模块文件实现了作用域隔离，包装之后的代码会通过 vm 原生模块的 runInThisContext 方法执行，返回一个具体的 function 对象，然后将当前模块对象的 exports 属性、require 方法、module（模块对象自身）以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个 function 执行，执行后模块的 exports 属性被返回给调用方，这样 exports 属性上的任何属性及方法都可以被外部调用到，但是模块中的其余变量则不可直接被调用。</p><blockquote><p>注：在 CommonJS 中每个文件都是一个模块对象，其具体定义如下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.exports = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">        parent.children.push(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.filename = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于函数入参中传入的 exports 属性本质上是模块对象 module 的 exports 属性的引用，因此如果文件中对 exports 直接赋值会改变 exports 属性的引用，从而导致模块暴露异常。</p><p><strong>Node 文件</strong>：</p><p>.node 文件是在编写了 C/C++ 模块之后编译产生的，所以这里 Node 主要是调用 process.dlopen 方法来加载和执行，在 Node 的架构下 dlopen 方法在 Windows 和 *nix 平台下分别有不同的实现，通过 libuv 层进行了封装。</p><p><strong>JSON 文件</strong>：</p><p>JSON 文件的编译在 Node 中是最简单的，Node 利用 fs 模块同步读取 JSON 文件的内容之后再调用 JSON.parse 方法得到对象，然后将它赋给模块对象的 exports 以供外部调用。</p><h3 id="2-核心模块"><a class="markdownIt-Anchor" href="#2-核心模块"></a> 2、核心模块</h3><p>Node 的核心模块可分为 C/C++ 编写的和 JavaScript 编写的两部分：</p><h4 id="1javascript核心模块的编译过程"><a class="markdownIt-Anchor" href="#1javascript核心模块的编译过程"></a> (1)JavaScript核心模块的编译过程</h4><p>在编译所有的 C/C++ 文件之前，编译程序需要将所有的 JavaScript 模块文件编译为 C/C++ 代码，因此 JavaScript 的完整编译过程如下：</p><p><strong>转存为 C/C++ 代码</strong></p><p>Node 采用了 V8 附带的 <a href="http://js2c.py">js2c.py</a> 工具，将所有内置的 JavaScript 代码转换为 C++ 里的数组并生成 node_natives.h 头文件，这个过程中 JavaScript 以<strong>字符串</strong>的形式存储在 node 的命名空间中，是不可以直接执行的。在启动 Node 进程时，JavaScript 代码直接加载进内存中。在加载的过程中，JavaScript 核心模块经过标识符分析后直接定位到内存中，这比普通的文件模块从磁盘中读取要快得多。</p><p><strong>编译 JavaScript 核心模块</strong></p><p>在引入 JavaScript 核心模块的过程中也同样会经历头尾包装过程，然后再执行并导出 exports 对象，与文件模块有区别的地方主要在于：<strong>获取源代码的方式</strong>和<strong>缓存执行结果的位置</strong>：</p><ul><li>JavaScript 核心模块的源文件主要通过 process.bingding(‘natives’) 从内存的 node 命名空间中取出，而 JavaScript 文件模块主要是通过 fs 模块在磁盘上读取。</li><li>编译成功的 JavaScript 核心模块会缓存到 NativeModule._cache 对象上，文件模块则会缓存到 Module._cache 对象上。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NativeModule</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.filename = id + <span class="string">&#x27;.js&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.exports = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">NativeModule._source = process.binding(<span class="string">&#x27;natives&#x27;</span>);</span><br><span class="line">NativeModule._cache = &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2cc核心模块的编译过程"><a class="markdownIt-Anchor" href="#2cc核心模块的编译过程"></a> (2)C/C++核心模块的编译过程</h4><p>在核心模块中有些模块全部由 C/C++ 编写，有些模块则由 C/C++ 完成核心部分，其他部分则由 JavaScript 实现包装或向外导出，以满足性能的要求。Node 中这种复合模式使得其在开发速度和性能之间找到平衡点。</p><p>通常将那些由 C/C++ 编写的部分统称为<strong>内建模块</strong>，它们通常不被用户直接调用，Node 中的 buffer、cypto、fs 等模块都是部分由 C/C++ 编写的复合模块。</p><p><strong>内建模块的组织形式</strong></p><p>在 Node 中内建模块的内部结构定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_module_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">void</span> *dso_handle;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *filename;</span><br><span class="line">    <span class="keyword">void</span> (*register_func) (v8::Handle&lt;v8::Object&gt; target);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *modname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个内建模块在定义之后都通过 NODE_MODULE 宏将模块定义到 node 命名空间中，模块的具体初始化方法挂在为结构的 register_func 成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_MODULE(modname, regfunc) &#123;</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        NODE_MODULE_EXPORT node::node_module_struct modname ## _module = &#123;</span><br><span class="line">            NODE_STANDARD_MODULE_STUFF,</span><br><span class="line">            regfunc,</span><br><span class="line">            NODE_STRINGIFY(modname)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>node_extensions.h 文件将这些散列的内建模块统一放进了一个叫 node_module_list 的数组中，这些模块有 node_buffer、node_crypto、node_evals…，这些内建模块的取出也非常简单，Node 提供了 get_builin_module() 方法从 node_module_list 数组中取出这些模块。</p><p>内建模块的优势在于：</p><ul><li>它们本身由 C/C++ 编写，性能上优于脚本语言</li><li>在进行文件编译时，它们被编译进二进制文件，一旦 Node 开始执行，它们被直接加载进内存中，无需再次做标识符定位、文件定位、编译等过程，直接就可执行。</li></ul><p><strong>内建模块的导出</strong></p><p>在 Node 的所有模块类型中存在着依赖层级关系：文件模可能会依赖核心模块、核心模块可能会依赖内建模块。通常不推荐文件模块直接调用内建模块而是直接调用核心模块即可，那么内建模块是如何将内部变量或方法导出以供外部 JavaScript 核心模块调用呢？</p><p>Node 在启动时会生成一个全局变量 process，并提供 Binding() 方法来协助加载内建模块，方法内会首先判断 binding_cache 缓存对象中是否存在，如果存在直接读取，如果不存在则先创建一个 exports 空对象，然后调用 get_builtin_module() 方法取出内建模块对象，通过执行 register_func() 填充 exports 对象，最后将 exports 对象按模块名缓存，并返回给调用方完成导出。</p><p>前文提到的 JavaScript 核心文件被转换为 C/C++ 数组存储后便也是通过 process.binding(‘natives’) 取出放置在 NativeModule._source 中的，此方法将通过 <a href="http://js2c.py">js2c.py</a> 工具转换出的字符串数组取出然后重新转换为普通字符串，以对 JavaScript 核心模块进行编译和执行。</p><h4 id="3核心模块的引入流程"><a class="markdownIt-Anchor" href="#3核心模块的引入流程"></a> (3)核心模块的引入流程</h4><p>虽然对于用户而言 require 方法十分简洁但是核心模块的引入往往要经历 C/C++ 层面的内建模块的定义、(JavaScript)核心模块的定义和引入及(JavaScript)文件模块层面的引入，我们以 os 原生模块的引入为例：</p><img src="/assets/深入浅出NodeJS/01.png" width="400"><h4 id="4编写核心模块"><a class="markdownIt-Anchor" href="#4编写核心模块"></a> (4)编写核心模块</h4><p>核心模块中 JavaScript 部分的开发与文件模块几乎相同，遵循 CommonJS 规范，编写核心模块的主要难点在于内建模块：</p><p>编写内建模块的主要分两步：编写头文件和 C/C++ 文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_hello.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NODE_HELLO_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_HELLO_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> node &#123;</span><br><span class="line">    <span class="comment">// 预定义方法</span></span><br><span class="line">    <span class="function">v8::Handle&lt;v8::value&gt; <span class="title">SayHello</span><span class="params">(<span class="keyword">const</span> v8::Arguments&amp; args)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_hello.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node_hello.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;v8.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> node &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line">    <span class="comment">// 实现预定义的方法</span></span><br><span class="line">    <span class="function">Handle&lt;Value&gt; <span class="title">SayHello</span><span class="params">(<span class="keyword">const</span> Arguments&amp; args)</span> </span>&#123;</span><br><span class="line">        HandleScope scope;</span><br><span class="line">        <span class="keyword">return</span> scope.Close(String::New(<span class="string">&quot;Hello world!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给传入的目标对象添加sayHello方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init_Hello</span><span class="params">(Handle&lt;Object&gt; target)</span> </span>&#123;</span><br><span class="line">        target-&gt;Set(String::NewSymbol(<span class="string">&quot;sayHello&quot;</span>), FunctionTemplate::New(SayHello)-&gt;GetFunction());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用NODE_MODULE()将注册方法定义到内存中</span></span><br><span class="line">NODE_MODULE(node_hello, node::Init_Hello)</span><br></pre></td></tr></table></figure><p>编写完成以后还需要让 Node 认为它是内建模块，因此还需要更改 src/node_extensions.h，在 NODE_EXT_LIST_END 前添加 NODE_EXT_LIST_ITEM（如 node_hello）,以将 node_hello 模块添加进 node_module_list 数组中。其次还需要让编写的代码文件编译进执行文件，同时需要更改 Node 项目生成文件 node.gyp，并在 ‘target_name’: ‘node’ 节点的 sources 中添加上新编写的两个文件，然后编译整个 Node 项目。</p><h3 id="3-cc-扩展模块"><a class="markdownIt-Anchor" href="#3-cc-扩展模块"></a> 3、C/C++ 扩展模块</h3><p>C/C++ 扩展模块属于文件模块中的一类，在编译时会首先被预编译为 .node 文件，然后调用 process.dlopen() 方法加载执行。不过在详细展开讲解之前我们先需要了解到 Node 的原生模块一定程度上是可以跨平台的，其前提条件是源代码可以支持在 *nix 和 Windows 上编译，其中 *.nix 下通过 g++/gcc 等编译器编译为动态链接共享对象文件(.so)，在 Windows 下则需要通过 Visual C++ 的编译器编译为动态链接库文件(.dll)，因此 .node 文件在 Windows 下实际上是一个 .dll 文件，在 *.nix 下是一个 .so 文件，dlopen 方法在内部实现时再根据平台进行区分，分别采用加载 .so 和 .dll 的方式。具体过程如下图所示：</p><img src="/assets/深入浅出NodeJS/02.png" width="700"><h4 id="1cc扩展模块的编写"><a class="markdownIt-Anchor" href="#1cc扩展模块的编写"></a> (1)C/C++扩展模块的编写</h4><p>普通的扩展模块与内建模块的区别在于无需将源代码编译进 Nod，而是通过 dlopen 方法动态加载，所以在编写普通扩展模块时无需将源代码写进 node 命名空间，也不需要提供头文件，其写法与内建模块一样，都是将方法挂载在 target 对象上，然后通过 NODE_MODULE 声明即可。</p><h4 id="2cc扩展模块的编译"><a class="markdownIt-Anchor" href="#2cc扩展模块的编译"></a> (2)C/C++扩展模块的编译</h4><p>从 0.8 版本以后 Node 官方采用 GYP 工具生成各个平台下的项目文件，极大程度的减小了开发者的工作量，Node 官方也基于 GYP 工具专门推出了专有的扩展构建工具 node-gyp，因此我们编译 C/C++ 扩展模块只需要编写 .gyp 项目文件 binding.gyp 并在终端分别执行命令 <code>node-gyp configure</code> 和 <code>node-gyp build</code> 即可。编译过程会根据平台不同分别编译处理并生成对应的 .node 文件。</p><h4 id="3cc扩展模块的加载"><a class="markdownIt-Anchor" href="#3cc扩展模块的加载"></a> (3)C/C++扩展模块的加载</h4><p>在编译得到 .node 文件后我们在代码中只需要通过 require() 方法调用即可，不过这个具体的调用过程却远比这个方法复杂，具体如下图所示：</p><img src="/assets/深入浅出NodeJS/03.png" width="500"><p>如上图所示加载 .node 文件实际上经历了两个步骤，第一个步骤是调用 uv_dlopen() 方法去打开动态链接库，第二个步骤是调用 uv_dlsym() 方法找到动态链接库中通过 NODE_MODULE 宏定义的方法地址，这两个过程都是通过 libuv 库进行封装的：在 *nix 平台下实际上调用的是 dlfcn.h 头文件中定义的 dlopen() 和 dlsym() 两个方法，在 Windows 平台下则是通过 LoadLibraryExW()和 GetProcAddress() 这两个方法实现的，他们分别加载 .so 和 .dll 文件。</p><p>由于编写模块时通过 NODE_MODULE 将模块定义为 node_module_struct 结构，所以在获取函数地址之后，将它映射为 node_module_struct 结构几乎是无缝对接的，接下来就是将传入的 exports 对象作为入参传入，将 C++ 中定义的方法挂载在 exports 对象上，然后调用者就可以轻松调用了。</p><h2 id="三-异步-io"><a class="markdownIt-Anchor" href="#三-异步-io"></a> 三、异步 I/O</h2><h3 id="1-异步-io-与非阻塞-io"><a class="markdownIt-Anchor" href="#1-异步-io-与非阻塞-io"></a> 1、异步 I/O 与非阻塞 I/O</h3><p>从实际效果而言异步和非阻塞都达到了我们并行 I/O 的目的，但是从计算机内核 I/O 而言，异步/同步和阻塞/非阻塞实际上是两回事。操作系统内核对于 I/O 只有两种方式：阻塞与非阻塞。在调用阻塞 I/O 时，应用程序需要等待 I/O 完成才返回结果，而非阻塞 I/O 调用之后会立即返回。</p><blockquote><p>注：操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件 I/O 操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行 I/O 调用，需要先打开文件描述符，然后根据文件描述符去实现文件的数据读写。此处阻塞 I/O 与非阻塞 I/O 的区别在于阻塞 I/O 完成了整个获取数据的过程，而非阻塞 I/O 则不带数据直接返回，要获取数据，还需要通过文件描述符再次获取。</p></blockquote><p>非阻塞 I/O 返回之后 CPU 的时间片可以用来处理其他事务，对于性能的提升是很明显的，但是非阻塞 I/O 依然存在一个问题：由于完整的 I/O 没有完成，立即返回的并不是业务层期望的数据，而仅是当前调用的状态，我们期望的异步 I/O 应该是应用程序发起阻塞调用或非阻塞调用，无需通过遍历或时间唤醒等方式轮询，可以直接处理下一个任务，只需要在 I/O 完成以后通过信号或回调将数据传递给应用程序即可，为了达到这样的目标 Node 主要借助了多线程：</p><p>让部分线程通过非阻塞 I/O 和轮询技术来完成数据读取，让另一个线程进行计算处理，通过进程之间的通信将 I/O 得到的数据进行传递，这样就轻松实现了异步 I/O。</p><p>具体异步 I/O 模型 Node 在 libuv 针对不同平台进行了不同的封装，Node 最初在 *nix 平台下采用了 libeio 配合 libev 实现了异步 I/O，在 Node v0.9.3 中自行实现了线程池来实现异步 I/O。而在 Windows 平台下直接采用了 IOCP 异步 I/O 模型实现，具体如图所示：</p><img src="/assets/深入浅出NodeJS/04.png" width="500"><h3 id="2-node-的异步-io"><a class="markdownIt-Anchor" href="#2-node-的异步-io"></a> 2、Node 的异步 I/O</h3><p>Node 是如何实现异步 I/O 的？核心就是 Node 的自身执行模型——事件循环，事件循环是一个典型的<strong>生产者/消费者模型</strong>，异步 I/O、网络请求等则是事件的生产者，源源不断的为 Node 提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则是从观察者那里不断取出事件并处理。</p><p>在 windows 下这个循环基于 IOCP 创建，而在 *nix 下则基于多线程创建。</p><h4 id="1请求对象"><a class="markdownIt-Anchor" href="#1请求对象"></a> (1)请求对象</h4><p>对于一般的（非异步）回调函数，函数由我们自行调用，对于 Node 中的异步 I/O 调用而言，回调函数却不由开发者来调用。那么从我们发出调用后到回调函数被执行，中间发生了什么呢？</p><p>事实上，从 Javascript 发起调用到内核执行完 I/O 操作的过渡过程中，存在一种中间产物，它叫做<strong>请求对象</strong>。请求对象是异步 I/O 过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及 I/O 操作完毕后的回调处理。</p><p>我们以 fs.open 方法为例：</p><img src="/assets/深入浅出NodeJS/05.png" width="600"><p>从上图我们可以看到虽然 libuv 有两个平台的实现，但是实质上还是调用了 uv_fs_open() 方法。在 uv_fs_open() 的调用过程中，我们创建了一个 FSReqWrap 请求对象，从 JavaScript 层传入的参数和当前方法都被封装在这个请求对象中，其中我们最为关注的回调函数则被设置在这个对象的 oncomplete_sym 属性上：</p><p>req_wrap -&gt; object -&gt; Set(oncomplete_sym, callback)</p><p>对象包装完毕后，在 Windows 下则调用 QueueUserWorkItem() 方法将这个 FSReqWrap 对象推入线程池中等待执行。</p><p>至此，JavaScript 调用立即返回，由 JavaScript 层面发起的异步调用的第一阶段就此结束。JavaScript 线程可以继续执行当前任务的后续操作。当前的 I/O 操作在线程池中等待执行，不管是否阻塞 I/O，都不会影响到 JavaScript 线程的后续执行，如此就达到了异步的目的。</p><h4 id="2执行回调"><a class="markdownIt-Anchor" href="#2执行回调"></a> (2)执行回调</h4><p>组装好请求对象、送入 I/O 线程池等待执行，实际上只完成了异步 I/O 的第一部分，回调通知是第二部分。线程池中 I/O 操作调用完毕之后，会将获取的结果储存在 req -&gt; result 属性上，然后调用 PostQueuedCompletionStatus() 通知 IOCP，告知对象操作已经完成。</p><p>PostQueuedCompletionStatus() 方法的作用是向 IOCP 提交执行状态，并将线程回归线程池，通过 PostQueuedCompletionStatus() 方法提交的状态可通过 GetQueuedCompletionStatus() 提取。</p><p>在这个过程中其实还动用了事件循环的 I/O 观察者，在每次 Tick 的执行中，它会调用 IOCP 相关的 GetQueuedCompletionStatus() 方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当作事件处理。</p><p>I/O 观察者回调函数的行为就是取出请求对象的 result 属性做为参数，取出 oncomplete_sym 属性做为方法，然后调用执行，以此达到调用 JavaScript 中传入的回调函数的目的。</p><p>至此整个异步 I/O 流程完全结束，流程如图所示：</p><img src="/assets/深入浅出NodeJS/06.png" width="700"><h3 id="3-非-io-的异步api"><a class="markdownIt-Anchor" href="#3-非-io-的异步api"></a> 3、非 I/O 的异步API</h3><h4 id="1定时器"><a class="markdownIt-Anchor" href="#1定时器"></a> (1)定时器</h4><p>setTimeout() 和 setInterval() 分别用于单次和多次定时执行任务，它们的实现原理与异步 I/O 比较类似，只是不需要异步 I/O 线程池的参与。调用 setTimeout() 或者 setInterval() 创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次 Tick 执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过就会形成一个事件，它的回调函数将立即执行。</p><p>setTimeout() 的具体执行流程如下图所示，stInterval() 与之相同，区别是后者是重复性的检测与执行。</p><img src="/assets/深入浅出NodeJS/07.png" width="700"><h4 id="2processnexttick"><a class="markdownIt-Anchor" href="#2processnexttick"></a> (2)process.nextTick()</h4><p>在了解 process.nextTick() 之前我们为了立即异步执行一个任务往往要通过如下代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>但是由于时间循环自身的原因定时器的精度不够，而且采用定时器需要动用红黑树，创建定时器和迭代等操作，较为浪费性能，而 process.nextTick() 相对要较为轻量，每次调用 process.nextTick() 只会将回调函数放入队列中，在下一轮 Tick 时取出执行。定时器中采用红黑树的操作时间复杂度为 O(lg(n))，nextTick() 的时间复杂度为 O(1)。</p><h4 id="3setimmediate"><a class="markdownIt-Anchor" href="#3setimmediate"></a> (3)setImmediate</h4><p>setImmediate() 与 process.nextTick() 类似，都是将回调函数延迟执行，但是 process.nextTick() 中的回调函数的优先级要高于 setmmediate()，这是因为 process.nextTick() 属于 idle 观察者，setImmediate() 属于 check 观察者。在每一轮循环检查中，idle 检查者先于 I/O 观察者，I/O 观察者先于 check 观察者。</p><p>而且在具体的实现中，process.nextTick() 的回调函数保存在一个数组中，而 setImmediate() 则是保存在链表中，在行为上，process.nextTick() 在每轮循环中会将数组中的回调函数全部执行完，而 setImmediate() 在每轮循环中执行链表中的一个回调函数。具体如下示例所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick延迟执行1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick延迟执行2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate延迟执行1&#x27;</span>)</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;强势插入&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate延迟执行2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;正常执行&#x27;</span>)</span><br></pre></td></tr></table></figure><p>其执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正常执行</span><br><span class="line">nextTick延迟执行1</span><br><span class="line">nextTick延迟执行2</span><br><span class="line">setImmediate延迟执行1</span><br><span class="line">强势插入</span><br><span class="line">setImmediate延迟执行2</span><br></pre></td></tr></table></figure><p>这样设计可以保证每轮循环可以较快的执行结束，防止 CPU 占用过多而阻塞后续 I/O 调用的情况。</p><h2 id="四-异步编程"><a class="markdownIt-Anchor" href="#四-异步编程"></a> 四、异步编程</h2><h3 id="1-异步编程解决方案"><a class="markdownIt-Anchor" href="#1-异步编程解决方案"></a> 1、异步编程解决方案</h3><p>利用事件循环的方式 Node 实现了异步模型，使得异步编程首次大规模出现在业务层面，目前异步编程的主要解决方案有如下三种：</p><ul><li>事件发布/订阅模式</li><li>Promise/Defered 模式</li><li>流程控制库</li></ul><h4 id="1事件发布订阅模式"><a class="markdownIt-Anchor" href="#1事件发布订阅模式"></a> (1)事件发布/订阅模式</h4><p>事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式。</p><p>Node 自身提供的 events 模块是发布/订阅的一个简单实现，发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又被称为事件侦听器。通过 emit() 发布事件后消息会立即传递给当前事件的所有侦听器执行。侦听器可以很灵活的添加删除，使得事件和具体的处理逻辑之间可以很轻松地关联和解耦。</p><p>值得注意的是 Node 对事件发布/订阅的机制做了一些额外的处理，这大多是基于健壮性考虑的：</p><ul><li>如果对一个事件添加超过 10 个侦听器将会得到一个警告，这是因为设计者任务侦听器太多容易造成内存泄漏，通过调用 emitter.setMaxListeners(0) 可以取消这个限制。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用 CPU 的场景。</li><li>为了处理异常，EventEmitter 对象对 error 事件进行了特殊对待。如果运行期间错误触发了 error 事件，EventEmitter 会检查是否有对 error 事件添加过侦听器。如果添加了，这个错误会交由侦听器处理，否则这个错误会做为异常抛出。如果外部没有捕获这个异常将会引起线程退出。</li></ul><p>Node 中对于事件发布/订阅模式的使用主要有如下几种：</p><p><strong>1.继承events模块</strong></p><p>实现一个继承 EventEmitter 的类是十分简单的，Node 在 util 模块封装了继承的方法可以很便利的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    events.EventEmitter.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Stream, events.EventEmitter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stream = <span class="keyword">new</span> Stream()</span><br><span class="line">stream.on(<span class="string">&#x27;hi&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">stream.emit(<span class="string">&#x27;hi&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>2.利用事件队列解决雪崩问题</strong></p><p>在事件发布/订阅模式中，通常也有一个 once() 方法，通过它添加的侦听器只能执行一次，在执行之后就会将它与事件的关联移除，这个特性可以帮助我们过滤一些重复性的事件响应，比如雪崩问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"><span class="keyword">var</span> status = <span class="string">&quot;ready&quot;</span></span><br><span class="line"><span class="keyword">var</span> select = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    proxy.once(<span class="string">&quot;selected&quot;</span>, callback);</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="string">&quot;ready&quot;</span>) &#123;</span><br><span class="line">        status = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">        db.select(<span class="string">&quot;SQL&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">            proxy.emit(<span class="string">&quot;selected&quot;</span>, results);</span><br><span class="line">            status = <span class="string">&quot;ready&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.多异步之间的协作方案</strong></p><p>一般而言事件发布/订阅模式中事件与侦听器的关系是一对多，但在异步编程中也会出现事件与侦听器的关系是多对一的情况，由于多个异步场景中回调函数的执行并不能保证顺序，且回调函数之间互相没有任何交集，所以需要借助一个第三方函数和第三方变量来处理异步协作的结果，通常我们把这个用于检测次数的变量叫做<strong>哨兵变量</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> results = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    results[key] = value;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count === <span class="number">3</span>) &#123;</span><br><span class="line">        render(results);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.readFile(template_path, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">    done(<span class="string">&quot;template&quot;</span>, template)</span><br><span class="line">&#125;)</span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    done(<span class="string">&quot;data&quot;</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line">l10n.get(<span class="function"><span class="keyword">function</span> (<span class="params">err, resource</span>) </span>&#123;</span><br><span class="line">    done(<span class="string">&quot;resource&quot;</span>, resource)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>除了这种方式之外我们还可以通过 <a href="https://github.com/JacksonTian/eventproxy">EventProxy</a> 中的 all() 方法来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> EventProxy();</span><br><span class="line"></span><br><span class="line">proxy.all(<span class="string">&quot;template&quot;</span>, <span class="string">&quot;data&quot;</span>, <span class="string">&quot;resources&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">template, data, resource</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(template_path, <span class="string">&quot;utf-8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, template</span>) </span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">&quot;template&quot;</span>, template)</span><br><span class="line">&#125;);</span><br><span class="line">db.query(sql, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">&quot;data&quot;</span>, data)</span><br><span class="line">&#125;)</span><br><span class="line">l10n.get(<span class="function"><span class="keyword">function</span> (<span class="params">err, resources</span>) </span>&#123;</span><br><span class="line">    proxy.emit(<span class="string">&quot;resources&quot;</span>, resources)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2promisedeferred模式"><a class="markdownIt-Anchor" href="#2promisedeferred模式"></a> (2)Promise/Deferred模式</h4><p><strong>1.Promise/A</strong></p><p>Promise/Deferred 模式其实包含两部分，即 Promise 和 Defered，Deferred 主要是用于内部，用于维护异步模型的状态，Promise 则用于外部，通过 then() 方法暴露给外部以添加自定义逻辑，整体关系如图所示：</p><img src="/assets/深入浅出NodeJS/08.png" width="700"><p>我们根据规范可以实现一个简易版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="keyword">const</span> &#123; EventEmitter &#125; = <span class="built_in">require</span>(<span class="string">&quot;events&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">&quot;util&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    EventEmitter.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(<span class="built_in">Promise</span>, EventEmitter)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">fulfilledHandler, errorHandler, progresssHandler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fulfilledHandler === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.once(<span class="string">&#x27;success&#x27;</span>, fulfilledHandler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> errorHandler === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.once(<span class="string">&#x27;error&#x27;</span>, errorHandler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> progresssHandler === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.once(<span class="string">&#x27;progress&#x27;</span>, progresssHandler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Deferred</span></span><br><span class="line"><span class="keyword">var</span> Deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&quot;unfilled&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line">&#125;</span><br><span class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.promise.emit(<span class="string">&#x27;success&#x27;</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&#x27;failed&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.promise.emit(<span class="string">&#x27;error&#x27;</span>, obj);</span><br><span class="line">&#125;</span><br><span class="line">Deferred.prototype.progress = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&#x27;progress&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.promise.emit(<span class="string">&#x27;progress&#x27;</span>, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Promise/Deferred 模式我们可以很轻松的完成对响应对象的封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promisify = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deferred = <span class="keyword">new</span> Defferred();</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        result += chunk;</span><br><span class="line">        deferred.progress(chunk);</span><br><span class="line">    &#125;)</span><br><span class="line">    res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        deferred.resolve(result)</span><br><span class="line">    &#125;)</span><br><span class="line">    res.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        deferred.reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意这里返回 deferred.promise 的目的是为了不让外部程序调用 resolve() 和 reject() 方法，更改状态的行为交由定义者控制。这样我们就可以通过下述方法实现对响应对象的调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">promisify(res).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>2.Promise中的多异步协作</strong></p><p>在 promise 的介绍中说过主要解决的是单个异步中存在的问题，那么当我们需要处理多个异步调用时又该如何处理呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Deferred.prototype.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = promises.length;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> results = [];</span><br><span class="line">    promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise, i</span>) </span>&#123;</span><br><span class="line">        promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            count--;</span><br><span class="line">            results[i] = data;</span><br><span class="line">            <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">                that.resolve(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            that.reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过 all() 方法抽象多个异步操作，只有所有的异步操作成功这个异步操作才算成功。</p><h4 id="3流程控制库"><a class="markdownIt-Anchor" href="#3流程控制库"></a> (3)流程控制库</h4><p><strong>1.尾触发与Next</strong></p><p>除了事件和 Promise 外还有一类方法是需要手工调用才能继续执行后续调用的，我们将此类方法叫做尾触发，常见的关键词是next。尾触发目前应用得最多的地方是中间件，尾触发十分适合处理网络请求的场景，将复杂的逻辑拆解成简洁、单一的处理单元，逐层次的处理请求对象和响应对象。</p><p>但是需要注意的是虽然中间件这种尾触发模式并不要求每个中间件方法都是异步的，但是如果每个步骤都采用异步完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者 Promise 完成的。</p><p><strong>2.async</strong></p><p><a href="https://www.npmjs.com/package/async">async</a>是最知名的流程控制模块，下面是它的几种典型用法：</p><ul><li>异步的串行执行：<code>async.series([func1, func2, ...], callback)</code></li><li>异步的并行执行：<code>async.parallel([func1, func2, ...], callback)</code></li><li>异步调用的依赖处理：<code>async.waterfall([func1, func2, ...], callback)</code></li><li>自动依赖处理：<code>async.auto(depsConfig)</code></li></ul><p>除此之外还有第三方库 <a href="https://www.npmjs.com/package/step">step</a> 和 <a href="https://www.npmjs.com/package/wind">wind</a>，此处不再详细介绍，可以查看官方文档资料。</p><h3 id="2-异步并发控制"><a class="markdownIt-Anchor" href="#2-异步并发控制"></a> 2、异步并发控制</h3><p>在 Node 中我们可以很轻易的利用异步发起并行调用，但是如果并发量过大我们的下层服务器会吃不消，如果是对文件系统进行大量并发调用，操作系统的文件描述符将会被瞬间用光。因此我们需要对异步并发做一定的控制，下面介绍两种解决方案：</p><h4 id="1bagpipe的解决方案"><a class="markdownIt-Anchor" href="#1bagpipe的解决方案"></a> (1)bagpipe的解决方案</h4><ul><li>通过一个队列来控制并发量</li><li>如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行</li><li>如果活跃度调用达到限定值，调用暂时存放在队列中。</li><li>每个异步调用结束时，从队列中取出新的异步调用执行</li></ul><h4 id="2async的解决方案"><a class="markdownIt-Anchor" href="#2async的解决方案"></a> (2)async的解决方案</h4><p>async 提供了 parallelLimit() 方法来处理异步调用的限制，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallelLimit([</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">&#x27;file1.text&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        fs.readFile(<span class="string">&#x27;file2.text&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, callback);</span><br><span class="line">    &#125;,</span><br><span class="line">], <span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>parallelLimit() 方法提供了一个用于限制并发数量的参数，使得任务只能同时并发一定数量，而不是无限制并发。</p><h2 id="五-内存控制"><a class="markdownIt-Anchor" href="#五-内存控制"></a> 五、内存控制</h2><h3 id="1-v8的垃圾回收机制与内存限制"><a class="markdownIt-Anchor" href="#1-v8的垃圾回收机制与内存限制"></a> 1、V8的垃圾回收机制与内存限制</h3><h4 id="1v8的内存限制"><a class="markdownIt-Anchor" href="#1v8的内存限制"></a> (1)V8的内存限制</h4><p>在一般的后端开发语言中在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（64位系统下约为1.4GB，32位系统下约为0.7GB），在这样的限制下 Node 无法直接操作大内存对象，而这个限制的根本原因在于 V8 的内存管理机制。</p><p>在 V8 中所有的 JavaScript 对象都是通过堆来进行分配的，当我们的代码中声明变量并赋值所使用的对象时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制为止，V8 限制堆的大小的主要原因是 V8 的垃圾回收机制的限制，按官方的说法，以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量的垃圾回收甚至要一秒以上，这样的时间花销是无法接受的。</p><p>V8 也提供了选项让我们使用更多内存，Node 在启动时可以传递 --max-old-space-size 或 --max-new-space-size 来调整内存限制的大小，示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --max-old-space-size=1700 test.js // 单位是MB</span><br><span class="line">node --max-new-space-size=1024 test.js // 单位是KB</span><br></pre></td></tr></table></figure><h4 id="2v8的垃圾回收机制"><a class="markdownIt-Anchor" href="#2v8的垃圾回收机制"></a> (2)V8的垃圾回收机制</h4><p>V8 的垃圾回收策略主要是基于分代式垃圾回收机制。</p><p><strong>V8的内存分代</strong></p><p>在 V8 中主要讲内存分为新生代与老生代两代，新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，具体如下图所示：</p><img src="/assets/深入浅出NodeJS/09.png" width="600"><p>v8 堆的整体大小就是新生代所占用的内存空间加上老生代的内存空间，前面提到的 --max-old-space-size 和 --max-new-space-size 也分别是用来设置老生代和新生代内存空间的大小，不过比较遗憾的是这两个值需要在启动时指定。这意味着 V8 使用的内存没有办法根据使用情况自动扩容，当内存内存分配过程中超过极限值时就会引起进程出错。</p><p><strong>Scavenge算法</strong></p><p>在分代的基础上，新生代中的对象主要通过 Scavenge 算法进行垃圾回收，在 Scavenage 的具体实现中主要采用了 Cheney 算法，Cheney 是一种采用复制的方式实现的垃圾回收算法，它将堆内存一分为二，每一部分空间都称为 semispace。在这两个 semispace 空间中只有一个处于使用中，另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的 semispace 被称为 To 空间。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时会检查 From 空间中的存活对象并将其复制到 To 空间中，然后将 From 空间中非存活对象占用的空间进行释放，完成复制后，From 空间和 To 空间的角色发生对换。简而言之，垃圾回收的过程，就是通过将存活对象在两个 semispace 空间之间来回复制的过程。</p><p>Scavenge 的缺点是只能使用堆内存的一半，但是由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现，因此 Scavenge 算法是典型的牺牲空间换取时间的算法。其不适合大规模的应用到所有的垃圾回收中，只适用于新生代对象周期较短的场景。</p><p>在单纯的 Scavenge 过程中，From 空间中的存活对象会被复制到 To 空间中去，然后对 From 空间和 To 空间进行角色互换（又称翻转）。但在分代式垃圾回收的前提下 From 空间中的存活对象在复制到 To 空间之前需要进行检查。在一定条件下需要将存活周期长的对象移动到老生代中，也就是完成对象晋升。</p><p>对象晋升的条件有两个，一个是对象是否经历过 Scavenge 回收，一个是 To 空间的内存占比超过限制。</p><img src="/assets/深入浅出NodeJS/10.png" width="600"><p>设置 25% 这个限制值的原因是当这次 Scavenge 回收完成后这个 To 空间将变成 From 空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。对象晋升后将在老生代空间中作为存活周期较长的对象来对待，接受新的回收算法的处理。</p><p><strong>Mark-Sweep &amp; Mark-Compact</strong></p><p>对于老生代中的对象，由于存活对象占较大比重，再采用 Scavenge 的方式会存在两个问题：一个是存活对象较多，复制存活对象的效率将会很低，另一个问题依然是浪费一半空间，因此老生代中主要采用了 Mark-Sweep 和 Mark-Compact 相结合的方式来进行垃圾回收。</p><p>Mark-Sweep 是标记清除的意思，它分为标记和清除两个阶段。在标记阶段 Mark-Sweep 会遍历堆中的所有对象，并标记活着的对象，而在随后的清除阶段只清除没有被标记的对象。Mark-Sweep 的最大问题在于进行了一次标记清除回收后内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，容易出现要存储大对象但是所有碎片空间都大小不足的情景，因此又引入了 Mark-Compact 算法。</p><p>Mark-Compact 是标记整理的意思，是在 Mark-Sweep 的基础上演变而来的。它们的差别在于对象被标记为死亡后，在整理的过程中，将活的对象往一侧移动，移动完成后直接清理掉边界外的内存。</p><p>3 种算法的简单对比如下：</p><table><thead><tr><th>回收算法</th><th style="text-align:center">Mark-Sweep</th><th style="text-align:center">Mark-Compact</th><th style="text-align:center">Scavenge</th></tr></thead><tbody><tr><td>速度</td><td style="text-align:center">中等</td><td style="text-align:center">最慢</td><td style="text-align:center">最快</td></tr><tr><td>空间开销</td><td style="text-align:center">少（有碎片）</td><td style="text-align:center">少（无碎片）</td><td style="text-align:center">双倍空间（无碎片）</td></tr><tr><td>是否移动对象</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr></tbody></table><p>从图中可以看出在 Mark-Sweep 和 Mark-Compact 之间由于 Mark-Compact 需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8 主要使用 Mark-Sweep，在空间不足以对从新生代晋升过来的对象进行分配时才使用 Mark-Compact。</p><h3 id="2-内存指标"><a class="markdownIt-Anchor" href="#2-内存指标"></a> 2、内存指标</h3><h4 id="1查看内存使用情况"><a class="markdownIt-Anchor" href="#1查看内存使用情况"></a> (1)查看内存使用情况</h4><p><strong>查看进程的内存占用</strong></p><p>调用 process.memoryUsage() 可以查看内存使用情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage()</span><br><span class="line">&#123;</span><br><span class="line">    rss: 13852672,</span><br><span class="line">    heapTotal: 6131200,</span><br><span class="line">    heapUsed: 2757120</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 rss 是 resident set size 的缩写，即进程的常驻内存部分。进程中的内存总共有几部分，一部分是 rss，其余部分在交换区（swap）或者文件系统（filesystem）中。</p><p>除了 rss 外，heapTotal 和 heapUsed 对应的是 V8 的堆内存信息。heapTotal 是堆中总共申请的内存量，heapUsed 是目前堆中使用中的内存量，这三个值的单位都是字节。</p><p><strong>查看系统的内存占用</strong></p><p>os 模块提供了 totalmem() 和 freemem() 这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; os.totalmem()</span><br><span class="line">8589934592</span><br><span class="line">&gt; os.freemem()</span><br><span class="line">4527833088</span><br></pre></td></tr></table></figure><h4 id="2堆外内存"><a class="markdownIt-Anchor" href="#2堆外内存"></a> (2)堆外内存</h4><p>通过 process.memoryUsage() 的结果可以看出堆内的内存用量总是小于进程内的常驻内存用量，这意味着 Node 中的内存使用并非都是通过 V8 进行分配的，我们将那些不是通过 V8 分配的内存称为<strong>堆外内存</strong>。</p><p>Node 并不同于浏览器的应用场景。在浏览器中 JavaScript 直接处理字符串即可满足绝大多数的业务需求，而 Node 则需要处理网络流和文件 I/O 流，因此 Node 中的 Buffer 对象不同于其他对象，它不经过 V8 的内存分配机制，所以也不会有堆内存的大小限制。</p><h3 id="3-内存泄漏"><a class="markdownIt-Anchor" href="#3-内存泄漏"></a> 3、内存泄漏</h3><p>通常，造成内存泄漏的原因有如下三个：</p><ul><li>缓存</li><li>队列消费不及时</li><li>作用域未释放</li></ul><h4 id="1慎将内存当作缓存"><a class="markdownIt-Anchor" href="#1慎将内存当作缓存"></a> (1)慎将内存当作缓存</h4><p>JavaScript 开发者通常喜欢用对象的键值对来缓存东西，但这与严格意义上的缓存又有着区别，严格意义上的有着完善的过期策略，而普通的键值对没有。使用键值对缓存对象的好处在于极其容易创建但是开发者往往容易忽略掉及时清除缓存对象。因此我们需要使用一些方法限定缓存对象的大小，防止内存无限制增长。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limitMap = <span class="function"><span class="keyword">function</span> (<span class="params">limit</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.limit = limit || <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">this</span>.map = &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>,keys = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"></span><br><span class="line">LimitMap.prototype.set = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> map = <span class="built_in">this</span>.map;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">this</span>.keys;</span><br><span class="line">    <span class="keyword">if</span> (!hasOwnProperty.call(map, key)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys.length === <span class="built_in">this</span>.limit) &#123;</span><br><span class="line">            <span class="keyword">var</span> firstKey = keys.shift();</span><br><span class="line">            <span class="keyword">delete</span> map[firstKey];</span><br><span class="line">        &#125;</span><br><span class="line">        keys.push(key)</span><br><span class="line">    &#125;</span><br><span class="line">    map[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LimitMap.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.map[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = LimitMap</span><br></pre></td></tr></table></figure><p>当然这种超过数量就以先进先出的方式进行淘汰的策略并不是十分高效，我们还可以采用 LRU 算法来进行处理。</p><p>除了这种直接使用键值对来当作缓存对象以外还有一种案例在于模块机制。为了加速模块的引入，所有模块都会通过编译执行，然后被缓存下来。由于通过 exports 导出的函数可以访问文件模块中的私有变量，这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因不会被释放。因此在设计模块时要十分小心内存泄漏的出现。</p><p>直接将内存作为缓存的方案要十分慎重。除了限制缓存的大小外另外要考虑的事情是，进程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。如果使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着两孩的缓存过期淘汰策略以及自有的内存管理，不影响 Node 进程的性能。目前市场上比较好的缓存有 Redis 和 Memcached。</p><h4 id="2关注队列状态"><a class="markdownIt-Anchor" href="#2关注队列状态"></a> (2)关注队列状态</h4><p>另一个不经意产生的内存泄漏则是队列。在 JavaScript 中可以通过队列（数组对象）来完成许多特殊的需求，队列经常在消费者-生产者模型中经常充当中间产物。这是一个容易忽略的情况，因为在大多数应用场景下，消费的速度远远大于生产的速度，内存泄漏不易发生。但是一旦消费的速度低于生产速度将会形成堆积。</p><p>这种情境下表层的解决方案是换用消费速度更高的技术，但是更深层的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。</p><h4 id="3内存泄漏排查"><a class="markdownIt-Anchor" href="#3内存泄漏排查"></a> (3)内存泄漏排查</h4><p>在 Node 中由于 V8 的堆内存大小的限制，它对内存泄漏非常敏感。当在线服务的请求量变大时，哪怕是一个字节的泄漏都会导致内存占用过高，常用的内存泄漏排查工具有：</p><ul><li>v8-profiler</li><li>node-headdump</li><li>node-memwatch</li></ul><h3 id="4-大内存应用"><a class="markdownIt-Anchor" href="#4-大内存应用"></a> 4、大内存应用</h3><p>由于 Node 的内存限制，操作大文件也要小心，好在 Node 提供了 stream 模块用于处理大文件。stream 继承自 EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法，它分为可读和可写两种。Node 中大多数模块都有 stream 的应用，比如 fs 的 createReadStream() 和 createWriteStream() 方法可以分别用于创建文件的可读流和可写流，可读流提供了管道方法 pipe() ，封装了 data 事件和写入操作，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = fs.createReadStream()</span><br><span class="line"><span class="keyword">var</span> writer = fs.createWriteStream()</span><br><span class="line">reader.pipe(writer)</span><br></pre></td></tr></table></figure><p>上述示例通过流的方式不会收到 V8 内存的限制，有效提高了程序的健壮性。</p><p>除此之外如果不需要进行字符串层面的操作，则不需要借助 V8 来处理，可以尝试进行纯粹的 Buffer 操作，这不会收到 V8 堆内存的限制，但是仍然需要小心物理内存的限制。</p><h2 id="六-理解buffer"><a class="markdownIt-Anchor" href="#六-理解buffer"></a> 六、理解Buffer</h2><h3 id="1-buffer结构"><a class="markdownIt-Anchor" href="#1-buffer结构"></a> 1、Buffer结构</h3><p>Buffer 是典型的 JavaScript 和 C++ 结合的模块。它将性能相关部分用 C++ 实现，将非性能相关的部分用 JavaScript 实现，如下图所示：</p><img src="/assets/深入浅出NodeJS/11.png" width="400"><p>由于 Buffer 太过常见，Node 在进程启动时就已经加载了它，并将其放在全局对象上，所以在使用 Buffer 时，无须通过 require() 即可直接使用。</p><h4 id="1buffer对象"><a class="markdownIt-Anchor" href="#1buffer对象"></a> (1)Buffer对象</h4><p>Buffer 对象类似于数组，元素为 16 进制的两位数，即 0～255 之间的数值。不同编码的字符串占用的元素各不相同，例如中文字符串在 UTF-8 编码下占据 3 个元素，字母和半角标点符号占用一个元素。</p><p>与数组类似，我们也可以通过 length 属性获取 Buffer 的长度，通过下标获取指定元素，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> Buffer(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buffer.length) <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(buffer[<span class="number">20</span>]) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>同样我们也可以直接通过下标为 Buffer 进行赋值，不过需要注意的是如果给元素赋值的值超过 255 就会逐次减去 256，直到得到 0～255 区间的数值。如果小于 0，则会将数值逐次加 256,直到得到 0～255 区间的数值。如果是小数舍弃掉小数部分只保留整数部分。</p><h4 id="2buffer内存分配"><a class="markdownIt-Anchor" href="#2buffer内存分配"></a> (2)Buffer内存分配</h4><p>Buffer 对象的内存分配不在 V8 的堆内存中，而是在 Node 的 C++ 层面实现内存的申请的，然后在 JavaScript 中分配内存，为了高效使用申请的内存 Node 采用了 slab 分配机制，简单而言 slab 就是一块申请好的固定大小的内存区域，slab 具有如下 3 种状态：</p><ul><li>full: 完全分配状态</li><li>partial: 部分分配状态</li><li>empty: 没有被分配的状态</li></ul><p>Node 以 8KB 为界限来区分 Buffer 是大对象还是小对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.poolSize = <span class="number">8</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>这个 8KB 也就是每个 slab 的大小值，在 JavaScript 层面，以它作为单位单元进行内存的分配。</p><p><strong>分配小 Buffer 对象</strong></p><p>如果指定 Buffer 的大小小于 8KB，Node 会按照小对象的方式进行分配。Buffer 的分配过程主要是使用一个局部变量 pool 作为中间处理对象，处于分配状态的 slab 单元都指向它，如果是分配一个全新的 slab 单元它将会申请一个新的 SlowBuffer 指向它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocPool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pool = <span class="keyword">new</span> SlowBuffer(Buffer.poolSize);</span><br><span class="line">    pool.used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>示例中我们新建了一个小 Buffer 对象，这次构造将会去检查 pool 对象，如果 pool 对象没有被创建，将会创建一个全新的 slab 单元指向它，这时 slab 单元处于 empty 状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pool || pool.length - pool.used &lt; <span class="built_in">this</span>.length) allocPool()</span><br></pre></td></tr></table></figure><p>同时该 Buffer 对象的 parent 属性指向该 slab，并记录下是从 slab 的哪个位置（offset）开始使用的，slab 对象自身也记录被使用了多少字节，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.parent = pool;</span><br><span class="line"><span class="built_in">this</span>.offset = pool.used;</span><br><span class="line">pool.used += <span class="built_in">this</span>.length;</span><br><span class="line"><span class="keyword">if</span> (pool.used &amp; <span class="number">7</span>) pool.used = ()</span><br></pre></td></tr></table></figure><p>这个时候 slab 单元处于 partial 状态。</p><p>当再次创建一个 Buffer 对象的时候构造过程就会判断这个 slab 的剩余空间是否足够，如果足够使用剩余空间，并更新 slab 的分配状态，如果 slab 的剩余空间不够，将会构造新的 slab，原 slab 中剩余的空间会造成浪费。</p><p><strong>分配大 Buffer 对象</strong></p><p>如果需要新建一个超过 8KB 的 Buffer 对象，将会直接分配一个 SlowBuffer 对象作为 slab 单元，这个 slab 单元将会被这个大 Buffer 对象独占。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.parent = <span class="keyword">new</span> SlowBuffer(<span class="built_in">this</span>.length)</span><br><span class="line"><span class="built_in">this</span>.offet = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>需要注意 Buffer 对象都是 JavaScript 层面的，能够被 V8 的垃圾回收标记回收，但是其内部的 parent 属性指向的 slowBuffer 却是来自于 Node 自身 C++ 的定义，是 C++ 层面上的 Buffer 对象，所以内存不在 V8 的堆中，因此不推荐用户直接操作它。</p><p><strong>总结</strong></p><p>简单而言，真正的内存是在 Node 的 C++ 层面提供的，JavaScript 层面只是使用它。当进行小而频繁的 Buffer 操作时，采用 slab 的机制进行预先申请和事后分配，使得 JavaScript 到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的 Buffer 而言，则直接使用 C++ 层面提供的内存，而无需细腻的分配操作。</p><h3 id="2-buffer的转换"><a class="markdownIt-Anchor" href="#2-buffer的转换"></a> 2、Buffer的转换</h3><p>Buffer 对象可以与字符串之间相互转换。</p><h4 id="1字符串转-buffer"><a class="markdownIt-Anchor" href="#1字符串转-buffer"></a> (1)字符串转 Buffer</h4><p>字符串转 Buffer 对象主要是通过构造函数完成的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(str, [encoding]);</span><br></pre></td></tr></table></figure><p>通过构造函数转换的 Buffer 对象，存储的只能是一种编码类型。encoding 参数不传递时，默认按 UTF-8 编码进行转码和存储。</p><p>一个 Buffer 对象可以存储不同编码类型的字符串转码的值，调用 write() 方法可以实现这个目的，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.write(string, [offset], [length], [encoding])</span><br></pre></td></tr></table></figure><p>由于可以不断写入内容到 Buffer 对象中，并且每次写入可以指定编码，所以 Buffer 对象中可以存在多种编码转化后的内容。因此 Buffer 反转字符串的时候需要格外小心。</p><h4 id="2buffer-转字符串"><a class="markdownIt-Anchor" href="#2buffer-转字符串"></a> (2)Buffer 转字符串</h4><p>实现 Buffer 向字符串的转换也十分简单，Buffer 对象的 toString() 可以将 Buffer 对象转换为字符串，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toString([encoding], [start], [end])</span><br></pre></td></tr></table></figure><p>通过设置 encoding（默认UTF-8）、start、end这三个参数实现整体或局部的转换。如果 Buffer 对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。</p><h3 id="3-buffer-的拼接"><a class="markdownIt-Anchor" href="#3-buffer-的拼接"></a> 3、Buffer 的拼接</h3><p>为了解释 Buffer 最容易出现的乱码情况我们以如下代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">&#x27;test.md&#x27;</span>, &#123; <span class="attr">highWaterMark</span>: <span class="number">11</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">rs.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    data += chunk;</span><br><span class="line">&#125;)</span><br><span class="line">rs.on(<span class="string">&quot;end&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们在测试数据中写入李白的《静夜思》，控制台最终输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">床前明��光，</span><br><span class="line">疑是地上��。</span><br><span class="line">举头望明月��</span><br><span class="line">低头思故乡。</span><br></pre></td></tr></table></figure><p>那么这里的乱码是如何产生的呢？</p><p>这是因为文件可读流在读取时会逐个读取 Buffer，这首诗的原始 Buffer 为 <code>&lt;Buffer e5 ba 8a e5 89 8d e6 98 8e e6 9c 88 e5 85 89 ef bc 8c 0a e7 96 91 e6 98 af e5 9c b0 e4 b8 8a e9 9c 9c e3 80 82 0a e4 b8 be e5 a4 b4 e6 9c 9b e6 98 8e ... 25 more bytes&gt;</code>，由于我们限定了 Buffer 对象的长度为 11，因此只读流需要读取 7 次才能完成完整的读取，结果是以下几个 Buffer 对象依次输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buffer e5 ba 8a e5 89 8d e6 98 8e e6 9c&gt;</span><br><span class="line">&lt;Buffer 88 e5 85 89 ef bc 8c 0a e7 96 91&gt;</span><br><span class="line">&lt;Buffer e6 98 af e5 9c b0 e4 b8 8a e9 9c&gt;</span><br><span class="line">&lt;Buffer 9c e3 80 82 0a e4 b8 be e5 a4 b4&gt;</span><br><span class="line">&lt;Buffer e6 9c 9b e6 98 8e e6 9c 88 ef bc&gt;</span><br><span class="line">&lt;Buffer 8c 0a e4 bd 8e e5 a4 b4 e6 80 9d&gt;</span><br><span class="line">&lt;Buffer e6 95 85 e4 b9 a1 e3 80 82&gt;</span><br></pre></td></tr></table></figure><p>buf.toString() 方法默认采用 UTF-8 编码，中文在 UTF-8 下占 3 个字节。所以第一个 Buffer 对象在输出时，只能显示 3 个字符，Buffer 中剩下的两个字节将会以乱码的方式显示。</p><p>在示例中我们构造了 11 这个限制，但是<strong>对于任意长度的 Buffer 而言宽字节字符串都有可能存在被截断的情况</strong>，只不过 Buffer 的长度越大出现的概率越低而已。</p><h4 id="1setencoding-与-string_decoder"><a class="markdownIt-Anchor" href="#1setencoding-与-string_decoder"></a> (1)setEncoding() 与 string_decoder()</h4><p>可读流对象可以通过 setEncoding() 方法设置编码方式，在方法内部会为可读流对象设置一个 decorator 对象，每次 data 事件都通过该 decorator 对象进行 Buffer 到字符串的解码，然后传递给调用者。decorator 对象来自 string_decorator 模块 StringDecorator 的实例对象，它在对 Buffer 进行解码时会保留未成功解析的字符，等到下次字符流到来合并到一起进行解析，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> StringDecorator = <span class="built_in">require</span>(<span class="string">&#x27;string_decorator&#x27;</span>).StringDecorator;</span><br><span class="line"><span class="keyword">var</span> decorator = <span class="keyword">new</span> StringDecorator(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf1 = <span class="keyword">new</span> Buffer([oxE5, oxBA, <span class="number">0x8A</span>, oxE5, ox89, ox8D, <span class="number">0xE6</span>, ox98, ox8E, oxE6, ox9C]);</span><br><span class="line"><span class="built_in">console</span>.log(decorator.write(buf1)); <span class="comment">// 床前明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf2 = <span class="keyword">new</span> Buffer([ox88, oxE5, <span class="number">0x85</span>, ox89, <span class="number">0xEF</span>, oxBC, ox8C, oxE7, ox96, ox91, oxE6]);</span><br><span class="line"><span class="built_in">console</span>.log(decorator.write(buf2)); <span class="comment">// 月光，疑</span></span><br></pre></td></tr></table></figure><p>decorator 在第一次 write() 时只输出前 9 个字节转码形成的字符，“月”字的前两个字节被保留在 StringDecorator 实例内部，第二次 write() 时将这剩余的两个字符与 11 个字符组合到一起再进行转码。</p><p>因此我们可以使用 setEncoding() 方法来解决《静夜思》的乱码问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">&#x27;test.md&#x27;</span>, &#123; <span class="attr">highWaterMark</span>: <span class="number">11</span> &#125;);</span><br><span class="line">rs.setEncoding(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>虽然 string_decorator 模块很奇妙，但是它目前只能处理 UTF-8、Base64 和 UCS-2/UTF-16LE 这三种编码，所以 setEncoding 并不能从根本上解决这个问题。</p><h4 id="2正确拼接-buffer"><a class="markdownIt-Anchor" href="#2正确拼接-buffer"></a> (2)正确拼接 Buffer</h4><p>除了 setEncoding 之外更好的解决方案是将多个小 Buffer 对象拼接成一个 Buffer 对象后再通过 iconv-lite（采用 JavaScript 实现的 Node 模块，支持更多的编码类型转换）一类的模块来转码，具体实现如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chunks = [];</span><br><span class="line"><span class="keyword">var</span> size = <span class="number">0</span>;</span><br><span class="line">res.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    chunks.push(chunk);</span><br><span class="line">    size += chunk.length;</span><br><span class="line">&#125;)</span><br><span class="line">res.on(<span class="string">&quot;end&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf = Buffer.concat(chunks, size);</span><br><span class="line">    <span class="keyword">var</span> str = iconv.decode(buf, <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(str)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中 Buffer.concat() 方法的具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat = <span class="function"><span class="keyword">function</span> (<span class="params">list, length</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(list)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Usage: Buffer.concat(list, [length])&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Buffer(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.length === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> list[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> length !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> buf = list[i];</span><br><span class="line">            length += buf.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buffer = <span class="keyword">new</span> Buffer(length);</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> buf = list[i];</span><br><span class="line">        buf.copy(buffer, pos);</span><br><span class="line">        pos += buf.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-buffer-与性能"><a class="markdownIt-Anchor" href="#4-buffer-与性能"></a> 4、Buffer 与性能</h3><p>在服务器传输数据时，通过预先转换静态内容为 Buffer 对象可以有效地减少 CPU 的重复使用，节省服务器的资源。在 Node 构建的 Web 应用中，可以选择将页面中动态内容和静态内容分离，静态内容部分可以通过预先转换为 Buffer 的方式使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取 Buffer，然后直接传输，不做额外的转换，避免损耗。</p><p>Buffer 的使用除了与字符串的转换有性能损耗外在文件读取时，有一个 highWaterMark 设置对性能的影响也至关重要。</p><p>fs.createReadStream() 的工作方式是在内存中准备一段 Buffer，然后在 fs.read() 读取时逐步从磁盘中将字节复制到 Buffer 中。完成一次读取时，则从这个 Buffer 中通过 slice() 方法取出部分数据作为一个小 Buffer 对象，再通过 data 事件传递给调用方。如果 Buffer 用完则重新分配一个，如果还有一个则继续使用。这个过程与小 Buffer 对象的内存分配比较类似，highWaterMark 的大小对性能有两个影响的点：</p><ul><li>highWaterMark 设置对 Buffer 内存的分配和使用有一定的影响。</li><li>heighWaterMark 设置过小，可能导致系统调用次数过多。</li></ul><p>文件流读取基于 Buffer 分配，Buffer 则基于 SlowBuffer 分配，这可以理解为两个维度的分配策略。如果文件较小（小于 8KB），有可能造成 slab 未能完全使用。由于 fs.createReadStream() 内部采用 fs.read() 方法实现，将会引起对磁盘的系统调用，对于大文件而言，highWaterMark 的大小决定会触发系统调用和 data 事件的次数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在微信读书零零散散看了一些章节，这次特意买了实体书认真全部看一遍，希望能用这篇博客去做一个记录和思考。&lt;/p&gt;
&lt;h2 id=&quot;一-node-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-node-简介&quot;&gt;&lt;/a&gt; 一、Node 简介&lt;/h2&gt;
&lt;h3 id=&quot;1-node-的特点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-node-的特点&quot;&gt;&lt;/a&gt; 1、Node 的特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;异步IO: Node 在底层构建了很多异步 I/O 的 API，从文件的读取到网络请求等，这样的意义在于在 Node 中我们可以从语言层面很自然地进行并行 I/O 操作而无须等待之前的调用结束，在编程模型上可以极大的提升效率。&lt;/li&gt;
&lt;li&gt;事件与回调函数: 事件的编程方式具有轻量级、松耦合、只关注事务点等优势，Node 将前端浏览器中应用广泛且成熟的事件引入后端，配合异步 I/O，将事件点暴露给业务逻辑，极大程度上方便了业务层的编码处理。但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是个主要的问题，Node 为此提供了回调函数，而且纵观下来回调函数也是最好的接受异步调用返回数据的方式。&lt;/li&gt;
&lt;li&gt;单线程: Node 保持了 JavaScript 在浏览器中单线程的特点，而且在 Node 中 JavaScript 与其他线程是无法共享任何状态的，单线程最大的好处是不用在线线程间的状态同步问题，没有频繁切换线程上下文所带来的性能损耗，缺点在于无法利用多核 CPU、错误会引起整个应用退出、CPU 阻塞会导致无法继续调用异步 I/O。&lt;/li&gt;
&lt;li&gt;跨平台: Node 借助 libuv 成功在操作系统与上层 Node 模块之间构建了一层平台层架构，因此借助 libuv 良好的架构设计 Node 实现了跨平台开发。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Node" scheme="http://kyleezhang.com/categories/Node/"/>
    
    
    <category term="Node" scheme="http://kyleezhang.com/tags/Node/"/>
    
    <category term="读书笔记" scheme="http://kyleezhang.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 SourceMap</title>
    <link href="http://kyleezhang.com/2021/07/11/sourcemap/"/>
    <id>http://kyleezhang.com/2021/07/11/sourcemap/</id>
    <published>2021-07-11T07:57:42.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-sourcemap"><a class="markdownIt-Anchor" href="#什么是-sourcemap"></a> 什么是 SourceMap</h2><p>在前端开发过程中，通常我们编写的源代码会经过多重处理（编译、封装、压缩等），最后形成产物代码。于是在浏览器中调试产物代码时，我们往往会发现代码变得面目全非，因此，我们需要一种在调试时将产物代码显示回源代码的功能，SourceMap 就是实现这一目标的工具。</p><p>SourceMap 的基本原理是，在编译处理的过程中，在生成产物代码的同时生成产物代码中被转换的部分与源代码中相应部分的映射关系表。有了这样一张完整的映射表，我们就可以通过 Chrome 控制台中的&quot;Enable Javascript source map&quot;来实现调试时的显示与定位源代码功能。</p><p>注：我们在控制台的网络面板中通常看不到 source map 文件的请求，其原因是出于安全考虑 Chrome 隐藏了 source map 的请求，需要通过 <a href="chrome://net-export/">net-log</a> 来查询。</p><a id="more"></a><h2 id="webpack-中-sourcemap-的预设"><a class="markdownIt-Anchor" href="#webpack-中-sourcemap-的预设"></a> Webpack 中 SourceMap 的预设</h2><p>在 Webpack 中，通过设置 devtool 来选择 source map 的预设类型，文档中共有 <a href="https://webpack.js.org/configuration/devtool/#devtool">20 余种</a> source map 的预设，这些预设通常包含了 “eval” “cheap” “module” “inline” “hidden” “nosource” “source-map” 等关键字的组合，这些关键字的具体逻辑如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack/lib/WebpackOptionsApply.js:232 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (options.devtool.includes(<span class="string">&quot;source-map&quot;</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> hidden = options.devtool.includes(<span class="string">&quot;hidden&quot;</span>); </span><br><span class="line">  <span class="keyword">const</span> inline = options.devtool.includes(<span class="string">&quot;inline&quot;</span>); </span><br><span class="line">  <span class="keyword">const</span> evalWrapped = options.devtool.includes(<span class="string">&quot;eval&quot;</span>); </span><br><span class="line">  <span class="keyword">const</span> cheap = options.devtool.includes(<span class="string">&quot;cheap&quot;</span>); </span><br><span class="line">  <span class="keyword">const</span> moduleMaps = options.devtool.includes(<span class="string">&quot;module&quot;</span>); </span><br><span class="line">  <span class="keyword">const</span> noSources = options.devtool.includes(<span class="string">&quot;nosources&quot;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Plugin = evalWrapped </span><br><span class="line">    ? <span class="built_in">require</span>(<span class="string">&quot;./EvalSourceMapDevToolPlugin&quot;</span>) </span><br><span class="line">    : <span class="built_in">require</span>(<span class="string">&quot;./SourceMapDevToolPlugin&quot;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Plugin(&#123; </span><br><span class="line">    filename: inline ? <span class="literal">null</span> : options.output.sourceMapFilename, </span><br><span class="line">    moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate, </span><br><span class="line">    fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate, </span><br><span class="line">    append: hidden ? <span class="literal">false</span> : <span class="literal">undefined</span>, </span><br><span class="line">    <span class="built_in">module</span>: moduleMaps ? <span class="literal">true</span> : cheap ? <span class="literal">false</span> : <span class="literal">true</span>, </span><br><span class="line">    columns: cheap ? <span class="literal">false</span> : <span class="literal">true</span>, </span><br><span class="line">    noSources: noSources, </span><br><span class="line">    namespace: options.output.devtoolNamespace </span><br><span class="line">  &#125;).apply(compiler); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.devtool.includes(<span class="string">&quot;eval&quot;</span>)) &#123; </span><br><span class="line">  <span class="keyword">const</span> EvalDevToolModulePlugin = <span class="built_in">require</span>(<span class="string">&quot;./EvalDevToolModulePlugin&quot;</span>); </span><br><span class="line">  <span class="keyword">new</span> EvalDevToolModulePlugin(&#123; </span><br><span class="line">    moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate, </span><br><span class="line">    namespace: options.output.devtoolNamespace </span><br><span class="line">  &#125;).apply(compiler); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码所示， devtool 的值匹配并非精确匹配，某个关键字只要包含在赋值中即可获得匹配，不同关键字的具体作用如下：</p><ul><li>false：即不开启 source map 功能，其他不符合上述规则的赋值也等价于 false。</li><li>eval：是指在编译器中使用 EvalDevToolModulePlugin 作为 source map 的处理插件。</li><li>[xxx-…]source-map：根据 devtool 对应值中是否有 eval 关键字来决定使用 EvalSourceMapDevToolPlugin 或 SourceMapDevToolPlugin 作为 source map 的处理插件，其余关键字则决定传入到插件的相关字段赋值。</li><li>inline：决定是否传入插件的 filename 参数，作用是决定单独生成 source map 文件还是在行内显示，该参数在 eval- 参数存在时无效。</li><li>hidden：决定传入插件 append 的赋值，作用是判断是否添加 SourceMappingURL 的注释，该参数在 eval- 参数存在时无效。</li><li>module：为 true 时传入插件的 module 为 true ，作用是为加载器（Loaders）生成 source map，因此可以查看到转换前的代码。</li><li>cheap：这个关键字有两处作用。首先，当 module 为 false 时，它决定插件 module 参数的最终取值，最终取值与 cheap 相反。其次，它决定插件 columns 参数的取值，作用是决定生成的 source map 中是否包含列信息，在不包含列信息的情况下，调试时只能定位到指定代码所在的行而定位不到所在的列。</li><li>nosource：nosource 决定了插件中 noSource 变量的取值，作用是决定生成的 source map 中是否包含源代码信息，不包含源码情况下只能显示调用堆栈信息。</li></ul><p>从上面的规则中我们还可以看到，根据不同规则，实际上 Webpack 是从三种插件中选择其一作为 source map 的处理插件。</p><ul><li>EvalDevToolModulePlugin：模块代码后添加 sourceURL=webpack:///+ 模块引用路径，不生成 source map 内容，模块产物代码通过 eval() 封装。</li><li>EvalSourceMapDevToolPlugin：生成 base64 格式的 source map 并附加在模块代码之后， source map 后添加 sourceURL=webpack:///+ 模块引用路径，不单独生成文件，模块产物代码通过 eval() 封装。</li><li>SourceMapDevToolPlugin：生成单独的 .map 文件，模块产物代码不通过 eval 封装。</li></ul><p>通过上面的代码分析，我们了解了不同参数在 Webpack 运行时起到的作用。那么这些不同参数组合下的各种预设对我们的 source map 生成又各自会产生什么样的效果呢？下面我们通过示例来看一下。</p><img src="/assets/sourcemap/01.png" /><blockquote><p>*注1：“/”前后分别表示产物 js 大小和对应 .map 大小。<br />*注2：“/”前后分别表示初次构建时间和开启 watch 模式下 rebuild 时间。对应统计的都是 development 模式下的笔者机器环境下几次构建时间的平均值，只作为相对快慢与量级的比较。</p></blockquote><p>从结果中可以看到，eval- 对应的 EvalSourceMapDevToolPlugin 整体要快于不带 eval- 的 SourceMapDevToolPlugin。尤其在质量最佳的配置下，eval-source-map 的再次构建速度要远快于其他几种，这是为什么呢？</p><p>原作者对于其的解释如下：</p><blockquote><p>devtool: “source-map” cannot cache SourceMaps for modules and need to regenerate complete SourceMap for the chunk. It’s something for production.<br />devtool: “eval-source-map” is really as good as devtool: “source-map”, but can cache SourceMaps for modules. It’s much faster for rebuilds.</p></blockquote><p>可以看到加 eval 和不加的功能是一样的，但加了 eval 后可利用字符串可缓存从而提效，因此再次构建速度更快。</p><p>在开发环境和生产环境下，我们对于 source map 功能的期望也有所不同：</p><p>我们在开发环境对 sourceMap 的要求是：快（eval），信息全（module），且由于此时代码未压缩，我们并不那么在意代码列信息(cheap),所以开发环境比较推荐配置是 cheap-module-eval-source-map</p><p>生产环境中一般情况下，我们并不希望任何人都可以在浏览器直接看到我们未编译的源码，所以我们不应该直接提供 sourceMap 给浏览器。但我们又需要 sourceMap 来定位我们的错误信息，一方面 webpack 会生成 sourcemap 文件以提供给错误收集工具比如 sentry，另一方面又不会为 bundle 添加引用注释，以避免浏览器使用。这时我们可以选择 hidden-source-map</p><p>除了通过 devtool 属性指定关键字外我们还可以通过自定义插件实现 source map 的生成，以 EvalSourceMapDevToolPlugin 为例，在 EvalSourceMapDevToolPlugin 的传入参数中，除了上面和预设相关的 filename、append、module、columns 外，还有影响注释内容的 moduleFilenameTemplate 和 protocol，以及影响处理范围的 test、include、exclude。这里重点看处理范围的参数，因为通常我们需要调试的是开发的业务代码部分，而非依赖的第三方模块部分。因此在生成 source map 的时候如果可以排除第三方模块的部分而只生成业务代码的 source map，无疑能进一步提升构建的速度，例如示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ... </span><br><span class="line">  <span class="comment">//devtool: &#x27;eval-source-map&#x27;, </span></span><br><span class="line">  devtool: <span class="literal">false</span>, </span><br><span class="line">  plugins: [ </span><br><span class="line">    <span class="keyword">new</span> webpack.EvalSourceMapDevToolPlugin(&#123; </span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>, </span><br><span class="line">      <span class="built_in">module</span>: <span class="literal">true</span>, </span><br><span class="line">      columns: <span class="literal">false</span> </span><br><span class="line">    &#125;) </span><br><span class="line">  ], </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们将 devtool 设为 false，而直接使用 EvalSourceMapDevToolPlugin，通过传入 module: true 和 column:false，达到和预设 eval-cheap-module-source-map 一样的质量，同时传入 exclude 参数，排除第三方依赖包的 source map 生成。保存设定后通过运行可以看到，在文件体积减小的同时，再次构建的速度相比上面表格中的速度提升了将近一倍，达到了最快一级。</p><h2 id="sourcemap-实现的原理是什么"><a class="markdownIt-Anchor" href="#sourcemap-实现的原理是什么"></a> SourceMap 实现的原理是什么</h2><p>我们在前文提到 SourceMap 的主要作用就是在生成产物代码的同时生成产物代码中被转换的部分与源代码中相应部分的映射关系表，那么 SourceMap 到底怎么做到源文件和处理后文件映射的？</p><h3 id="一-map-文件详解"><a class="markdownIt-Anchor" href="#一-map-文件详解"></a> 一、map 文件详解</h3><p>要分析实现，还是得先从现象下手，假定源文件 script.js 内容为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>其输出内容为 script-min.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>对应生成的 source map 文件 script-min.js.map:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;version&quot;:3,&quot;file&quot;:&quot;script-min.js&quot;,&quot;lineCount&quot;:1,&quot;mappings&quot;:&quot;AAAA,IAAIA,EAAE,CAAN,CACIC,EAAE,CADN,CAEIC,EAAE;&quot;,&quot;sources&quot;:[&quot;script.js&quot;],&quot;names&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&#125;</span><br></pre></td></tr></table></figure><p>各个字段的具体含义如下：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>version</td><td>Source map 的版本，目前为 3</td></tr><tr><td>file</td><td>转换后的文件名</td></tr><tr><td>sourceRoot</td><td>转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空</td></tr><tr><td>sources</td><td>转换前的文件,该项是一个数组,表示可能存在多个文件合并</td></tr><tr><td>names</td><td>转换前的所有变量名和属性名</td></tr><tr><td>mappings</td><td>记录位置信息的字符串</td></tr></tbody></table><p>可以看到，既然我们要定位，自然最关心的是具有【记录位置信息】功能的 mapping 属性，接下来详细讲解如何分析 mapping。</p><p><strong>mappings 属性值的含义</strong>：</p><table><thead><tr><th>分析角度</th><th>含义</th></tr></thead><tbody><tr><td>行对应</td><td>以分号（;）表示，每个分号对应转换后源码的一行。所以，第一个分号前的内容，就对应源码的第一行，以此类推。</td></tr><tr><td>位置对应</td><td>以逗号（,）表示，每个逗号对应转换后源码的一个位置。所以，第一个逗号前的内容，就对应该行源码的第一个位置，以此类推。</td></tr><tr><td>分词信息</td><td>以 VLQ 编码表示，代表记录该位置对应的转换前的源码位置、原来属于那个文件等信息。</td></tr></tbody></table><ul><li>【行对应】很好理解，即一个分号为一行，因为压缩后基本上都是一行了，所以这个没啥有用信息；</li><li>【位置对应】可以理解为分词，每个逗号对应转换后源码的一个位置；</li><li>【分词信息】是关键，如AAAA代表该位置转换前的源码位置，以VLQ编码表示；</li></ul><p>举例来说，假定mappings属性的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mappings:&quot;AAAAA,BBBBB;CCCCC&quot;</span><br></pre></td></tr></table></figure><p>就表示，转换后的源码分成两行，第一行有两个位置，第二行有一个位置。</p><p>其中【分词信息】每组最多五位（如果不是变量，只会有四位），分别是：</p><ul><li>第一位，表示这个位置在【转换后代码】的第几列。</li><li>第二位，表示这个位置属于【sources 属性】中的哪一个文件。</li><li>第三位，表示这个位置属于【转换前代码】的第几行。</li><li>第四位，表示这个位置属于【转换前代码】的第几列。</li><li>第五位，表示这个位置属于【names 属性】的哪一个变量。</li></ul><p>有几点需要说明。首先，所有的值都是以0作为基数的。其次，第五位不是必需的，如果该位置没有对应names属性中的变量，可以省略第五位。再次，每一位都采用VLQ编码表示；由于VLQ编码是变长的，所以每一位可以由多个字符构成。</p><p>如果某个位置是AAAAA，由于A在VLQ编码中表示0，因此这个位置的五个位实际上都是0。它的意思是，该位置在转换后代码的第0列，对应sources属性中第0个文件，属于转换前代码的第0行第0列，对应names属性中的第0个变量。</p><p>到此，我们也算是知道 map 文件到底是怎么组成的了。</p><h3 id="二-vlq-编码"><a class="markdownIt-Anchor" href="#二-vlq-编码"></a> 二、VLQ 编码</h3><p>VLQ 编码最早用于MIDI文件，后来被多种格式采用。它的特点就是可以非常精简地表示很大的数值。</p><p>VLQ编码是变长的。如果（整）数值在-15到+15之间（含两个端点），用一个字符表示；超出这个范围，就需要用多个字符表示。它规定，每个字符使用6个两进制位，正好可以借用Base 64编码的字符表。</p><img src="/assets/02.png" width="500" /><p>在这6个位中，左边的第一位（最高位）表示是否&quot;连续&quot;（continuation）。如果是1，代表这６个位后面的6个位也属于同一个数；如果是0，表示该数值到这6个位结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Continuation</span><br><span class="line">|　　　　　Sign</span><br><span class="line">|　　　　　|</span><br><span class="line">V　　　　　V</span><br><span class="line">１０１０１１</span><br></pre></td></tr></table></figure><p>这6个位中的右边最后一位（最低位）的含义，取决于这6个位是否是某个数值的VLQ编码的第一个字符。如果是的，这个位代表&quot;符号&quot;（sign），0为正，1为负（Source map的符号固定为0）；如果不是，这个位没有特殊含义，被算作数值的一部分。</p><p>下面看一个例子，如何对数值16进行VLQ编码。</p><ul><li>第一步，将16改写成二进制形式10000。</li><li>第二步，在最右边补充符号位。因为16大于0，所以符号位为0，整个数变成100000。</li><li>第三步，从右边的最低位开始，将整个数每隔5位，进行分段，即变成1和00000两段。如果最高位所在的段不足5位，则前面补0，因此两段变成00001和00000。</li><li>第四步，将两段的顺序倒过来，即00000和00001。</li><li>第五步，在每一段的最前面添加一个&quot;连续位&quot;，除了最后一段为0，其他都为1，即变成100000和000001。</li><li>第六步，将每一段转成Base 64编码。</li></ul><p>查表可知，100000为g，000001为B。因此，数值16的VLQ编码为gB。上面的过程，看上去好像很复杂，做起来其实很简单，具体的实现请看官方的<a href="https://github.com/mozilla/source-map/blob/master/lib/source-map/base64-vlq.js">base64-vlq.js</a>文件，里面有详细的注释。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://juejin.cn/post/6969748500938489892">万字长文：关于sourcemap，这篇文章就够了</a></p><p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">JavaScript Source Map 详解</a></p><p>拉勾教育课程《前端工程化精讲》</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-sourcemap&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是-sourcemap&quot;&gt;&lt;/a&gt; 什么是 SourceMap&lt;/h2&gt;
&lt;p&gt;在前端开发过程中，通常我们编写的源代码会经过多重处理（编译、封装、压缩等），最后形成产物代码。于是在浏览器中调试产物代码时，我们往往会发现代码变得面目全非，因此，我们需要一种在调试时将产物代码显示回源代码的功能，SourceMap 就是实现这一目标的工具。&lt;/p&gt;
&lt;p&gt;SourceMap 的基本原理是，在编译处理的过程中，在生成产物代码的同时生成产物代码中被转换的部分与源代码中相应部分的映射关系表。有了这样一张完整的映射表，我们就可以通过 Chrome 控制台中的&amp;quot;Enable Javascript source map&amp;quot;来实现调试时的显示与定位源代码功能。&lt;/p&gt;
&lt;p&gt;注：我们在控制台的网络面板中通常看不到 source map 文件的请求，其原因是出于安全考虑 Chrome 隐藏了 source map 的请求，需要通过 &lt;a href=&quot;chrome://net-export/&quot;&gt;net-log&lt;/a&gt; 来查询。&lt;/p&gt;</summary>
    
    
    
    <category term="前端工程化" scheme="http://kyleezhang.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="webpack" scheme="http://kyleezhang.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>SCSS 学习笔记</title>
    <link href="http://kyleezhang.com/2021/06/03/css-scss/"/>
    <id>http://kyleezhang.com/2021/06/03/css-scss/</id>
    <published>2021-06-03T19:52:58.000Z</published>
    <updated>2022-06-12T11:24:41.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="css-预处理器的由来"><a class="markdownIt-Anchor" href="#css-预处理器的由来"></a> CSS 预处理器的由来</h2><p>CSS 语言本身存在如下缺陷：</p><ul><li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li><li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护；</li></ul><h2 id="css-预处理器是什么"><a class="markdownIt-Anchor" href="#css-预处理器是什么"></a> CSS 预处理器是什么？</h2><p>CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题。 比如说：Sass（SCSS）、LESS、Stylus、Turbine 等等都属于 CSS 预处理器。</p><a id="more"></a><p>目前使用范围较广的 CSS 预处理器主要有如下三种：</p><ul><li>Sass：2007年诞生，最早也是最成熟的 CSS 预处理器，拥有 ruby 社区的支持和 compass 这一最强大的 CSS 框架，后来受 Less 影响，已经进化到了全面兼容 CSS 的 Scss。</li><li>Less：2009年出现，受 Sass 的影响较大，但又使用 CSS 的语法，让大部分开发者和设计师更容易上手，在 ruby 社区之外支持者远超过 Sass，其缺点是比起 SASS 来，可编程功能不够，不过优点是简单和兼容 CSS，反过来也影响了 Sass 演变到了 Scss 的时代，著名的 Twitter Bootstrap 就是采用 LESS 做底层语言的。</li><li>Stylus：2010年产生，来自 Node.js 社区，主要用来给 Node 项目进行 CSS 预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如 SASS 和 LESS，但 Stylus 被称为是一种革命性的新语言，提供一个高效、动态、和使用表达方式来生成 CSS，写法更接近于 js，并且同时支持缩进和 CSS 常规样式书写规则。</li></ul><p><strong>CSS预处理器的优劣</strong>：</p><ul><li>优点： CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题。支持嵌套、变量和逻辑等。可以让 CSS 更加简洁、提高代码复用性、逻辑分明等等</li><li>缺点： CSS 的文件体积和复杂度不可控；增加了调试难度和成本等。</li></ul><p><strong>SCSS的优点</strong>：</p><ul><li>官方介绍</li></ul><blockquote><p>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</p></blockquote><ul><li><p>特色功能</p><ul><li>完全兼容 CSS3</li><li>在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能</li><li>通过函数进行颜色值与属性值的运算</li><li>提供控制指令 (control directives)等高级功能</li><li>自定义输出格式</li></ul></li></ul><h2 id="编译环境"><a class="markdownIt-Anchor" href="#编译环境"></a> 编译环境</h2><p>Less、Scss(Sass) 和 Stylus 代码并不能被浏览器直接解析，所以必须先将它们编译成 CSS 代码，我们在实际项目开发中可以采用现有框架已经提供了的 CSS 预处理器选项，比如 webpack 提供的相应 loader、rollup 提供的相应插件等等，编译相关配置会自动帮我们生成！但是当我们在使用终端命令实现对 SCSS 代码的编译需要全局安装 Sass 预处理器，在不同的环境我们可以使用了不同的预处理器：</p><ul><li>Node 环境下的 node-sass 模块</li><li>Node 环境下的 dart-sass 模块</li><li>Ruby 环境下的 sass 模块</li><li>Dart 环境下的 sass 模块</li></ul><p>SCSS 的开发语言是 Ruby，但是由于对于前端来说最常用的环境是 Node，因此社区为我们提供了 Node 环境下的编译包 node-sass 和 dart-sass，Less 在命令行终端进行编译则需要全局安装 less 库，而 Stylus 本身就是来源于 Node.js 社区，因此只需要安装最新的 stylus 包即可使用。</p><p><strong>node-sass 模块的使用</strong>：</p><ol><li>单文件编译</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">node-sass  原有的scss文件 生成的css文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash">node-sass  原有的scss文件 -o 生成目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> example:</span></span><br><span class="line"><span class="meta">$</span><span class="bash">node-sass a.scss b.css</span></span><br><span class="line"><span class="meta">$</span><span class="bash">node-sass a.scss -o css_files</span></span><br></pre></td></tr></table></figure><ol start="2"><li>多文件编译</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">node-sass 原有的scss文件目录 -o 生成的css文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> example:</span></span><br><span class="line"><span class="meta">$</span><span class="bash">node-sass c -o d</span></span><br></pre></td></tr></table></figure><ol start="3"><li>文件监听模式</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在<span class="string">&quot;1&quot;</span>和<span class="string">&quot;2&quot;</span>的基础上填加<span class="string">&quot;-w&quot;</span>命令行参数即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash">node-sass -w 原有的scss文件 -o 生成目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash">node-sass -w 原有的scss文件目录 -o 生成的css文件目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> example:</span></span><br><span class="line"><span class="meta">$</span><span class="bash">node-sass -w scss -o css</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 效果：编译进程不结束，监听文件内容</span></span><br></pre></td></tr></table></figure><h2 id="语法糖"><a class="markdownIt-Anchor" href="#语法糖"></a> 语法糖</h2><blockquote><p>注：Sass 是一门弱类型语言，对语法要求没那么严格。</p></blockquote><h3 id="一-注释"><a class="markdownIt-Anchor" href="#一-注释"></a> 一、注释</h3><ol><li>Sass 支持标准的 CSS 多行注释 <code>/* */</code>，以及单行注释 <code>//</code>，前者会被完整输出到编译后的 CSS 文件中，而后者则不会。</li><li>将 <code>!</code> 作为多行注释的第一个字符表示在<strong>压缩输出</strong>模式下保留这条注释并输出到 CSS 文件中，通常用于添加版权信息。</li><li>插值语句 (interpolation) 也可写进多行注释中输出变量值</li></ol><p>例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> hello</span></span><br><span class="line"><span class="comment"> world!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compile scss files to css</span></span><br><span class="line"><span class="comment">// it&#x27;s ready to do it.</span></span><br><span class="line"><span class="variable">$pink</span>: <span class="number">#f3e1e1</span>;</span><br><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$pink</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$author</span>: <span class="string">&#x27;gdream@126.com&#x27;</span>;</span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> Author: #&#123;$author&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>开发模式编译后:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> hello</span></span><br><span class="line"><span class="comment"> world!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f3e1e1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> Author: &#x27;gdream@126.com&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>压缩输出模式编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f3e1e1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> Author: &#x27;gdream@126.com&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="二-变量"><a class="markdownIt-Anchor" href="#二-变量"></a> 二、变量</h3><h4 id="1定义"><a class="markdownIt-Anchor" href="#1定义"></a> 1.定义</h4><p>变量以美元符号开头，赋值方法与 CSS 属性的写法一样</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$width</span>: <span class="number">1600px</span>;</span><br><span class="line"><span class="variable">$pen-size</span>: <span class="number">3em</span>;</span><br></pre></td></tr></table></figure><h4 id="2使用"><a class="markdownIt-Anchor" href="#2使用"></a> 2.使用</h4><p>直接使用变量的名称即可调用变量</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$width</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$pen-size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3作用域"><a class="markdownIt-Anchor" href="#3作用域"></a> 3.作用域</h4><p>变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 <code>!global</code> 声明</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#foo</span> &#123;</span><br><span class="line">  <span class="variable">$width</span>: <span class="number">5em</span> !global;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#bar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#foo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#bar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-数据类型"><a class="markdownIt-Anchor" href="#三-数据类型"></a> 三、数据类型</h3><p>Sass 支持 7 种主要的数据类型：</p><ul><li>数字，<code>1, 2, 13, 10px</code></li><li>字符串，有引号字符串与无引号字符串，<code>&quot;foo&quot;, 'bar', baz</code></li><li>颜色，<code>blue, #04a3f9, rgba(255,0,0,0.5)</code></li><li>布尔型，<code>true, false</code></li><li>空值，<code>null</code></li><li>数组 (list)，用空格或逗号作分隔符，<code>1.5em 1em 0 2em, Helvetica, Arial, sans-serif</code></li><li>maps, 相当于 JavaScript 的 object，<code>(key1: value1, key2: value2)</code></li></ul><p>Sass 也支持其他 CSS 属性值，比如 Unicode 字符集，或 <code>!important</code> 声明。然而 Sass 不会特殊对待这些属性值，一律视为无引号字符串。</p><p>判断数据类型的方式：<code>type-of($value)</code></p><h4 id="1字符串strings"><a class="markdownIt-Anchor" href="#1字符串strings"></a> 1.字符串(Strings)</h4><p>SassScript 支持 CSS 的两种字符串类型：<code>有引号字符串 (quoted strings)</code>和<code>无引号字符串 (unquoted strings)</code>。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span>: <span class="string">&#x27;Tom Bob&#x27;</span>;</span><br><span class="line"><span class="variable">$container</span>: <span class="string">&quot;top bottom&quot;</span>;</span><br><span class="line"><span class="variable">$what</span>: heart;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：在编译 CSS 文件时不会改变其类型。只有一种情况例外，使用 `#&#123;&#125;` (interpolation) 时，有引号字符串将被编译为无引号字符串，这样便于在 mixin 中引用选择器名</span></span><br></pre></td></tr></table></figure><h4 id="2数字numbers"><a class="markdownIt-Anchor" href="#2数字numbers"></a> 2.数字(Numbers)</h4><p>Sass 支持两种数字类型：<code>带单位数字</code>和<code>不带单位数字</code>。（可正可负可为零，可正可浮点）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$my-age</span>: <span class="number">19</span>;</span><br><span class="line"><span class="variable">$your-age</span>: <span class="number">19.5</span>;</span><br><span class="line"><span class="variable">$height</span>: <span class="number">120px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：单位会和数字当做一个整体，进行算数运算</span></span><br></pre></td></tr></table></figure><h4 id="3空值null"><a class="markdownIt-Anchor" href="#3空值null"></a> 3.空值(Null)</h4><p>只有一个取值<code>null</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$value</span>: null;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：由于它代表空，所以不能够使用它与任何类型进行算数运算</span></span><br></pre></td></tr></table></figure><h4 id="4布尔型booleans"><a class="markdownIt-Anchor" href="#4布尔型booleans"></a> 4.布尔型(Booleans)</h4><p>只有两个取值：<code>true</code>和<code>false</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: true;</span><br><span class="line"><span class="variable">$b</span>: false;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：只有自身是false和null才会返回false，其他一切都将返回true</span></span><br></pre></td></tr></table></figure><h4 id="5数组-lists"><a class="markdownIt-Anchor" href="#5数组-lists"></a> 5.数组 (Lists)</h4><p>通过空格或者逗号分隔的一系列的值。事实上，独立的值也被视为数组，即只包含一个值的数组。索引从 <code>1</code> 开始</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$list0</span>: <span class="number">1px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="number">6px</span>;</span><br><span class="line"><span class="variable">$list1</span>: <span class="number">1px</span> <span class="number">2px</span>, <span class="number">5px</span> <span class="number">6px</span>;</span><br><span class="line"><span class="variable">$list2</span>: (<span class="number">1px</span> <span class="number">2px</span>) (<span class="number">5px</span> <span class="number">6px</span>);</span><br></pre></td></tr></table></figure><p>数组中可以包含子数组，比如 <code>1px 2px, 5px 6px</code> 是包含 <code>1px 2px</code> 与 <code>5px 6px</code> 两个数组的数组。如果内外两层数组使用相同的分隔方式，需要用圆括号包裹内层，所以也可以写成 <code>(1px 2px) (5px 6px)</code>。变化是，之前的 <code>1px 2px, 5px 6px</code> 使用逗号分割了两个子数组 (comma-separated)，而 <code>(1px 2px) (5px 6px)</code> 则使用空格分割(space-separated)。</p><p>当数组被编译为 CSS 时，Sass 不会添加任何圆括号（CSS 中没有这种写法），所以 <code>(1px 2px) (5px 6px)</code> 与 <code>1px 2px, 5px 6px</code> 在编译后的 CSS 文件中是完全一样的，但是它们在 Sass 文件中却有不同的意义，前者是包含两个数组的数组，而后者是包含四个值的数组。</p><p>用 <code>()</code> 表示不包含任何值的空数组（在 Sass 3.3 版之后也视为空的 map）。空数组不可以直接编译成 CSS，比如编译 <code>font-family: ()</code> Sass 将会报错。如果数组中包含空数组或空值，编译时将被清除，比如 <code>1px 2px () 3px</code> 或 <code>1px 2px null 3px</code>。</p><p>基于逗号分隔的数组允许保留结尾的逗号，这样做的意义是强调数组的结构关系，尤其是需要声明只包含单个值的数组时。例如 <code>(1,)</code> 表示只包含 <code>1</code> 的数组，而 <code>(1 2 3,)</code> 表示包含 <code>1 2 3</code> 这个以空格分隔的数组的数组。</p><h4 id="6映射maps"><a class="markdownIt-Anchor" href="#6映射maps"></a> 6.映射(Maps)</h4><p>Maps必须被圆括号包围，可以映射任何类型键值对（任何类型，包括内嵌maps，不过不推荐这种内嵌方式）</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$map</span>: ( </span><br><span class="line">  <span class="variable">$key1</span>: value1, </span><br><span class="line">  <span class="variable">$key2</span>: value2, </span><br><span class="line">  <span class="variable">$key3</span>: value3 </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="7颜色-colors"><a class="markdownIt-Anchor" href="#7颜色-colors"></a> 7.颜色 (Colors)</h4><p>CSS原有颜色类型，十六进制、RGB、RGBA、HSL、HSLA和色彩单词</p><p>SCSS提供了内置Colors函数，从而更方便地使用颜色(后续会详细介绍)</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$color0</span>: green;</span><br><span class="line"><span class="variable">$color1</span>: lighten(<span class="variable">$color</span>, <span class="number">15%</span>);</span><br><span class="line"><span class="variable">$color2</span>: darken(<span class="variable">$color</span>, <span class="number">15%</span>);</span><br><span class="line"><span class="variable">$color3</span>: saturate(<span class="variable">$color</span>, <span class="number">15%</span>);</span><br><span class="line"><span class="variable">$color4</span>: desaturate(<span class="variable">$color</span>, <span class="number">15%</span>);</span><br><span class="line"><span class="variable">$color5</span>: (green + red);</span><br></pre></td></tr></table></figure><h3 id="四-运算"><a class="markdownIt-Anchor" href="#四-运算"></a> 四、运算</h3><h4 id="1数字运算符"><a class="markdownIt-Anchor" href="#1数字运算符"></a> 1.数字运算符</h4><p>SassScript 支持数字的加减乘除、取整等运算 (<code>+, -, *, /, %</code>)，如果必要会在不同单位间转换值（注：如果要保留运算符号，则应该使用插值语法）。</p><ul><li><p><code>+</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纯数字</span></span><br><span class="line"><span class="variable">$add1</span>: <span class="number">1</span> + <span class="number">2</span>;<span class="comment">// 3</span></span><br><span class="line"><span class="variable">$add2</span>: <span class="number">1</span> + <span class="number">2px</span>; <span class="comment">// 3px</span></span><br><span class="line"><span class="variable">$add3</span>: <span class="number">1px</span> + <span class="number">2</span>; <span class="comment">// 3px</span></span><br><span class="line"><span class="variable">$add4</span>: <span class="number">1px</span> + <span class="number">2px</span>;<span class="comment">//3px</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯字符串</span></span><br><span class="line"><span class="variable">$add5</span>: <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// &quot;ab&quot;</span></span><br><span class="line"><span class="variable">$add6</span>: <span class="string">&quot;a&quot;</span> + b;  <span class="comment">// &quot;ab&quot;</span></span><br><span class="line"><span class="variable">$add7</span>: a + <span class="string">&quot;b&quot;</span>;  <span class="comment">// ab</span></span><br><span class="line"><span class="variable">$add8</span>: a + b;  <span class="comment">// ab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字和字符串</span></span><br><span class="line"><span class="variable">$add9</span>: <span class="number">1</span> + a;<span class="comment">// 1a</span></span><br><span class="line"><span class="variable">$adda</span>: a + <span class="number">1</span>;<span class="comment">// a1</span></span><br><span class="line"><span class="variable">$addb</span>: <span class="string">&quot;1&quot;</span> + a; <span class="comment">// &quot;1a&quot;</span></span><br><span class="line"><span class="variable">$addc</span>: <span class="number">1</span> + <span class="string">&quot;a&quot;</span>; <span class="comment">// &quot;1a&quot;</span></span><br><span class="line"><span class="variable">$addd</span>: <span class="string">&quot;a&quot;</span> + <span class="number">1</span>; <span class="comment">// &quot;a1&quot;</span></span><br><span class="line"><span class="variable">$adde</span>: a + <span class="string">&quot;1&quot;</span>; <span class="comment">// a1</span></span><br><span class="line"><span class="variable">$addf</span>: <span class="number">1</span> + <span class="string">&quot;1&quot;</span>; <span class="comment">// &quot;11&quot;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>纯数字：只要有单位，结果必有单位</li><li>纯字符串：第一个字符串有无引号决定结果是否有引号</li><li>数字和字符串：第一位有引号，结果必为引号；第一位对应数字非数字且最后一位带有引号，则结果必为引号</li></ol></li><li><p><code>-</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$add1</span>: <span class="number">1</span> - <span class="number">2</span>;<span class="comment">// -1</span></span><br><span class="line"><span class="variable">$add2</span>: <span class="number">1</span> - <span class="number">2px</span>; <span class="comment">// -1px</span></span><br><span class="line"><span class="variable">$add3</span>: <span class="number">1px</span> - <span class="number">2</span>; <span class="comment">// -1px</span></span><br><span class="line"><span class="variable">$add4</span>: <span class="number">1px</span> - <span class="number">2px</span>;<span class="comment">//-1px</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$sub1</span>: a - <span class="number">1</span>;  <span class="comment">// a-1</span></span><br><span class="line"><span class="variable">$sub2</span>: <span class="number">1</span> - a;  <span class="comment">// 1-a</span></span><br><span class="line"><span class="variable">$sub3</span>: <span class="string">&quot;a&quot;</span> - <span class="number">1</span>;<span class="comment">// &quot;a&quot;-1</span></span><br><span class="line"><span class="variable">$sub4</span>: a - <span class="string">&quot;1&quot;</span>;<span class="comment">// a-&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。</li><li>只要其中一个值首位不为数字的，结果就按顺序去除空格后拼接起来。</li></ol></li><li><p><code>*</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$num1</span>: <span class="number">1</span> * <span class="number">2</span>;    <span class="comment">// 2</span></span><br><span class="line"><span class="variable">$mul2</span>: <span class="number">1</span> * <span class="number">2px</span>;  <span class="comment">// 2px</span></span><br><span class="line"><span class="variable">$num3</span>: <span class="number">1px</span> * <span class="number">2</span>;  <span class="comment">// 2px</span></span><br><span class="line"><span class="variable">$num4</span>: <span class="number">2px</span> * <span class="number">2px</span>;<span class="comment">// 编译不通过</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$num5</span>: <span class="number">1</span> * <span class="number">2</span>abc; <span class="comment">// 2abc</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>每个字段必须前部分为数字，且两个字段只能一个后部分是字符(因为此时后缀被当被单位看待了)。其余编译不通过。</li></ol></li><li><p><code>/</code></p><p>总结：</p><ol><li>不会四舍五入，精确到小数点后5位</li><li>每个字段必须前部分为数字，且当前者只是单纯数字无单位时，后者(除数)后部分不能有字符。其余结果就按顺序去除空格后拼接起来(因为此时后缀被当被单位看待了)。</li></ol></li><li><p><code>%</code></p><p>总结：</p><ol><li>值与&quot;%&quot;之间必须要有空格，否则会被看做字符串</li></ol></li></ul><h4 id="2关系运算符"><a class="markdownIt-Anchor" href="#2关系运算符"></a> 2.关系运算符</h4><p>大前提：两端必须为<code>数字</code>或<code>前部分数字后部分字符</code></p><p>返回值：<code>true</code> or <code>false</code></p><ul><li><p><code>&gt;</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span> &gt; <span class="number">2</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span> &gt; <span class="number">2</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>&gt;=</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span> &gt;= <span class="number">2</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;=</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span> &lt;= <span class="number">2</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3相等运算符"><a class="markdownIt-Anchor" href="#3相等运算符"></a> 3.相等运算符</h4><p>作用范围：相等运算 <code>==, !=</code> 可用于所有数据类型</p><p>返回值：<code>true</code> or <code>false</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span> == <span class="number">1px</span>; <span class="comment">// true</span></span><br><span class="line"><span class="variable">$b</span>: <span class="string">&quot;a&quot;</span> == a; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>前部分为不带引号数字时，对比的仅仅是数字部分；反之，忽略引号，要求字符一一对应</li></ol><h4 id="4布尔运算符"><a class="markdownIt-Anchor" href="#4布尔运算符"></a> 4.布尔运算符</h4><p>Sass 支持布尔型的 <code>and</code> <code>or</code> 以及 <code>not</code> 运算。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>: <span class="number">1</span>&gt;<span class="number">0</span> and <span class="number">0</span>&gt;=<span class="number">5</span>; <span class="comment">// fasle</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>值与&quot;and&quot;、&quot;or&quot;和&quot;not&quot;之间必须要有空格，否则会被看做字符串</li></ol><h4 id="5颜色值运算"><a class="markdownIt-Anchor" href="#5颜色值运算"></a> 5.颜色值运算</h4><p>颜色值的运算是分段计算进行的，也就是分别计算红色，绿色，以及蓝色的值</p><ul><li><p><code>颜色值与颜色值</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#010203</span> + <span class="number">#040506</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#050709</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>颜色值与数字</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#010203</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 01 * 2 = 02 02 * 2 = 04 03 * 2 = 06，然后编译为</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#020406</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>RGB和HSL</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果颜色值包含 alpha channel（rgba 或 hsla 两种颜色值），必须拥有相等的 alpha 值才能进行运算，因为算术运算不会作用于 alpha 值。</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.75</span>) + rgba(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.75</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.75</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6运算优先级"><a class="markdownIt-Anchor" href="#6运算优先级"></a> 6.运算优先级</h4><ol start="0"><li><code>()</code></li><li><code>*</code>、<code>/</code>、<code>%</code></li><li><code>+</code>、<code>-</code></li><li><code>&gt;</code> 、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></li></ol><h3 id="五-嵌套语法"><a class="markdownIt-Anchor" href="#五-嵌套语法"></a> 五、嵌套语法</h3><h3 id="六-其他语法"><a class="markdownIt-Anchor" href="#六-其他语法"></a> 六、其他语法</h3><h4 id="1插值语法"><a class="markdownIt-Anchor" href="#1插值语法"></a> 1.<code>插值语法</code></h4><p>通过 <code>#&#123;&#125;</code> 插值语句可以在选择器、属性名和属性值中使用变量。</p><p>但大多数情况下，这样使用属性值可能还不如直接使用变量方便，但是使用 <code>#&#123;&#125;</code> 可以避免 Sass 运行运算表达式，直接编译 CSS。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span>: foo;</span><br><span class="line"><span class="variable">$attr</span>: border;</span><br><span class="line"><span class="selector-tag">p</span>.#&#123;<span class="variable">$name</span>&#125; &#123;</span><br><span class="line">  #&#123;<span class="variable">$attr</span>&#125;-<span class="attribute">color</span>: <span class="variable">$name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2.<code>&amp;</code></h4><p><code>&amp;</code>为父选择器</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blank;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3default"><a class="markdownIt-Anchor" href="#3default"></a> 3.<code>!default</code></h4><p>可以在变量的结尾添加 <code>!default</code> 给一个未通过 <code>!default</code> 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$content</span>: <span class="string">&quot;First content&quot;</span>;</span><br><span class="line"><span class="variable">$content</span>: <span class="string">&quot;Second content?&quot;</span> !default;</span><br><span class="line"><span class="variable">$new_content</span>: <span class="string">&quot;First time reference&quot;</span> !default;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="variable">$content</span>;</span><br><span class="line">  new-<span class="attribute">content</span>: <span class="variable">$new_content</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译为：</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;First content&quot;</span>;</span><br><span class="line">  new-<span class="attribute">content</span>: <span class="string">&quot;First time reference&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：变量是 null 空值时将视为未被 <code>!default</code> 赋值。</p><h4 id="3global"><a class="markdownIt-Anchor" href="#3global"></a> 3.<code>!global</code></h4><p>前文中我们已经提到它的主要作用就是将局部变量提升为全局变量</p><h4 id="4optional"><a class="markdownIt-Anchor" href="#4optional"></a> 4.<code>!optional</code></h4><p>如果 <code>@extend</code> 失败会收到错误提示，比如，这样写 <code>a.important &#123;@extend .notice&#125;</code>，当没有 <code>.notice</code> 选择器时，将会报错，只有 <code>h1.notice</code> 包含 <code>.notice</code> 时也会报错，因为 <code>h1</code> 与 <code>a</code> 冲突，会生成新的选择器。</p><p>如果要求 <code>@extend</code> 不生成新选择器，可以通过 <code>!optional</code> 声明达到这个目的.</p><p>简而言之：当<code>@extend</code>相关代码出现语法错误时，编译器可能会给我们&quot;乱&quot;编译为css，我们加上这个参数可以在出现问题后不让他编译该部分代码</p><h3 id="七-rules与指令"><a class="markdownIt-Anchor" href="#七-rules与指令"></a> 七、@-Rules与指令</h3><h4 id="1import"><a class="markdownIt-Anchor" href="#1import"></a> 1.<code>@import</code></h4><p>Sass 拓展了 <code>@import</code> 的功能，允许其导入 SCSS 或 SASS 文件。被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。</p><p>通常，<code>@import</code> 寻找 Sass 文件并将其导入，但在以下情况下，<code>@import</code> 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。</p><ul><li>文件拓展名是 <code>.css</code>；</li><li>文件名以 <code>http://</code> 开头；</li><li>文件名是 <code>url()</code>；</li><li><code>@import</code> 包含 media queries。</li></ul><p>如果不在上述情况内，文件的拓展名是 <code>.scss</code> 或 <code>.sass</code>，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 <code>.scss</code> 或 <code>.sass</code> 的文件并将其导入。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;foo.scss&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="comment">// 以上两种方式均可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方式均不可行</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;foo.css&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;foo&quot;</span> screen;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;http://foo.com/bar&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> url(foo);</span><br></pre></td></tr></table></figure><p>Sass 允许同时导入多个文件，例如同时导入 rounded-corners 与 text-shadow 两个文件：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;rounded-corners&quot;</span>, <span class="string">&quot;text-shadow&quot;</span>;</span><br></pre></td></tr></table></figure><p>导入文件也可以使用 <code>#&#123; &#125;</code> 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 <code>url()</code> 导入方式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$family</span>: unquote(<span class="string">&quot;Droid+Sans&quot;</span>);</span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;http://fonts.googleapis.com/css?family=\#&#123;$family&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译为：</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;http://fonts.googleapis.com/css?family=Droid+Sans&quot;</span>);</span><br></pre></td></tr></table></figure><p>如果你有一个 SCSS 或 Sass 文件需要引入， 但是你又不希望它被编译为一个 CSS 文件， 这时，你就可以在文件名前面加一个下划线，就能避免被编译。 这将告诉 Sass 不要把它编译成 CSS 文件。 然后，你就可以像往常一样引入这个文件了，而且还可以省略掉文件名前面的下划线。</p><p>除此之外，还支持嵌套 @import，但是不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 <code>@import</code>。</p><h4 id="2media"><a class="markdownIt-Anchor" href="#2media"></a> 2.<code>@media</code></h4><p>Sass 中 <code>@media</code> 指令与 CSS 中用法一样，只是增加了一点额外的功能：允许其在 CSS 规则中嵌套。如果 <code>@media</code> 嵌套在 CSS 规则内，编译时，<code>@media</code> 将被编译到文件的最外层，包含嵌套的父选择器。这个功能让 <code>@media</code> 用起来更方便，不需要重复使用选择器，也不会打乱 CSS 的书写流程。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (orientation: landscape) &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (orientation: landscape) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@media</code> 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 <code>and</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="keyword">@media</span> (orientation: landscape) &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为：</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (orientation: landscape) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@media</code> 甚至可以使用 Sass 中提供的变量，函数，以及运算符等代替条件的名称或者值</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$media</span>: screen;</span><br><span class="line"><span class="variable">$feature</span>: -webkit-min-device-pixel-ratio;</span><br><span class="line"><span class="variable">$value</span>: <span class="number">1.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> #&#123;<span class="variable">$media</span>&#125; and (<span class="variable">$feature</span>: <span class="variable">$value</span>) &#123;</span><br><span class="line">  .sidebar &#123;</span><br><span class="line">    width: <span class="number">500px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为：</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (-webkit-min-device-pixel-ratio: <span class="number">1.5</span>) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3extend"><a class="markdownIt-Anchor" href="#3extend"></a> 3.<code>@extend</code></h4><p><code>@extend</code>即<code>继承</code>。在设计网页的时候常常遇到这种情况：一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。</p><p>总的来看：支持层叠继承、多继承、允许延伸任何定义给单个元素的选择器（但是允许不一定好用）</p><h5 id="a-基本延伸"><a class="markdownIt-Anchor" href="#a-基本延伸"></a> a. <code>基本延伸</code></h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .error;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码的意思是将 .error 下的所有样式继承给 .seriousError，border-width: 3px; 是单独给 .seriousError 设定特殊样式，这样，使用 .seriousError 的地方可以不再使用 .error。</span></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.error</span>, <span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@extend</code> 的作用是将重复使用的样式 (<code>.error</code>) 延伸 (extend) 给需要包含这个样式的特殊样式（<code>.seriousError</code>）</p><p>注意理解以下情况：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.error</span><span class="selector-class">.intrusion</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&quot;/image/hacked.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .error;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.error</span>, <span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.error</span><span class="selector-class">.intrusion</span>, <span class="selector-class">.seriousError</span><span class="selector-class">.intrusion</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&quot;/image/hacked.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当合并选择器时，<code>@extend</code> 会很聪明地避免无谓的重复，<code>.seriousError.seriousError</code> 将编译为 <code>.seriousError</code>，不能匹配任何元素的选择器也会删除。</p><h5 id="b-延伸复杂的选择器"><a class="markdownIt-Anchor" href="#b-延伸复杂的选择器"></a> b. <code>延伸复杂的选择器</code></h5><p>Class 选择器并不是唯一可以被延伸 (extend) 的，Sass 允许延伸任何定义给单个元素的选择器，比如 <code>.special.cool</code>，<code>a:hover</code> 或者 <code>a.user[href^=&quot;http://&quot;]</code> 等</p><h5 id="c-多重延伸"><a class="markdownIt-Anchor" href="#c-多重延伸"></a> c. <code>多重延伸</code></h5><p>同一个选择器可以延伸给多个选择器，它所包含的属性将继承给所有被延伸的选择器</p><h5 id="d-继续延伸"><a class="markdownIt-Anchor" href="#d-继续延伸"></a> d. <code>继续延伸</code></h5><p>当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个</p><h5 id="e-选择器列"><a class="markdownIt-Anchor" href="#e-选择器列"></a> e. <code>选择器列</code></h5><p>暂时不可以将选择器列 (Selector Sequences)，比如 <code>.foo .bar</code> 或 <code>.foo + .bar</code>，延伸给其他元素，但是，却可以将其他元素延伸给选择器列。</p><p>尽量不使用<code>合并选择器列</code>，因为如果凭个人推理的话，会出现排列组合的情况，所以 Sass 编译器只会保留有用的组合形式，但依旧会存在排列组合的情况，有可能会留下隐患。</p><ol><li>当两个列合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前</li></ol>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#demo</span> <span class="selector-class">.overview</span> <span class="selector-class">.fakelink</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为：</span></span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-id">#demo</span> <span class="selector-class">.overview</span> <span class="selector-class">.fakelink</span>,</span><br><span class="line"><span class="selector-id">#demo</span> <span class="selector-class">.overview</span> <span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-class">.fakelink</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果两个列包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出</li></ol>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.overview</span> <span class="selector-class">.fakelink</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-class">.overview</span> <span class="selector-class">.fakelink</span>,</span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.overview</span> <span class="selector-class">.tabbar</span> <span class="selector-class">.fakelink</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="f-在指令中延伸"><a class="markdownIt-Anchor" href="#f-在指令中延伸"></a> f. <code>在指令中延伸</code></h5><p>在指令中使用 <code>@extend</code> 时（比如在 <code>@media</code> 中）有一些限制：Sass 不可以将 <code>@media</code> 层外的 CSS 规则延伸给指令层内的 CSS.</p><h5 id="g-placeholder"><a class="markdownIt-Anchor" href="#g-placeholder"></a> g. <code>%placeholder</code></h5><p><code>%placeholder</code> 为选择器占位符，配合 <code>@extend-Only选择器</code> 使用。</p><p>效果：只定义了样式，但不会对原有选择器匹配的元素生效</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1:</span></span><br><span class="line">%<span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.path</span>&#123;</span><br><span class="line">  <span class="keyword">@extend</span> %img;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后：</span></span><br><span class="line"><span class="selector-class">.path</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example2:</span></span><br><span class="line"><span class="selector-id">#context</span> <span class="selector-tag">a</span>%extreme &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.notice</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %extreme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-id">#context</span> <span class="selector-tag">a</span><span class="selector-class">.notice</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4at-root"><a class="markdownIt-Anchor" href="#4at-root"></a> 4.<code>@at-root</code></h4><blockquote><p>The @at-root directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector</p></blockquote><p>译文：@at root指令使一个或多个规则在文档的根发出，而不是嵌套在其父选择器下。它可以与单个内联选择器一起使用</p><p>在SCSS中嵌套，使用 @at-root 内联选择器模式，可以使多个规则跳出嵌套，编译出来的 CSS 无任何嵌套，让代码更加的简单。回到 SCSS 中的嵌套中，如果不使用 @at-root 内联选择器模式，将会按代码的层级关系一层一层往下嵌套</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1</span></span><br><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="keyword">@at-root</span> .bar &#123;</span><br><span class="line">    <span class="attribute">color</span>:gray;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.bar</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1</span></span><br><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="keyword">@at-root</span> &amp; .bar &#123;</span><br><span class="line">    <span class="attribute">color</span>:gray;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="keyword">@at-root</span> &amp;.bar &#123;</span><br><span class="line">    <span class="attribute">color</span>:gray;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.foo</span> <span class="selector-class">.bar</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.foo</span><span class="selector-class">.bar</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: gray; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：@at-root 默认情况下并不能使规则或者选择器跳出指令，通过使用 without 和 with 可以解决该问题</p><h4 id="5debug"><a class="markdownIt-Anchor" href="#5debug"></a> 5.<code>@debug</code></h4><p>用于调试，按标准错误输出流输出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$size</span>: <span class="number">9px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.file</span>&#123;</span><br><span class="line">  <span class="keyword">@debug</span> <span class="variable">$size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6warn"><a class="markdownIt-Anchor" href="#6warn"></a> 6.<code>@warn</code></h4><p>用于警告，按标准错误输出流输出</p><h4 id="7error"><a class="markdownIt-Anchor" href="#7error"></a> 7.<code>@error</code></h4><p>用于报错，按标准错误输出流输出</p><p><strong>总结</strong>：</p><table><thead><tr><th>序列</th><th>@-rules</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>@import</td><td>导入sass或scss文件</td></tr><tr><td>2</td><td>@media</td><td>用于将样式规则设置为不同的媒体类型</td></tr><tr><td>3</td><td>@extend</td><td>以继承的方式共享选择器</td></tr><tr><td>4</td><td>@at-root</td><td>转到根节点</td></tr><tr><td>5</td><td>@debug</td><td>用于调试，按标准错误输出流输出</td></tr><tr><td>6</td><td>@warn</td><td>用于警告，按标准错误输出流输出</td></tr><tr><td>7</td><td>@error</td><td>用于报错，按标准错误输出流输出</td></tr></tbody></table><h3 id="八-控制指令"><a class="markdownIt-Anchor" href="#八-控制指令"></a> 八、控制指令</h3><h4 id="1if"><a class="markdownIt-Anchor" href="#1if"></a> 1.<code>if()</code></h4><p><em>三元运算符</em></p><p>表达式：<code>if(expression, value1, value2)</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: if(<span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span>, green, yellow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2if"><a class="markdownIt-Anchor" href="#2if"></a> 2.<code>@if</code></h4><p><em>条件语句</em></p><p>当 <code>@if</code> 的表达式返回值不是 <code>false</code> 或者 <code>null</code> 时，条件成立，输出 <code>&#123;&#125;</code> 内的代码</p><p><code>@if</code> 声明后面可以跟多个 <code>@else if</code> 声明，或者一个 <code>@else</code> 声明。如果 <code>@if</code> 声明失败，Sass 将逐条执行 <code>@else if</code> 声明，如果全部失败，最后执行 <code>@else</code> 声明</p><ul><li><p><code>单@if</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@if - @else</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="number">1</span> + <span class="number">1</span> != <span class="number">2</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@if - @else if - @else</code></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$age</span>: <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$age</span> == <span class="number">18</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125; <span class="keyword">@else</span> if <span class="variable">$age</span> == <span class="number">19</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3for"><a class="markdownIt-Anchor" href="#3for"></a> 3.<code>@for</code></h4><p><em>循环语句</em></p><p>表达式：<code>@for $var from &lt;start&gt; through &lt;end&gt;</code> 或 <code>@for $var from &lt;start&gt; to &lt;end&gt;</code></p><p>through 和 to 的相同点与不同点：</p><ul><li>相同点：两者均包含<start>的值</li><li>不同点：through包含<end>的值，但to不包含<end>的值</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">3</span> &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123; <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">4em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">6em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4while"><a class="markdownIt-Anchor" href="#4while"></a> 4.<code>@while</code></h4><p><em>循环语句</em></p><p>表达式：<code>@while expression</code></p><p><code>@while</code> 指令重复输出格式直到表达式返回结果为 <code>false</code>。这样可以实现比 <code>@for</code> 更复杂的循环，只是很少会用到</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line"><span class="keyword">@while</span> <span class="variable">$i</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123; <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>; &#125;</span><br><span class="line">  <span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-class">.item-6</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-4</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">4em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5each"><a class="markdownIt-Anchor" href="#5each"></a> 5.<code>@each</code></h4><p><em>循环语句</em></p><p>表达式：<code>$var in $vars</code></p><p><code>$var</code> 可以是任何变量名</p><p><code>$vars</code> 只能是<code>Lists</code>或者<code>Maps</code></p><ul><li><p>一维列表</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$animal</span> in puma, sea-slug, egret, salamander &#123;</span><br><span class="line">  .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-class">.puma-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/puma.png&#x27;</span>); &#125;</span><br><span class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/sea-slug.png&#x27;</span>); &#125;</span><br><span class="line"><span class="selector-class">.egret-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/egret.png&#x27;</span>); &#125;</span><br><span class="line"><span class="selector-class">.salamander-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/salamander.png&#x27;</span>); &#125;</span><br></pre></td></tr></table></figure></li><li><p>二维列表</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$animal</span>, <span class="variable">$color</span>, <span class="variable">$cursor</span> in (puma, black, default),</span><br><span class="line">                                  (sea-slug, blue, pointer),</span><br><span class="line">                                  (egret, white, move) &#123;</span><br><span class="line">  .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/#&#123;$animal&#125;.png&#x27;</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="variable">$color</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="variable">$cursor</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-class">.puma-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/puma.png&#x27;</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">  <span class="attribute">cursor</span>: default; &#125;</span><br><span class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/sea-slug.png&#x27;</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid blue;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer; &#125;</span><br><span class="line"><span class="selector-class">.egret-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&#x27;/images/egret.png&#x27;</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid white;</span><br><span class="line">  <span class="attribute">cursor</span>: move; &#125;</span><br></pre></td></tr></table></figure></li><li><p>maps</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$header</span>, <span class="variable">$size</span> in (h1: <span class="number">2em</span>, h2: <span class="number">1.5em</span>, h3: <span class="number">1.2em</span>) &#123;</span><br><span class="line">  #&#123;<span class="variable">$header</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>; &#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.5em</span>; &#125;</span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="九-混合指令"><a class="markdownIt-Anchor" href="#九-混合指令"></a> 九、混合指令</h3><blockquote><p>混合指令（Mixin）用于定义可重复使用的样式，避免了使用无语意的 class，比如 <code>.float-left</code>。混合指令可以包含所有的 CSS 规则，绝大部分 Sass 规则，甚至通过参数功能引入变量，输出多样化的样式。</p></blockquote><p>注意：这不是函数！没有返回值！！</p><h4 id="1定义混合指令"><a class="markdownIt-Anchor" href="#1定义混合指令"></a> 1.定义混合指令</h4><p>混合指令的用法是在 <code>@mixin</code> 后添加名称与样式，以及需要的参数（可选）。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式：</span></span><br><span class="line"><span class="keyword">@mixin</span> name &#123;</span><br><span class="line">    <span class="comment">// 样式....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example：</span></span><br><span class="line"><span class="keyword">@mixin</span> large-text &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    family: Arial;</span><br><span class="line">    size: <span class="number">20px</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2引用混合样式"><a class="markdownIt-Anchor" href="#2引用混合样式"></a> 2.引用混合样式</h4><p>使用 <code>@include</code> 指令引用混合样式，格式是在其后添加混合名称，以及需要的参数（可选）。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式：</span></span><br><span class="line"><span class="keyword">@include</span> name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：无参数或参数都有默认值时，带不带括号都可以</span></span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example：</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> large-text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Arial;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3参数"><a class="markdownIt-Anchor" href="#3参数"></a> 3.参数</h4><p>格式：按照变量的格式，通过逗号分隔，将参数写进Mixin名称后的圆括号里</p><p>支持默认值；支持多参数；支持不定参数；支持位置传参和关键词传参</p><h5 id="a-位置传参"><a class="markdownIt-Anchor" href="#a-位置传参"></a> a. 位置传参</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> mp(<span class="variable">$width</span>) &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> mp(<span class="number">300px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b关键词传参"><a class="markdownIt-Anchor" href="#b关键词传参"></a> b.关键词传参</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> mp(<span class="variable">$width</span>) &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> mp(<span class="variable">$width</span>: <span class="number">300px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="c参数默认值"><a class="markdownIt-Anchor" href="#c参数默认值"></a> c.参数默认值</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> mp(<span class="variable">$width</span>: <span class="number">500px</span>) &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="variable">$width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> mp(<span class="variable">$width</span>: <span class="number">300px</span>);</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    <span class="keyword">@include</span> mp(<span class="number">300px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="d不定参数"><a class="markdownIt-Anchor" href="#d不定参数"></a> d.不定参数</h5><blockquote><p>官方：Variable Arguments</p><p>译文：参数变量</p><p>有时，不能确定混合指令需要使用多少个参数。这时，可以使用参数变量 <code>…</code> 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> mar(<span class="variable">$value</span>...) &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4向混合样式中导入内容"><a class="markdownIt-Anchor" href="#4向混合样式中导入内容"></a> 4.向混合样式中导入内容</h4><p>在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 <code>@content</code> 标志的地方</p><p>可以看作参数的升级版</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> example &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="keyword">@content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@include</span> example&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">  <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile:</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">html</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十-函数指令"><a class="markdownIt-Anchor" href="#十-函数指令"></a> 十、函数指令</h3><h4 id="1内置函数"><a class="markdownIt-Anchor" href="#1内置函数"></a> 1.内置函数</h4><h5 id="a-字符串函数"><a class="markdownIt-Anchor" href="#a-字符串函数"></a> a. 字符串函数</h5><blockquote><p>索引第一个为1，最后一个为-1；切片两边均为闭区间</p></blockquote><table><thead><tr><th style="text-align:left">函数名和参数类型</th><th style="text-align:center">函数作用</th></tr></thead><tbody><tr><td style="text-align:left">quote($string)</td><td style="text-align:center">添加引号</td></tr><tr><td style="text-align:left">unquote($string)</td><td style="text-align:center">除去引号</td></tr><tr><td style="text-align:left">to-lower-case($string)</td><td style="text-align:center">变为小写</td></tr><tr><td style="text-align:left">to-upper-case($string)</td><td style="text-align:center">变为大写</td></tr><tr><td style="text-align:left">str-length($string)</td><td style="text-align:center">返回$string的长度(汉字算一个)</td></tr><tr><td style="text-align:left">str-index(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">string，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">，</span></span></span></span>substring)</td><td style="text-align:center">返回<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">在</mi></mrow><annotation encoding="application/x-tex">substring在</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">在</span></span></span></span>string的位置</td></tr><tr><td style="text-align:left">str-insert($string, $insert, $index)</td><td style="text-align:center">在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">的</mi></mrow><annotation encoding="application/x-tex">string的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">的</span></span></span></span>index处插入$insert</td></tr><tr><td style="text-align:left">str-slice($string, $start-at, $end-at）</td><td style="text-align:center">截取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi mathvariant="normal">的</mi></mrow><annotation encoding="application/x-tex">string的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">的</span></span></span></span>start-at和$end-at之间的字符串</td></tr></tbody></table><h5 id="b-数字函数"><a class="markdownIt-Anchor" href="#b-数字函数"></a> b. 数字函数</h5><table><thead><tr><th>函数名和参数类型</th><th style="text-align:center">函数作用</th></tr></thead><tbody><tr><td>percentage($number)</td><td style="text-align:center">转换为百分比形式</td></tr><tr><td>round($number)</td><td style="text-align:center">四舍五入为整数</td></tr><tr><td>ceil($number)</td><td style="text-align:center">数值向上取整</td></tr><tr><td>floor($number)</td><td style="text-align:center">数值向下取整</td></tr><tr><td>abs($number)</td><td style="text-align:center">获取绝对值</td></tr><tr><td>min($number…)</td><td style="text-align:center">获取最小值</td></tr><tr><td>max($number…)</td><td style="text-align:center">获取最大值</td></tr><tr><td>random($number?:number)</td><td style="text-align:center">不传入值：获得0-1的随机数；传入正整数n：获得0-n的随机整数（左开右闭）</td></tr></tbody></table><h5 id="c-数组函数"><a class="markdownIt-Anchor" href="#c-数组函数"></a> c. 数组函数</h5><table><thead><tr><th>函数名和参数类型</th><th style="text-align:center">函数作用</th></tr></thead><tbody><tr><td>length($list)</td><td style="text-align:center">获取数组长度</td></tr><tr><td>nth($list, n)</td><td style="text-align:center">获取指定下标的元素</td></tr><tr><td>set-nth($list, $n, $value)</td><td style="text-align:center">向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">的</mi></mrow><annotation encoding="application/x-tex">list的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">的</span></span></span></span>n处插入$value</td></tr><tr><td>join($list1, $list2, $separator)</td><td style="text-align:center">拼接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mn>1</mn><mi mathvariant="normal">和</mi><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mn>2</mn><mi mathvariant="normal">；</mi></mrow><annotation encoding="application/x-tex">list1和list2；</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mord cjk_fallback">；</span></span></span></span>separator为新list的分隔符，默认为auto，可选择comma、space</td></tr><tr><td>append($list, $val, $separator)</td><td style="text-align:center">向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">末</mi><mi mathvariant="normal">尾</mi><mi mathvariant="normal">添</mi><mi mathvariant="normal">加</mi></mrow><annotation encoding="application/x-tex">list的末尾添加</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">末</span><span class="mord cjk_fallback">尾</span><span class="mord cjk_fallback">添</span><span class="mord cjk_fallback">加</span></span></span></span>val；$separator为新list的分隔符，默认为auto，可选择comma、space</td></tr><tr><td>index($list, $value)</td><td style="text-align:center">返回<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">在</mi></mrow><annotation encoding="application/x-tex">value值在</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">在</span></span></span></span>list中的索引值</td></tr><tr><td>zip($lists…)</td><td style="text-align:center">将几个列表结合成一个多维的列表；要求每个的列表个数值必须是相同的</td></tr></tbody></table><h5 id="d-映射函数"><a class="markdownIt-Anchor" href="#d-映射函数"></a> d. 映射函数</h5><table><thead><tr><th>函数名和参数类型</th><th style="text-align:center">函数作用</th></tr></thead><tbody><tr><td>map-get($map, $key)</td><td style="text-align:center">获取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">中</mi></mrow><annotation encoding="application/x-tex">map中</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">中</span></span></span></span>key对应的$value</td></tr><tr><td>map-merge($map1, $map2)</td><td style="text-align:center">合并<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mn>1</mn><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">map1和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord">1</span><span class="mord cjk_fallback">和</span></span></span></span>map2，返回一个新$map</td></tr><tr><td>map-remove($map, $key)</td><td style="text-align:center">从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">删</mi><mi mathvariant="normal">除</mi></mrow><annotation encoding="application/x-tex">map中删除</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">删</span><span class="mord cjk_fallback">除</span></span></span></span>key，返回一个新$map</td></tr><tr><td>map-keys($map)</td><td style="text-align:center">返回<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">的</mi></mrow><annotation encoding="application/x-tex">map所有的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">的</span></span></span></span>key</td></tr><tr><td>map-values($map)</td><td style="text-align:center">返回<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">的</mi></mrow><annotation encoding="application/x-tex">map所有的</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">的</span></span></span></span>value</td></tr><tr><td>map-has-key($map, $key)</td><td style="text-align:center">判断<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">否</mi><mi mathvariant="normal">存</mi><mi mathvariant="normal">在</mi></mrow><annotation encoding="application/x-tex">map中是否存在</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">否</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">在</span></span></span></span>key，返回对应的布尔值</td></tr><tr><td>keywords($args)</td><td style="text-align:center">返回一个函数的参数，并可以动态修改其值</td></tr></tbody></table><h5 id="e-颜色函数"><a class="markdownIt-Anchor" href="#e-颜色函数"></a> e. 颜色函数</h5><ul><li><p><strong>RGB函数</strong></p><table><thead><tr><th>函数名和参数类型</th><th style="text-align:center">函数作用</th></tr></thead><tbody><tr><td>rgb($red, $green, $blue)</td><td style="text-align:center">返回一个16进制颜色值</td></tr><tr><td>rgba(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>d</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">red,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mpunct">,</span></span></span></span>green,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">blue,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mpunct">,</span></span></span></span>alpha)</td><td style="text-align:center">返回一个rgba；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>d</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">red,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mpunct">,</span></span></span></span>green和$blue可被当作一个整体以颜色单词、hsl、rgb或16进制形式传入</td></tr><tr><td>red($color)</td><td style="text-align:center">从$color中获取其中红色值</td></tr><tr><td>green($color)</td><td style="text-align:center">从$color中获取其中绿色值</td></tr><tr><td>blue($color)</td><td style="text-align:center">从$color中获取其中蓝色值</td></tr><tr><td>mix(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mn>1</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">color1,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mpunct">,</span></span></span></span>color2,$weight?)</td><td style="text-align:center">按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">将</mi></mrow><annotation encoding="application/x-tex">weight比例，将</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">例</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">将</span></span></span></span>color1和$color2混合为一个新颜色</td></tr></tbody></table></li><li><p><strong>HSL函数</strong></p><table><thead><tr><th>函数名和参数类型</th><th>函数作用</th></tr></thead><tbody><tr><td>hsl(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">hue,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mpunct">,</span></span></span></span>saturation,$lightness)</td><td>通过色相（hue）、饱和度(saturation)和亮度（lightness）的值创建一个颜色</td></tr><tr><td>hsla(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">hue,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mpunct">,</span></span></span></span>saturation,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>n</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">lightness,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mpunct">,</span></span></span></span>alpha)</td><td>通过色相（hue）、饱和度(saturation)、亮度（lightness）和透明（alpha）的值创建一个颜色</td></tr><tr><td>saturation($color)</td><td>从一个颜色中获取饱和度（saturation）值</td></tr><tr><td>lightness($color)</td><td>从一个颜色中获取亮度（lightness）值</td></tr><tr><td>adjust-hue(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">color,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span></span></span></span>degrees)</td><td>通过改变一个颜色的色相值，创建一个新的颜色</td></tr><tr><td>lighten(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">color,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span></span></span></span>amount)</td><td>通过改变颜色的亮度值，让颜色变亮，创建一个新的颜色</td></tr><tr><td>darken(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">color,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span></span></span></span>amount)</td><td>通过改变颜色的亮度值，让颜色变暗，创建一个新的颜色</td></tr><tr><td>hue($color)</td><td>从一个颜色中获取亮度色相（hue）值</td></tr></tbody></table></li><li><p><strong>Opacity函数</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>alpha(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>o</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">color)/opacity(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span></span></span></span>color)</td><td>获取颜色透明度值</td></tr><tr><td>rgba(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>r</mi><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">color,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span></span></span></span>alpha)</td><td>改变颜色的透明度</td></tr><tr><td>opacify($color, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>f</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo>−</mo><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">amount) / fade-in(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span></span></span></span>color, $amount)</td><td>使颜色更不透明</td></tr><tr><td>transparentize($color, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>f</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo>−</mo><mi>o</mi><mi>u</mi><mi>t</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">amount) / fade-out(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mopen">(</span></span></span></span>color, $amount)</td><td>使颜色更加透明</td></tr></tbody></table></li></ul><h5 id="f-introspection函数"><a class="markdownIt-Anchor" href="#f-introspection函数"></a> f. Introspection函数</h5><table><thead><tr><th>函数名和参数类型</th><th style="text-align:center">函数作用</th></tr></thead><tbody><tr><td>type-of($value)</td><td style="text-align:center">返回$value的类型</td></tr><tr><td>unit($number)</td><td style="text-align:center">返回$number的单位</td></tr><tr><td>unitless($number)</td><td style="text-align:center">判断$number是否带单位，返回对应的布尔值</td></tr><tr><td>comparable($number1, $number2)</td><td style="text-align:center">判断<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mn>1</mn><mi mathvariant="normal">和</mi></mrow><annotation encoding="application/x-tex">number1和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mord cjk_fallback">和</span></span></span></span>number2是否可以做加、减和合并，返回对应的布尔值</td></tr></tbody></table><h4 id="2自定义函数"><a class="markdownIt-Anchor" href="#2自定义函数"></a> 2.自定义函数</h4><blockquote><p>Sass 支持自定义函数，并能在任何属性值或 Sass script 中使用</p><p>Params: 与Mixin一致</p><p>支持返回值</p></blockquote><p><strong>基本格式：</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@function</span> fn-name(<span class="variable">$params</span>...) &#123;</span><br><span class="line">    <span class="keyword">@return</span> <span class="variable">$params</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example:</span></span><br><span class="line"><span class="keyword">@function</span> fn-name(<span class="variable">$params</span>...) &#123;</span><br><span class="line">    <span class="keyword">@return</span> nth(<span class="variable">$params</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: fn-name(<span class="number">1px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiled:</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十一-细节与展望"><a class="markdownIt-Anchor" href="#十一-细节与展望"></a> 十一、细节与展望</h3><h4 id="1细节"><a class="markdownIt-Anchor" href="#1细节"></a> 1.细节</h4><p>a. @extend、@Mixin和@function的选择</p><p><a href="https://csswizardry.com/2016/02/mixins-better-for-performance/">原文链接</a></p><p><img src="https://raw.githubusercontent.com/ggdream/scss/master/sources.assets/image-20200707171035353.png" alt="image-20200707171035353" /></p><blockquote><p><code>minxins</code>在网络传输中比<code>@extend</code> 拥有更好的性能.尽管有些文件未压缩时更大，但使用<code>gzip</code>压缩后，依然可以保证我们拥有更好的性能。</p></blockquote><p><strong>所以@extend我们就尽量不要使用了，而@Mixin和@function的差别在定义和使用上</strong></p><blockquote><p>定义方式不同： <code>@function</code> 需要调用<code>@return</code>输出结果。而 @mixin则不需要。</p><p>使用方式不同：<code>@mixin</code> 使用<code>@include</code>引用，而 <code>@function</code> 使用小括号执行函数。</p></blockquote><h4 id="2展望"><a class="markdownIt-Anchor" href="#2展望"></a> 2.展望</h4><blockquote><p>以上内容算是&quot;基础&quot;部分，但是对于日常开发，我觉得是足够使用的了。</p><p>如果想要进一步了解，就必须先去学习下Ruby，使用Ruby相关模块进行更丰富地学习</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;css-预处理器的由来&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#css-预处理器的由来&quot;&gt;&lt;/a&gt; CSS 预处理器的由来&lt;/h2&gt;
&lt;p&gt;CSS 语言本身存在如下缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；&lt;/li&gt;
&lt;li&gt;没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;css-预处理器是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#css-预处理器是什么&quot;&gt;&lt;/a&gt; CSS 预处理器是什么？&lt;/h2&gt;
&lt;p&gt;CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题。 比如说：Sass（SCSS）、LESS、Stylus、Turbine 等等都属于 CSS 预处理器。&lt;/p&gt;</summary>
    
    
    
    <category term="CSS 世界" scheme="http://kyleezhang.com/categories/CSS-%E4%B8%96%E7%95%8C/"/>
    
    
    <category term="CSS" scheme="http://kyleezhang.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的数组</title>
    <link href="http://kyleezhang.com/2021/06/02/javascript-array/"/>
    <id>http://kyleezhang.com/2021/06/02/javascript-array/</id>
    <published>2021-06-02T16:29:07.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<p>数组在任何一门编程语言中都是一个最常见的词，它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。其作为数据结构的官方定义如下所示：</p><blockquote><p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p></blockquote><p>这其中有几个关键词</p><ul><li>线性表：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。</li><li>连续的内存空间与相同的类型数据：这两个特点赋予了数组结构最为核心的特性：随机访问性。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</li></ul><a id="more"></a><p>那么数组结构是如何实现随机访问性的呢？</p><p>我们拿一个长度为 10 的 int 类型的数组 <code>int[] a = new int[10]</code> 来举例。在我画的这个图中，计算机给数组 <code>a[10]</code>，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p><img src="/assets/javascript-array/01.jpeg" width="600" /><p>计算机给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>其中 data_type_size 表示数组中每个元素的大小。</p><p>因此数组结构拥有一个其他数据结构都无法比拟的核心特性：<strong>在确定数组下标的前提性可以直接访问数组元素，即数组结构访问元素的时间复杂度为O(1)</strong>，当然与之相对的数组结构的删除数据和插入数据都显得极为低效，我们首先来看插入操作，假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位，操作的具体复杂度随 k 的不同，如果 k 为 1 需要移动 n个元素，如果 k 为 2 则需要移动 n-1 个元素，…，事实上数组插入的平均时间复杂度为O(n)。</p><p>跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p><p>那么 JavaScript 中的数组（Array）概念是否与数组结构相同呢？事实上<strong>完全不一样！！！</strong>，JavaScript 中的数组本质上是对象，它依然属于 key-value 的结构，因此 JavaScript 中的数组在<strong>内存空间上不是连续（contiguous）的</strong>，在不同的平台（比如不同浏览器端）可以使用不同的数据结构来实现，比如链表。与此同时由于 JavaScript 本身是一门弱类型语言，因此 JavaScript 中的数组<strong>也不仅仅支持一种类型数据</strong>，这也是 JavaScript 中数组与很多编程语言如 C、C++、C# 的数组不同的地方，那么我们应该怎么理解 JavaScript 中的数组呢？</p><p>其实 JavaScript 中的数组本质上单纯只是编程语言的数据类型，它本身与数据结构中的数组并不等价，其具体实现依然是 key-value 键值对结构，与普通对象不同的是它的 key 只能是索引属性，即数字 1，2，3…，显而易见，读取目标位置的具体元素、删除目标元素等操作真实的数组结构相较于这种不连续内存的实现都有太多的优越性，而且随着计算机硬件的不断发展计算机内存也有了极大的提升，因此现代浏览器在具体实现 Javascript 中的数组时都采用了不同的性能优化手段，我们以 Chrome 浏览器为例：</p><p>在 Chrome 的 V8 引擎中它有两种存储方式，快数组与慢数组，初始化空数组时，使用快数组，快数组使用连续的内存空间，当数组长度达到最大时，JSArray 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。当数组中 hole 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。（关于 v8 引擎中对象的具体存储实现可以查看我的博客<a href="https://kyleezhang.github.io/2020/10/25/client-v8-01/">V8是怎么提升对象属性访问速度的</a>）。</p><p>为了对比介绍 V8 实现的这些优化我需要介绍 ES6 引入的类型化数组（Typed Arrays），它给我们提供了访问原始二进制数据的能力，了解更多可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays">MDN 文档</a>。JavaScript 类型数组（Typed Arrays）将实现拆分为缓冲和视图两部分。一个缓冲（由 ArrayBuffer 对象实现）描述的是一个数据块。缓冲没有格式可言，并且不提供机制访问其内容。为了访问在缓冲对象中包含的内存，你需要使用视图。视图提供了上下文 — 即数据类型、起始偏移量和元素数 — 将数据转换为实际有类型的数组。举个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> view   = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buffer);</span><br><span class="line">view[<span class="number">0</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>好，接下来我们来验证 V8 引擎对于 JavaScript 中数组操作能力的具体提升，首先是数据插入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LIMIT = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(LIMIT);</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;Array insertion time&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; LIMIT; i++) &#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;Array insertion time&quot;</span>); <span class="comment">// Array insertion time: 21.74169921875 ms</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LIMIT = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(LIMIT * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buffer);</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;ArrayBuffer insertion time&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; LIMIT; i++) &#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;ArrayBuffer insertion time&quot;</span>); <span class="comment">// ArrayBuffer insertion time: 23.27978515625 ms</span></span><br></pre></td></tr></table></figure><p>示例中旧式数组和 ArrayBuffer 的性能不相上下，这是因为 Chrome 已经自动得将将元素类型相同的传统数组在内部转换成内存连续的数组。第一个例子正是如此。尽管使用了 new Array(LIMIT)，但实际实现上依然采用了数组的数据结构，被分配了连续的内存空间，我们接下来修改其实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LIMIT = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(LIMIT);</span><br><span class="line">arr.push(&#123;<span class="attr">a</span>: <span class="number">22</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;Array insertion time&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; LIMIT; i++) &#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;Array insertion time&quot;</span>); <span class="comment">// Array insertion time: 697.494140625 ms</span></span><br></pre></td></tr></table></figure><p>这儿我们在第三行改变了数组元素，使元素不再是单一数据类型，我们观察到其执行时间发生了巨大变化，这是因为 arr 数组不再具有数组结构的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的。我们可以通过查看其内存快照来验证：</p><img src="/assets/javascript-array/02.png" width="600" /><p>我们接着来验证数据的读取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LIMIT = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(LIMIT);</span><br><span class="line">arr.push(&#123;<span class="attr">a</span>: <span class="number">22</span>&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; LIMIT; i++) &#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;Array read time&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; LIMIT; i++) &#123;</span><br><span class="line"><span class="comment">//arr[i] = i;</span></span><br><span class="line">p = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;Array read time&quot;</span>); <span class="comment">// Array read time: 18.0458984375 ms</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LIMIT = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(LIMIT * <span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buffer);</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;ArrayBuffer insertion time&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; LIMIT; i++) &#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;ArrayBuffer read time&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; LIMIT; i++) &#123;</span><br><span class="line"><span class="keyword">var</span> p = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;ArrayBuffer read time&quot;</span>); <span class="comment">// ArrayBuffer read time: 27.92626953125 ms</span></span><br></pre></td></tr></table></figure><p>总结：我们平时在创建和使用 Javascript 中的数组时应尽可能使用同种数据类型，以方便浏览器对其性能进行优化，另外不由得感叹一句谷歌大佬们真的牛逼，，，，</p><p>参考资料：</p><p>极客时间《数据结构与算法之美》专栏</p><p><a href="https://www.wemlion.com/post/javascript-array-evolution-performance/">深入 JavaScript 数组：进化与性能</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组在任何一门编程语言中都是一个最常见的词，它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。其作为数据结构的官方定义如下所示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这其中有几个关键词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性表：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。&lt;/li&gt;
&lt;li&gt;连续的内存空间与相同的类型数据：这两个特点赋予了数组结构最为核心的特性：随机访问性。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="深入理解 JavaScript" scheme="http://kyleezhang.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://kyleezhang.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>从vue-cli到Vue CLI（二）</title>
    <link href="http://kyleezhang.com/2021/05/15/vue-cli-02/"/>
    <id>http://kyleezhang.com/2021/05/15/vue-cli-02/</id>
    <published>2021-05-15T12:00:35.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue-cli"><a class="markdownIt-Anchor" href="#vue-cli"></a> Vue CLI</h2><p>vue-cli 在 3.0 版本进行了彻底的重构，为了区别也将其普遍称为 Vue CLI，是目前 Vue 官方推荐的 Vue 项目快速开发的完整系统，它基于 Webpack 实现，提供了终端命令行工具、零配置脚手架、插件体系、图形化管理界面等诸多功能，近乎提供了前端项目工程化的所有步骤的完整工具链，也是当前 Vue 项目构建的主流工具。</p><h3 id="一-整体架构"><a class="markdownIt-Anchor" href="#一-整体架构"></a> 一、整体架构</h3><p>vue-cli 为了尽可能覆盖项目工程化需求所以模版项目往往引入了大量第三方库，但实际开发过程中开发者可能并不需要这些功能模块，虽然可以通过在模版项目的 meta.js 或 meta.json 文件配置 prompts 在命令行交互然后在 filterFiles 函数中对生成项目的文件目录结构进行筛选，但是依然可配置性不强，会存在较多冗余依赖或功能，并且依赖项的升级极为痛苦，因此为了给开发者提供更灵活的配置能力 Vue CLI 实现了一种极为巧妙的架构设计：</p><a id="more"></a><img src="/assets/vue-cli/05.png" width="400" /><p>如上图所示，Vue CLI 的最新架构主要由如下模块构成：</p><p>1、@vue/cli: 首先我们会在全局安装一个@vue/cli，其为我们提供了一系列 vue 命令，例如我们最常用 vue create、vue add 指令等等。@vue/cli 本质上依然是脚手架工具，主要通过 CLI 交互自动化创建项目基础结构，具体步骤为：</p><ul><li>准备命令行交互的问题</li><li>根据用户的回答决定是否使用某个插件（内置）</li><li>调用 npm/yarn 自动在项目本地安装这些插件</li><li>调用每个插件内部的 generator 方法</li><li>generator 内部创建所有文件</li></ul><p>2、@vue/cli-service: 如果说 @vue/cli 的主要作用是项目的生成，那么 @vue/cli-service 才是开发者日常开发的真正核心，为我们提供了 Vue.js 开发环境的 CLI 服务（本地测试、生产环境构建等等），因此它提供的主要功能点如下所示：</p><ul><li>提供了一个适用于大多数 Vue.js 项目的 Webpack 配置，并且内部只做最通用的配置。</li><li>把 Webpack 与 Webpack Dev Server 封装进内部，提供 server &amp; build 命令。</li><li>加载其他 CLI 插件内部的核心服务。</li></ul><p>3、@vue/cli-plugin-xxx: 个人觉得 Vue CLI 设计最出彩的地方就在于插件机制，项目本身创建最开始的时候只是根据用户在命令行的交互问题生成 package.json，然后根据所拥有的模块动态完成 Webpack 的配置并生成项目结构，因此 Vue CLI 的插件模块主要完成如下功能：</p><ul><li>提供了个性化的 Webpack 配置，让构建过程支持不同的技术选型</li><li>提供了 Generator 用于生成项目中所需的文件</li><li>提供了额外的 Command 用于实现扩展功能，例如 cli-plugin-eslint 插件中提供了 lint 子命令</li></ul><p>下面我们开始详细分析每一个模块来查看其功能的具体实现：</p><img src="/assets/emoji/03.png" width="260" /><h3 id="二-vuecli"><a class="markdownIt-Anchor" href="#二-vuecli"></a> 二、@vue/cli</h3><p>@vue/cli 主要为我们提供了一系列 vue 命令，具体如下图所示：</p><img src="/assets/vue-cli/06.png" width="800" /><p>这些指令都是在 <code>@vue/cli/bin/vue.js</code> 文件中通过 command 库的 command 方法指定的，此处比较有意思的是 @vue/cli 提供了 suggestCommands 函数，用于对用户在命令行的错误输入分析并给出猜测指令，具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @vue/cli/bin/vue.js</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// output help information on unknown commands</span></span><br><span class="line"><span class="comment">// 如果不是前文已挂载的命令开始执行如下函数</span></span><br><span class="line">program.on(<span class="string">&#x27;command:*&#x27;</span>, <span class="function">(<span class="params">[cmd]</span>) =&gt;</span> &#123;</span><br><span class="line">  program.outputHelp()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`  `</span> + chalk.red(<span class="string">`Unknown command <span class="subst">$&#123;chalk.yellow(cmd)&#125;</span>.`</span>))</span><br><span class="line">  <span class="built_in">console</span>.log()</span><br><span class="line">  suggestCommands(cmd)</span><br><span class="line">  process.exitCode = <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 猜测用户意图</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">suggestCommands</span> (<span class="params">unknownCommand</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> availableCommands = program.commands.map(<span class="function"><span class="params">cmd</span> =&gt;</span> cmd._name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> suggestion</span><br><span class="line"></span><br><span class="line">  availableCommands.forEach(<span class="function"><span class="params">cmd</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isBestMatch = leven(cmd, unknownCommand) &lt; leven(suggestion || <span class="string">&#x27;&#x27;</span>, unknownCommand)</span><br><span class="line">    <span class="keyword">if</span> (leven(cmd, unknownCommand) &lt; <span class="number">3</span> &amp;&amp; isBestMatch) &#123;</span><br><span class="line">      suggestion = cmd</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (suggestion) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`  `</span> + chalk.red(<span class="string">`Did you mean <span class="subst">$&#123;chalk.yellow(suggestion)&#125;</span>?`</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用了 leven 了这个包，这是用于计算字符串编辑距离算法的 JS 实现，Vue CLI 这里使用了这个包，来分别计算输入的命令和当前已挂载的所有命令的编辑举例，从而猜测用户实际想输入的命令是哪个。一个简单功能的实现，但极大程度地提升了用户体验👍。</p><p>首先我们开始分析项目创建最核心的 create 命令：</p><h4 id="1-create-命令"><a class="markdownIt-Anchor" href="#1-create-命令"></a> 1、create 命令</h4><p>我们首先查看 create 命令的入口：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/@vue/cli/bin/vue.js</span></span><br><span class="line">program</span><br><span class="line">  .command(<span class="string">&#x27;create &lt;app-name&gt;&#x27;</span>)</span><br><span class="line">  .description(<span class="string">&#x27;create a new project powered by vue-cli-service&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-p, --preset &lt;presetName&gt;&#x27;</span>, <span class="string">&#x27;Skip prompts and use saved or remote preset&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-d, --default&#x27;</span>, <span class="string">&#x27;Skip prompts and use default preset&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-i, --inlinePreset &lt;json&gt;&#x27;</span>, <span class="string">&#x27;Skip prompts and use inline JSON string as preset&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-m, --packageManager &lt;command&gt;&#x27;</span>, <span class="string">&#x27;Use specified npm client when installing dependencies&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-r, --registry &lt;url&gt;&#x27;</span>, <span class="string">&#x27;Use specified npm registry when installing dependencies (only for npm)&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-g, --git [message]&#x27;</span>, <span class="string">&#x27;Force git initialization with initial commit message&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-n, --no-git&#x27;</span>, <span class="string">&#x27;Skip git initialization&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-f, --force&#x27;</span>, <span class="string">&#x27;Overwrite target directory if it exists&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-c, --clone&#x27;</span>, <span class="string">&#x27;Use git clone when fetching remote preset&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-x, --proxy&#x27;</span>, <span class="string">&#x27;Use specified proxy when creating project&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;-b, --bare&#x27;</span>, <span class="string">&#x27;Scaffold project without beginner instructions&#x27;</span>)</span><br><span class="line">  .action(<span class="function">(<span class="params">name, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minimist(process.argv.slice(<span class="number">3</span>))._.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(chalk.yellow(<span class="string">&#x27;\n Info: You provided more than one argument. The first one will be used as the app\&#x27;s name, the rest are ignored.&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --git makes commander to default git to true</span></span><br><span class="line">    <span class="keyword">if</span> (process.argv.includes(<span class="string">&#x27;-g&#x27;</span>) || process.argv.includes(<span class="string">&#x27;--git&#x27;</span>)) &#123;</span><br><span class="line">      options.forceGit = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;../lib/create&#x27;</span>)(name, options)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>上述参数的具体作用如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-p, --preset &lt;presetName&gt;       忽略提示符并使用已保存的或远程的预设选项</span><br><span class="line">-d, --default                   忽略提示符并使用默认预设选项</span><br><span class="line">-i, --inlinePreset &lt;json&gt;       忽略提示符并使用内联的 JSON 字符串预设选项</span><br><span class="line">-m, --packageManager &lt;<span class="built_in">command</span>&gt;  在安装依赖时使用指定的 npm 客户端</span><br><span class="line">-r, --registry &lt;url&gt;            在安装依赖时使用指定的 npm registry</span><br><span class="line">-g, --git [message]             强制 / 跳过 git 初始化，并可选的指定初始化提交信息</span><br><span class="line">-n, --no-git                    跳过 git 初始化</span><br><span class="line">-f, --force                     覆写目标目录可能存在的配置</span><br><span class="line">-c, --<span class="built_in">clone</span>                     使用 git <span class="built_in">clone</span> 获取远程预设选项</span><br><span class="line">-x, --proxy                     使用指定的代理创建项目</span><br><span class="line">-b, --bare                      创建项目时省略默认组件中的新手指导信息</span><br><span class="line">-h, --<span class="built_in">help</span>                      输出使用帮助信息</span><br></pre></td></tr></table></figure><p>具体的执行则主要是调用了 <code>../lib/create.js</code> 文件暴露出的 create 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">projectName, options</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (options.proxy) &#123;</span><br><span class="line">    process.env.HTTP_PROXY = options.proxy <span class="comment">// 根据用户是否配置 proxy 项创建环境变量 HTTP_PROXY</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cwd = options.cwd || process.cwd() <span class="comment">// 当前目录</span></span><br><span class="line">  <span class="keyword">const</span> inCurrent = projectName === <span class="string">&#x27;.&#x27;</span> <span class="comment">// 是否在当前目录</span></span><br><span class="line">  <span class="keyword">const</span> name = inCurrent ? path.relative(<span class="string">&#x27;../&#x27;</span>, cwd) : projectName <span class="comment">// 项目名称</span></span><br><span class="line">  <span class="keyword">const</span> targetDir = path.resolve(cwd, projectName || <span class="string">&#x27;.&#x27;</span>) <span class="comment">// 生成项目的目录</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = validateProjectName(name) <span class="comment">// 调用 validate-npm-package-name 库校验项目名称</span></span><br><span class="line">  <span class="keyword">if</span> (!result.validForNewPackages) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(chalk.red(<span class="string">`Invalid project name: &quot;<span class="subst">$&#123;name&#125;</span>&quot;`</span>))</span><br><span class="line">    result.errors &amp;&amp; result.errors.forEach(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(chalk.red.dim(<span class="string">&#x27;Error: &#x27;</span> + err))</span><br><span class="line">    &#125;)</span><br><span class="line">    result.warnings &amp;&amp; result.warnings.forEach(<span class="function"><span class="params">warn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(chalk.red.dim(<span class="string">&#x27;Warning: &#x27;</span> + warn))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此处代码主要用于项目生成路径的判断，主要是当存在相同项目目录的时候调用 inquirer.prompt 来询问是否要 Overwrite || Merge || Cancel，当带有 -f || --force 的时候会跳过这些交互，即 options force = true</span></span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(targetDir) &amp;&amp; !options.merge) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options.force) &#123;</span><br><span class="line">      <span class="keyword">await</span> fs.remove(targetDir)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> clearConsole()</span><br><span class="line">      <span class="keyword">if</span> (inCurrent) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; ok &#125; = <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">            type: <span class="string">&#x27;confirm&#x27;</span>,</span><br><span class="line">            message: <span class="string">`Generate project in current directory?`</span></span><br><span class="line">          &#125;</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; action &#125; = <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">          &#123;</span><br><span class="line">            name: <span class="string">&#x27;action&#x27;</span>,</span><br><span class="line">            type: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">            message: <span class="string">`Target directory <span class="subst">$&#123;chalk.cyan(targetDir)&#125;</span> already exists. Pick an action:`</span>,</span><br><span class="line">            choices: [</span><br><span class="line">              &#123; <span class="attr">name</span>: <span class="string">&#x27;Overwrite&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;overwrite&#x27;</span> &#125;,</span><br><span class="line">              &#123; <span class="attr">name</span>: <span class="string">&#x27;Merge&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;merge&#x27;</span> &#125;,</span><br><span class="line">              &#123; <span class="attr">name</span>: <span class="string">&#x27;Cancel&#x27;</span>, <span class="attr">value</span>: <span class="literal">false</span> &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">if</span> (!action) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action === <span class="string">&#x27;overwrite&#x27;</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`\nRemoving <span class="subst">$&#123;chalk.cyan(targetDir)&#125;</span>...`</span>)</span><br><span class="line">          <span class="keyword">await</span> fs.remove(targetDir)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> creator = <span class="keyword">new</span> Creator(name, targetDir, getPromptModules())</span><br><span class="line">  <span class="keyword">await</span> creator.create(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> create(...args).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="comment">// 捕获内部所有抛出的错误，将当前的 spinner  状态停止，退出进程。</span></span><br><span class="line">    stopSpinner(<span class="literal">false</span>) <span class="comment">// do not persist</span></span><br><span class="line">    error(err)</span><br><span class="line">    <span class="keyword">if</span> (!process.env.VUE_CLI_TEST) &#123;</span><br><span class="line">      process.exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处经过认真的代码分析我们成功发现真正实现的核心都在 <code>../lib/Creator</code> 的 Creator 类中😓，，，但是这儿 getPromptModules 方法的作用是什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.getPromptModules = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    <span class="string">&#x27;vueVersion&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;babel&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;typescript&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;pwa&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;router&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;vuex&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;cssPreprocessors&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;linter&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;unit&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;e2e&#x27;</span></span><br><span class="line">  ].map(<span class="function"><span class="params">file</span> =&gt;</span> <span class="built_in">require</span>(<span class="string">`../promptModules/<span class="subst">$&#123;file&#125;</span>`</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getPromptModules 函数主要用于 <code>../promptModules/</code> 文件夹下不同配置文件内容的读取，我们以 <code>../promptModules/unit.js</code> 为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//../promptModules/unit.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">cli</span> =&gt;</span> &#123;</span><br><span class="line">  cli.injectFeature(&#123;</span><br><span class="line">    name: <span class="string">&#x27;Unit Testing&#x27;</span>,</span><br><span class="line">    value: <span class="string">&#x27;unit&#x27;</span>,</span><br><span class="line">    short: <span class="string">&#x27;Unit&#x27;</span>,</span><br><span class="line">    description: <span class="string">&#x27;Add a Unit Testing solution like Jest or Mocha&#x27;</span>,</span><br><span class="line">    link: <span class="string">&#x27;https://cli.vuejs.org/config/#unit-testing&#x27;</span>,</span><br><span class="line">    plugins: [<span class="string">&#x27;unit-jest&#x27;</span>, <span class="string">&#x27;unit-mocha&#x27;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  cli.injectPrompt(&#123;</span><br><span class="line">    name: <span class="string">&#x27;unit&#x27;</span>,</span><br><span class="line">    when: <span class="function"><span class="params">answers</span> =&gt;</span> answers.features.includes(<span class="string">&#x27;unit&#x27;</span>),</span><br><span class="line">    type: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">    message: <span class="string">&#x27;Pick a unit testing solution:&#x27;</span>,</span><br><span class="line">    choices: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">&#x27;Jest&#x27;</span>,</span><br><span class="line">        value: <span class="string">&#x27;jest&#x27;</span>,</span><br><span class="line">        short: <span class="string">&#x27;Jest&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">&#x27;Mocha + Chai (requires webpack 4)&#x27;</span>,</span><br><span class="line">        value: <span class="string">&#x27;mocha&#x27;</span>,</span><br><span class="line">        short: <span class="string">&#x27;Mocha&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  cli.onPromptComplete(<span class="function">(<span class="params">answers, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (answers.unit === <span class="string">&#x27;mocha&#x27;</span>) &#123;</span><br><span class="line">      options.plugins[<span class="string">&#x27;@vue/cli-plugin-unit-mocha&#x27;</span>] = &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (answers.unit === <span class="string">&#x27;jest&#x27;</span>) &#123;</span><br><span class="line">      options.plugins[<span class="string">&#x27;@vue/cli-plugin-unit-jest&#x27;</span>] = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cli.injectFeature</code> 是注入 featurePrompt，即初始化项目时选择的勾选项如 babel，typescript，pwa 等等，如下图：</p><img src="/assets/vue-cli/07.png" width="500" /><p><code>cli.injectPrompt</code> 是根据选择的 featurePrompt 然后注入对应的 prompt，当选择了 unit，接下来会有以下的 prompt，选择 Mocha + Chai 还是 Jest：</p><img src="/assets/vue-cli/08.png" width="500" /><p><code>cli.onPromptComplete</code> 就是一个回调，会根据选择来添加对应的插件， 当选择了 mocha ，那么就会添加 @vue/cli-plugin-unit-mocha 插件。</p><p>接下来我们开始正式查看 Creator 类，打开一看，哦豁，554 行代码，12 个引入模块，告辞！</p><p>考虑到大家时间比较紧张（wo bi jiao lan）这儿梳理一下主要流程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Creator</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, context, promptModules</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.context = process.env.VUE_CLI_CONTEXT = context</span><br><span class="line">    <span class="comment">// 获取了 preset 和 feature 的交互选择列表，在 vue create 命令初始化项目的时候提供选择</span></span><br><span class="line">    <span class="keyword">const</span> &#123; presetPrompt, featurePrompt &#125; = <span class="built_in">this</span>.resolveIntroPrompts()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.presetPrompt = presetPrompt <span class="comment">// preset 列表</span></span><br><span class="line">    <span class="built_in">this</span>.featurePrompt = featurePrompt <span class="comment">// pwa、babel、e2e等等</span></span><br><span class="line">    <span class="comment">// 存放项目配置的文件（package.json || congfig.js） 以及是否将 presetPrompts 存放起来</span></span><br><span class="line">    <span class="built_in">this</span>.outroPrompts = <span class="built_in">this</span>.resolveOutroPrompts()</span><br><span class="line">    <span class="built_in">this</span>.outroPrompts = [] <span class="comment">// 对应 feature 的 Prompts</span></span><br><span class="line">    <span class="comment">// 不同阶段回调函数列表</span></span><br><span class="line">    <span class="built_in">this</span>.promptCompleteCbs = []</span><br><span class="line">    <span class="built_in">this</span>.afterInvokeCbs = []</span><br><span class="line">    <span class="built_in">this</span>.afterAnyInvokeCbs = []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.run = <span class="built_in">this</span>.run.bind(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> promptAPI = <span class="keyword">new</span> PromptModuleAPI(<span class="built_in">this</span>)</span><br><span class="line">    promptModules.forEach(<span class="function"><span class="params">m</span> =&gt;</span> m(promptAPI))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿我们首先注意到构造函数中分别为实例对象添加了 presetPrompt、featurePrompt、outroPrompts、outroPrompts 等各种各样的 “prompt” 属性，那么它们之间有什么区别，又分别代表了什么呢？</p><ul><li>presetPrompt： 预设选项 prompt，加入上次以 Manually 模式进行了预设选项，并且保存到了 ~/.vuerc 中，那么在初始化项目时就会列出已经保存的 preset，并提供选择。</li><li>featurePrompt：项目的一些 feature，就是选择 babel，typescript，pwa，router，vuex，cssPreprocessors，linter，unit，e2e。</li><li>injectedPrompts：当选择了 feature 后，就会为对应的 feature 注入 prompts，比如你选择了 unit，那么就会让你选择模式： Mocha + Chai 还是 Jest</li><li>outroPrompts： 其他的 prompt，包含：<ul><li>将 Babel, PostCSS, ESLint 等等的配置文件存放在 package.json 中还是存放在 config 文件中；</li><li>是否需要将这次设置的 preset 保存到本地，如果需要则会进一步让你输入名称进行保存；</li><li>安装依赖是选择 npm 还是 yarn。</li></ul></li></ul><p>再搞清了 “prompt” 之间的区别后我们接着往下看 PromptModuleAPI，其源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">PromptModuleAPI</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">creator</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.creator = creator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  injectFeature (feature) &#123;</span><br><span class="line">    <span class="built_in">this</span>.creator.featurePrompt.choices.push(feature)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  injectPrompt (prompt) &#123;</span><br><span class="line">    <span class="built_in">this</span>.creator.injectedPrompts.push(prompt)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  injectOptionForPrompt (name, option) &#123;</span><br><span class="line">    <span class="built_in">this</span>.creator.injectedPrompts.find(<span class="function"><span class="params">f</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> f.name === name</span><br><span class="line">    &#125;).choices.push(option)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onPromptComplete (cb) &#123;</span><br><span class="line">    <span class="built_in">this</span>.creator.promptCompleteCbs.push(cb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PromptModuleAPI 实例会调用它的实例方法，然后将 injectFeature，injectPrompt，injectOptionForPrompt，onPromptComplete 保存到 Creator 实例对应的变量中。最后遍历前面 getPromptModules 获取的 promptModules，传入实例 promptAPI，初始化 Creator 实例中 featurePrompt, injectedPrompts, promptCompleteCbs 变量。</p><p>在 <code>../lib/create.js</code> 文件中的 create 方法中我们生成 Creator 实例后调用了其 create 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> creator.create(options)</span><br></pre></td></tr></table></figure><p>因此我们接着查看 create 方法的具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> create (cliOptions = &#123;&#125;, preset = <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isTestOrDebug = process.env.VUE_CLI_TEST || process.env.VUE_CLI_DEBUG</span><br><span class="line">  <span class="keyword">const</span> &#123; run, name, context, afterInvokeCbs, afterAnyInvokeCbs &#125; = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!preset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cliOptions.preset) &#123;</span><br><span class="line">      <span class="comment">// vue create foo --preset bar</span></span><br><span class="line">      preset = <span class="keyword">await</span> <span class="built_in">this</span>.resolvePreset(cliOptions.preset, cliOptions.clone)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cliOptions.default) &#123;</span><br><span class="line">      <span class="comment">// vue create foo --default</span></span><br><span class="line">      preset = defaults.presets.default</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cliOptions.inlinePreset) &#123;</span><br><span class="line">      <span class="comment">// vue create foo --inlinePreset &#123;...&#125;</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        preset = <span class="built_in">JSON</span>.parse(cliOptions.inlinePreset)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        error(<span class="string">`CLI inline preset is not valid JSON: <span class="subst">$&#123;cliOptions.inlinePreset&#125;</span>`</span>)</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      preset = <span class="keyword">await</span> <span class="built_in">this</span>.promptAndResolvePreset()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clone before mutating</span></span><br><span class="line">  preset = cloneDeep(preset)</span><br><span class="line">  <span class="comment">// inject core service</span></span><br><span class="line">  preset.plugins[<span class="string">&#x27;@vue/cli-service&#x27;</span>] = <span class="built_in">Object</span>.assign(&#123; <span class="comment">// 注入核心 @vue/cli-service</span></span><br><span class="line">    projectName: name</span><br><span class="line">  &#125;, preset, &#123;</span><br><span class="line">    bare: cliOptions.bare</span><br><span class="line">  &#125;)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断 vue create 命令是否带有 -p 选项，如果有的话会调用 resolvePreset 去解析 preset。resolvePreset 函数会先获取 <code>～/.vuerc</code> 中保存的 preset， 然后进行遍历，如果里面包含了 -p 中的 <code>&lt;presetName&gt;</code>，则返回 <code>～/.vuerc</code> 中的 preset。如果没有则判断是否是采用内联的 JSON 字符串预设选项，如果是就会解析 <code>.json</code> 文件，并返回 preset，还有一种情况就是从远程获取 preset（利用 download-git-repo 下载远程的 preset.json 并返回。</p><p>如果 vue create 命令没有带有 -p 选项就会调用 promptAndResolvePreset 函数利用 inquirer.prompt 以命令后交互的形式来获取 preset，下面看下 promptAndResolvePreset 函数的源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> promptAndResolvePreset (answers = <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// prompt</span></span><br><span class="line">  <span class="keyword">if</span> (!answers) &#123;</span><br><span class="line">    <span class="keyword">await</span> clearConsole(<span class="literal">true</span>)</span><br><span class="line">    answers = <span class="keyword">await</span> inquirer.prompt(<span class="built_in">this</span>.resolveFinalPrompts())</span><br><span class="line">  &#125;</span><br><span class="line">  debug(<span class="string">&#x27;vue-cli:answers&#x27;</span>)(answers)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (answers.packageManager) &#123;</span><br><span class="line">    saveOptions(&#123;</span><br><span class="line">      packageManager: answers.packageManager</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> preset</span><br><span class="line">  <span class="keyword">if</span> (answers.preset &amp;&amp; answers.preset !== <span class="string">&#x27;__manual__&#x27;</span>) &#123;</span><br><span class="line">    preset = <span class="keyword">await</span> <span class="built_in">this</span>.resolvePreset(answers.preset)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// manual</span></span><br><span class="line">    preset = &#123;</span><br><span class="line">      useConfigFiles: answers.useConfigFiles === <span class="string">&#x27;files&#x27;</span>,</span><br><span class="line">      plugins: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    answers.features = answers.features || []</span><br><span class="line">    <span class="comment">// run cb registered by prompt modules to finalize the preset</span></span><br><span class="line">    <span class="built_in">this</span>.promptCompleteCbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(answers, preset))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// validate</span></span><br><span class="line">  validatePreset(preset)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// save preset</span></span><br><span class="line">  <span class="keyword">if</span> (answers.save &amp;&amp; answers.saveName &amp;&amp; savePreset(answers.saveName, preset)) &#123;</span><br><span class="line">    log()</span><br><span class="line">    log(<span class="string">`🎉  Preset <span class="subst">$&#123;chalk.yellow(answers.saveName)&#125;</span> saved in <span class="subst">$&#123;chalk.yellow(rcPath)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  debug(<span class="string">&#x27;vue-cli:preset&#x27;</span>)(preset)</span><br><span class="line">  <span class="keyword">return</span> preset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码首先利用 this.resolveFinalPrompts() 获取了最后的 prompts 并通过 inquirer.prompt 在命令行与用户交互，这儿的 resolveFinalPrompts 的实现如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">resolveFinalPrompts () &#123;</span><br><span class="line">  <span class="comment">// patch generator-injected prompts to only show in manual mode</span></span><br><span class="line">  <span class="comment">// 将所有的 Prompt 合并，包含 preset，feature，injected，outro，只有当选择了手动模式的时候才会显示 injectedPrompts</span></span><br><span class="line">  <span class="built_in">this</span>.injectedPrompts.forEach(<span class="function"><span class="params">prompt</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> originalWhen = prompt.when || (<span class="function">() =&gt;</span> <span class="literal">true</span>)</span><br><span class="line">    prompt.when = <span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> isManualMode(answers) &amp;&amp; originalWhen(answers)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prompts = [</span><br><span class="line">    <span class="built_in">this</span>.presetPrompt,</span><br><span class="line">    <span class="built_in">this</span>.featurePrompt,</span><br><span class="line">    ...this.injectedPrompts,</span><br><span class="line">    ...this.outroPrompts</span><br><span class="line">  ]</span><br><span class="line">  debug(<span class="string">&#x27;vue-cli:prompts&#x27;</span>)(prompts)</span><br><span class="line">  <span class="keyword">return</span> prompts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inquirer.prompt 执行完成后会返回 answers，如果选择了本地保存的 preset 或者 default，则调用 resolvePreset 进行解析 preset，否则遍历 promptCompleteCbs 执行 injectFeature 和 injectPrompt 的回调，将对应的插件赋值到 options.plugins 中，以 unit 为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cli.onPromptComplete(<span class="function">(<span class="params">answers, options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (answers.unit === <span class="string">&#x27;mocha&#x27;</span>) &#123;</span><br><span class="line">    options.plugins[<span class="string">&#x27;@vue/cli-plugin-unit-mocha&#x27;</span>] = &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (answers.unit === <span class="string">&#x27;jest&#x27;</span>) &#123;</span><br><span class="line">    options.plugins[<span class="string">&#x27;@vue/cli-plugin-unit-jest&#x27;</span>] = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果 feature 选择了 unit，并且 unit 模式选择的是 Mocha + Chai，则添加 @vue/cli-plugin-unit-mocha 插件，如果选择的是 Jest 则添加 @vue/cli-plugin-unit-jest 插件。</p><p>我们接着查看 create 方法在获取到 preset 之后，还会向 preset 的插件里面注入核心插件 <code>@vue/cli-service</code>， 它是调用 <code>vue-cli-service &lt;command&gt; [...args]</code> 时创建的类。 负责管理内部的 webpack 配置、暴露服务和构建项目的命令等。</p><p>至此我们已经完成了 vue create 命令执行过程中第一个要点：<strong>获取用户配置信息</strong>，并且根据配置信息获取了所需的插件，接下来便是另一个核心<strong>依赖的安装</strong>，我们来接着看 create 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> create (cliOptions = &#123;&#125;, preset = <span class="literal">null</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> packageManager = (</span><br><span class="line">    cliOptions.packageManager ||</span><br><span class="line">    loadOptions().packageManager ||</span><br><span class="line">    (hasYarn() ? <span class="string">&#x27;yarn&#x27;</span> : <span class="literal">null</span>) ||</span><br><span class="line">    (hasPnpm3OrLater() ? <span class="string">&#x27;pnpm&#x27;</span> : <span class="string">&#x27;npm&#x27;</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> clearConsole()</span><br><span class="line">  <span class="keyword">const</span> pm = <span class="keyword">new</span> PackageManager(&#123; context, <span class="attr">forcePackageManager</span>: packageManager &#125;)</span><br><span class="line"></span><br><span class="line">  log(<span class="string">`✨  Creating project in <span class="subst">$&#123;chalk.yellow(context)&#125;</span>.`</span>)</span><br><span class="line">  <span class="built_in">this</span>.emit(<span class="string">&#x27;creation&#x27;</span>, &#123; <span class="attr">event</span>: <span class="string">&#x27;creating&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get latest CLI plugin version</span></span><br><span class="line">  <span class="keyword">const</span> &#123; latestMinor &#125; = <span class="keyword">await</span> getVersions()</span><br><span class="line">  <span class="comment">// generate package.json with plugin dependencies</span></span><br><span class="line">  <span class="keyword">const</span> pkg = &#123;</span><br><span class="line">    name,</span><br><span class="line">    version: <span class="string">&#x27;0.1.0&#x27;</span>,</span><br><span class="line">    private: <span class="literal">true</span>,</span><br><span class="line">    devDependencies: &#123;&#125;,</span><br><span class="line">    ...resolvePkg(context)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deps = <span class="built_in">Object</span>.keys(preset.plugins)</span><br><span class="line">  deps.forEach(<span class="function"><span class="params">dep</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preset.plugins[dep]._isPreset) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &#123; version &#125; = preset.plugins[dep]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!version) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isOfficialPlugin(dep) || dep === <span class="string">&#x27;@vue/cli-service&#x27;</span> || dep === <span class="string">&#x27;@vue/babel-preset-env&#x27;</span>) &#123;</span><br><span class="line">        version = isTestOrDebug ? <span class="string">`latest`</span> : <span class="string">`~<span class="subst">$&#123;latestMinor&#125;</span>`</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        version = <span class="string">&#x27;latest&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pkg.devDependencies[dep] = version</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write package.json</span></span><br><span class="line">  <span class="keyword">await</span> writeFileTree(context, &#123;</span><br><span class="line">    <span class="string">&#x27;package.json&#x27;</span>: <span class="built_in">JSON</span>.stringify(pkg, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处代码主要有两处作用：<strong>获取最新 CLI （包含插件）的版本</strong> 和 <strong>生成 package.json</strong>，这里 getVersions 方法用于判断 @vue/cli 是否需要更新以及初始化项目中相关插件的版本，需要注意的是，getVersions 获取 CLI 的版本并不是直接获取， 而是通过 <code>vue-cli-version-marker</code> npm 包获取的 CLI 版本，为什么会这样做，主要原因有两点：</p><ul><li>vue-cli 从 3.0（@vue/cli） 开始就放在了 @vue 下面，即是一个 scoped package, 而 <strong>scoped package 又不支持通过 npm registry 来获取 latest 版本信息</strong>。比如 vue-cli-version-marker/latest 可以正常访问，而 @vue/cli/latest 则不可以。</li><li>获取 scoped packages 的数据比获取 unscoped package 通常要慢 300ms。</li></ul><p>正是由于上述两个原因，因此通过 unscoped package <code>vue-cli-version-marker</code> 来获取 CLI 版本，<code>vue-cli-version-marker</code> 的内容比较简单，就是一个 package.json，通过获取里面 devDependencies 的版本信息，从而获取 @vue/cli 以及一些插件的版本号。</p><p>获取了插件版本之后遍历 preset 中所有 plugin 为其初始化版本号。并调用 writeFileTree 生成 package.json 。</p><p>在生成 package.json 文件之后便开始依赖的正式安装，在这之前会先进行判断是否需要 git 初始化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> create (cliOptions = &#123;&#125;, preset = <span class="literal">null</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// intilaize git repository before installing deps</span></span><br><span class="line">  <span class="comment">// so that vue-cli-service can setup git hooks.</span></span><br><span class="line">  <span class="keyword">const</span> shouldInitGit = <span class="built_in">this</span>.shouldInitGit(cliOptions)</span><br><span class="line">  <span class="keyword">if</span> (shouldInitGit) &#123;</span><br><span class="line">    log(<span class="string">`🗃  Initializing git repository...`</span>)</span><br><span class="line">    <span class="built_in">this</span>.emit(<span class="string">&#x27;creation&#x27;</span>, &#123; <span class="attr">event</span>: <span class="string">&#x27;git-init&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">await</span> run(<span class="string">&#x27;git init&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// install plugins</span></span><br><span class="line">  log(<span class="string">`⚙\u&#123;fe0f&#125;  Installing CLI plugins. This might take a while...`</span>)</span><br><span class="line">  log()</span><br><span class="line">  <span class="built_in">this</span>.emit(<span class="string">&#x27;creation&#x27;</span>, &#123; <span class="attr">event</span>: <span class="string">&#x27;plugins-install&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTestOrDebug &amp;&amp; !process.env.VUE_CLI_TEST_DO_INSTALL_PLUGIN) &#123;</span><br><span class="line">    <span class="comment">// in development, avoid installation process</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">require</span>(<span class="string">&#x27;./util/setupDevProject&#x27;</span>)(context)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> pm.install()</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会先调用 shouldInitGit 来判断是否需要 git 初始化，判断的情形有以下几种：</p><ul><li>没有安装 git (!hasGit())：false；</li><li>vue create 含有 --git 或者 -g 选项：true；</li><li>vue create 含有 --no-git 或者 -n 选项：false；</li><li>生成项目的目录是否已经含有 git （!hasProjectGit(this.context)）：如果有，则返回 false，否则返回 true。</li></ul><p>在判断完是否需要 git 初始化项目后，接下来就会调用 <code>pm.install</code> 安装依赖，还是看下其源码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> install () &#123;</span><br><span class="line">  <span class="keyword">const</span> args = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.needsPeerDepsFix) &#123;</span><br><span class="line">    args.push(<span class="string">&#x27;--legacy-peer-deps&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.VUE_CLI_TEST) &#123;</span><br><span class="line">    args.push(<span class="string">&#x27;--silent&#x27;</span>, <span class="string">&#x27;--no-progress&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">this</span>.runCommand(<span class="string">&#x27;install&#x27;</span>, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> runCommand (command, args) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevNodeEnv = process.env.NODE_ENV</span><br><span class="line">  <span class="comment">// In the use case of Vue CLI, when installing dependencies,</span></span><br><span class="line">  <span class="comment">// the `NODE_ENV` environment variable does no good;</span></span><br><span class="line">  <span class="comment">// it only confuses users by skipping dev deps (when set to `production`).</span></span><br><span class="line">  <span class="keyword">delete</span> process.env.NODE_ENV</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">this</span>.setRegistryEnvs()</span><br><span class="line">  <span class="keyword">await</span> executeCommand(</span><br><span class="line">    <span class="built_in">this</span>.bin,</span><br><span class="line">    [</span><br><span class="line">      ...PACKAGE_MANAGER_CONFIG[<span class="built_in">this</span>.bin][command],</span><br><span class="line">      ...(args || [])</span><br><span class="line">    ],</span><br><span class="line">    <span class="built_in">this</span>.context</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevNodeEnv) &#123;</span><br><span class="line">    process.env.NODE_ENV = prevNodeEnv</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中调用了 setRegistryEnvs 函数，它的作用是指定安装源，具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Any command that implemented registry-related feature should support</span></span><br><span class="line"><span class="comment">// `-r` / `--registry` option</span></span><br><span class="line"><span class="keyword">async</span> getRegistry (scope) &#123;</span><br><span class="line">  <span class="keyword">const</span> cacheKey = scope || <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>._registries[cacheKey]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._registries[cacheKey]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> args = minimist(process.argv, &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      r: <span class="string">&#x27;registry&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> registry</span><br><span class="line">  <span class="keyword">if</span> (args.registry) &#123;</span><br><span class="line">    registry = args.registry</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!process.env.VUE_CLI_TEST &amp;&amp; <span class="keyword">await</span> shouldUseTaobao(<span class="built_in">this</span>.bin)) &#123;</span><br><span class="line">    registry = registries.taobao</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (scope) &#123;</span><br><span class="line">        registry = (<span class="keyword">await</span> execa(<span class="built_in">this</span>.bin, [<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, scope + <span class="string">&#x27;:registry&#x27;</span>])).stdout</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!registry || registry === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        registry = (<span class="keyword">await</span> execa(<span class="built_in">this</span>.bin, [<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;registry&#x27;</span>])).stdout</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// Yarn 2 uses `npmRegistryServer` instead of `registry`</span></span><br><span class="line">      registry = (<span class="keyword">await</span> execa(<span class="built_in">this</span>.bin, [<span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;npmRegistryServer&#x27;</span>])).stdout</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>._registries[cacheKey] = stripAnsi(registry).trim()</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._registries[cacheKey]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中如果 vue create 还有 -r 选项则采用设置的安装源，否则调用 shouldUseTaobao 函数来判断是否需要使用淘宝 NPM 镜像源，如果两者都不匹配则会调用 <a href="https://www.npmjs.com/package/execa">execa</a> 来直接执行 <code>this.bin</code> 文件，这儿的 bin 属性实际上就是 PackageManager 类创建的时候传入的 forcePackageManager 参数，即 yarn / npm / pnpm，在选定安装源后紧接着调用 executeCommand 函数，executeCommand 函数利用了 execa 执行 npm 或者 yarn 安装命令。至此<strong>安装依赖</strong>的流程就全部结束了，接下来就是 <code>vue create</code> 最核心的部分<strong>代码生成</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> create (cliOptions = &#123;&#125;, preset = <span class="literal">null</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// run generator</span></span><br><span class="line">  log(<span class="string">`🚀  Invoking generators...`</span>)</span><br><span class="line">  <span class="built_in">this</span>.emit(<span class="string">&#x27;creation&#x27;</span>, &#123; <span class="attr">event</span>: <span class="string">&#x27;invoking-generators&#x27;</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> plugins = <span class="keyword">await</span> <span class="built_in">this</span>.resolvePlugins(preset.plugins, pkg)</span><br><span class="line">  <span class="keyword">const</span> generator = <span class="keyword">new</span> Generator(context, &#123;</span><br><span class="line">    pkg,</span><br><span class="line">    plugins,</span><br><span class="line">    afterInvokeCbs,</span><br><span class="line">    afterAnyInvokeCbs</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">await</span> generator.generate(&#123;</span><br><span class="line">    extractConfigFiles: preset.useConfigFiles</span><br><span class="line">  &#125;)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中在实例化 Generator 实例之前调用了 resolvePlugins 对插件进行初始化，举个例子：<code>[&#123; '@vue/cli-plugin-babel': &#123; useTsWithBabel: true &#125; &#125;]</code> 的入参将被转化生成 <code>[&#123; id: '@vue/cli-plugin-babel', apply, options: &#123; useTsWithBabel: true &#125;&#125;]</code>，这儿主要的不同是多了 apply 对象，实际上了对应插件下 <code>generator</code> 文件的加载对象，在示例中也就是 <code>@vue/cli-plugin-babel/generator</code> 文件。</p><p>再完成了对插件的初始化和每个插件下的 <code>generator.js</code> 文件的加载后正式开始 Generator 实例的创建，在实例化一个 Generator 的时候会初始化一些成员变量，最重要的就是调用插件的 generators，不同于 1.x/2.x 基于模板的脚手架，Vue-cli3.0 采用了一套 基于插件的架构，到这里就会交给各个插件去执行了，看一下 Generator 实例化的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">context, &#123;</span></span><br><span class="line"><span class="params">    pkg = &#123;&#125;,</span></span><br><span class="line"><span class="params">    plugins = [],</span></span><br><span class="line"><span class="params">    afterInvokeCbs = [],</span></span><br><span class="line"><span class="params">    afterAnyInvokeCbs = [],</span></span><br><span class="line"><span class="params">    files = &#123;&#125;,</span></span><br><span class="line"><span class="params">    invoking = <span class="literal">false</span></span></span><br><span class="line"><span class="params">  &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.context = context</span><br><span class="line">    <span class="built_in">this</span>.plugins = plugins</span><br><span class="line">    <span class="built_in">this</span>.originalPkg = pkg</span><br><span class="line">    <span class="built_in">this</span>.pkg = <span class="built_in">Object</span>.assign(&#123;&#125;, pkg)</span><br><span class="line">    <span class="built_in">this</span>.pm = <span class="keyword">new</span> PackageManager(&#123; context &#125;)</span><br><span class="line">    <span class="built_in">this</span>.imports = &#123;&#125;</span><br><span class="line">    <span class="built_in">this</span>.rootOptions = &#123;&#125;</span><br><span class="line">    <span class="built_in">this</span>.afterInvokeCbs = afterInvokeCbs</span><br><span class="line">    <span class="built_in">this</span>.afterAnyInvokeCbs = afterAnyInvokeCbs</span><br><span class="line">    <span class="built_in">this</span>.configTransforms = &#123;&#125; <span class="comment">// 插件通过 GeneratorAPI 暴露的 addConfigTransform 方法添加如何提取配置文件</span></span><br><span class="line">    <span class="built_in">this</span>.defaultConfigTransforms = defaultConfigTransforms <span class="comment">// 默认的配置文件</span></span><br><span class="line">    <span class="built_in">this</span>.reservedConfigTransforms = reservedConfigTransforms <span class="comment">// 保留的配置文件 vue.config.js</span></span><br><span class="line">    <span class="built_in">this</span>.invoking = invoking</span><br><span class="line">    <span class="comment">// for conflict resolution</span></span><br><span class="line">    <span class="built_in">this</span>.depSources = &#123;&#125;</span><br><span class="line">    <span class="comment">// virtual file tree</span></span><br><span class="line">    <span class="built_in">this</span>.files = <span class="built_in">Object</span>.keys(files).length</span><br><span class="line">      <span class="comment">// when execute `vue add/invoke`, only created/modified files are written to disk</span></span><br><span class="line">      ? watchFiles(files, <span class="built_in">this</span>.filesModifyRecord = <span class="keyword">new</span> <span class="built_in">Set</span>())</span><br><span class="line">      <span class="comment">// all files need to be written to disk</span></span><br><span class="line">      : files</span><br><span class="line">    <span class="built_in">this</span>.fileMiddlewares = []</span><br><span class="line">    <span class="built_in">this</span>.postProcessFilesCbs = []</span><br><span class="line">    <span class="comment">// exit messages</span></span><br><span class="line">    <span class="built_in">this</span>.exitLogs = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load all the other plugins</span></span><br><span class="line">    <span class="built_in">this</span>.allPluginIds = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.pkg.dependencies || &#123;&#125;)</span><br><span class="line">      .concat(<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.pkg.devDependencies || &#123;&#125;))</span><br><span class="line">      .filter(isPlugin)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cliService = plugins.find(<span class="function"><span class="params">p</span> =&gt;</span> p.id === <span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> rootOptions = cliService</span><br><span class="line">      ? cliService.options</span><br><span class="line">      : inferRootOptions(pkg)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.rootOptions = rootOptions</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后查看其具体被调用实例的 generate 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> generate (&#123;</span><br><span class="line">  extractConfigFiles = <span class="literal">false</span>,</span><br><span class="line">  checkExisting = <span class="literal">false</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">this</span>.initPlugins()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// save the file system before applying plugin for comparison</span></span><br><span class="line">  <span class="keyword">const</span> initialFiles = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.files)</span><br><span class="line">  <span class="comment">// extract configs from package.json into dedicated files.</span></span><br><span class="line">  <span class="built_in">this</span>.extractConfigFiles(extractConfigFiles, checkExisting)</span><br><span class="line">  <span class="comment">// wait for file resolve</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">this</span>.resolveFiles()</span><br><span class="line">  <span class="comment">// set package.json</span></span><br><span class="line">  <span class="built_in">this</span>.sortPkg()</span><br><span class="line">  <span class="built_in">this</span>.files[<span class="string">&#x27;package.json&#x27;</span>] = <span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.pkg, <span class="literal">null</span>, <span class="number">2</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">  <span class="comment">// write/update file tree to disk</span></span><br><span class="line">  <span class="keyword">await</span> writeFileTree(<span class="built_in">this</span>.context, <span class="built_in">this</span>.files, initialFiles, <span class="built_in">this</span>.filesModifyRecord)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这儿 initPlugins 的主要作用是为每个插件对应生成一个 GeneratorAPI 实例，同时将实例作为参数传递给前面插件初始化时生成的插件下 <code>generator</code> 文件的加载对象，也可以理解为将实例 api 传入插件暴露出来的 generator 函数，这儿的最重要的就是 GeneratorAPI 了。</p><p>前面说到 Vue CLI 是基于一套插件架构的，那么如果插件需要自定义项目模板、修改模板中的一些文件或者添加一些依赖的话怎么处理呢？方法是 @vue/cli 插件所提供的 generator 向外暴露一个函数，接收的第一个参数 api，然后通过该 api 提供的方法去完成应用的拓展工作，这里所说 的 api 就是 GeneratorAPI，下面看一下 GeneratorAPI 提供了哪些方法。</p><ul><li>hasPlugin：判断项目中是否有某个插件</li><li>extendPackage：拓展 package.json 配置</li><li>render：利用 ejs 渲染模板文件</li><li>onCreateComplete：内存中保存的文件字符串全部被写入文件后的回调函数</li><li>exitLog：当 generator 退出的时候输出的信息</li><li>genJSConfig：将 json 文件生成为 js 配置文件</li><li>injectImports：向文件当中注入import语法的方法</li><li>injectRootOptions：向 Vue 根实例中添加选项</li><li>…</li></ul><p>下面以 <code>@vue/cli-service/generator/index.js</code> 为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">api, options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 渲染 ejs 模板 */</span></span><br><span class="line">  api.render(<span class="string">&#x27;./template&#x27;</span>, &#123;</span><br><span class="line">    doesCompile: api.hasPlugin(<span class="string">&#x27;babel&#x27;</span>) || api.hasPlugin(<span class="string">&#x27;typescript&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 扩展 package.json</span></span><br><span class="line">  api.extendPackage(&#123;</span><br><span class="line">    scripts: &#123;</span><br><span class="line">      <span class="string">&#x27;serve&#x27;</span>: <span class="string">&#x27;vue-cli-service serve&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;build&#x27;</span>: <span class="string">&#x27;vue-cli-service build&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    dependencies: &#123;</span><br><span class="line">      <span class="string">&#x27;vue&#x27;</span>: <span class="string">&#x27;^2.5.17&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devDependencies: &#123;</span><br><span class="line">      <span class="string">&#x27;vue-template-compiler&#x27;</span>: <span class="string">&#x27;^2.5.17&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;postcss&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;plugins&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;autoprefixer&#x27;</span>: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    browserslist: [</span><br><span class="line">      <span class="string">&#x27;&gt; 1%&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;last 2 versions&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;not ie &lt;= 8&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 如果 preset 中包含 vue-router</span></span><br><span class="line">  <span class="keyword">if</span> (options.router) &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>)(api, options)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果 preset 中包含 vuex</span></span><br><span class="line">  <span class="keyword">if</span> (options.vuex) &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;./vuex&#x27;</span>)(api, options)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果 preset 中包含 cssPreprocessor，即选择了 css 预处理器</span></span><br><span class="line">  <span class="keyword">if</span> (options.cssPreprocessor) &#123;</span><br><span class="line">    <span class="keyword">const</span> deps = &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        <span class="string">&#x27;node-sass&#x27;</span>: <span class="string">&#x27;^4.9.0&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;sass-loader&#x27;</span>: <span class="string">&#x27;^7.0.1&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      less: &#123;</span><br><span class="line">        <span class="string">&#x27;less&#x27;</span>: <span class="string">&#x27;^3.0.4&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;less-loader&#x27;</span>: <span class="string">&#x27;^4.1.0&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      stylus: &#123;</span><br><span class="line">        <span class="string">&#x27;stylus&#x27;</span>: <span class="string">&#x27;^0.54.5&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;stylus-loader&#x27;</span>: <span class="string">&#x27;^3.0.2&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    api.extendPackage(&#123;</span><br><span class="line">      devDependencies: deps[options.cssPreprocessor]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// additional tooling configurations</span></span><br><span class="line">  <span class="keyword">if</span> (options.configs) &#123;</span><br><span class="line">    api.extendPackage(options.configs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过示例我们可以感受到 vue-cli 3.0 的插件机制的核心：<strong>通过 GeneratorAPI 所暴露的方法将所有功能都交给插件去完成</strong>。对于 vue-cli 3.0 内置的插件，比如：@vue/cli-plugin-eslint 、@vue/cli-plugin-pwa 等等，以及其他第三方插件，他们的 generator 作用都是一样都可以向项目的 package.json 中注入额外的依赖或字段，并向项目中添加文件。我们也可以结合 GeneratorAPI 所暴露的方法自定义插件，因此 vue-cli 3.0 的插件机制给予了我们极大的灵活性与扩展性。</p><p>在完成对每个插件的处理之后开始进入到了<strong>生成项目文件</strong>的阶段，大致可以分为三部分，<strong>extractConfigFiles（提取配置文件）</strong>，<strong>resolveFiles（模板渲染）</strong> 和 <strong>writeFileTree（在磁盘上生成文件）</strong>。</p><p>1、 extractConfigFiles</p><p>提取配置文件指的是将一些插件（比如 eslint，babel）的配置从 package.json 的字段中提取到专属的配置文件中。下面以 eslint 为例进行分析： 在初始化项目的时候，如果选择了 eslint 插件，在调用 @vue/cli-plugin-eslint 的 generator 的时候，就会向 package.json 注入 eslintConfig 字段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">api, &#123; config, lintOn = [] &#125;, _, invoking</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> lintOn === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    lintOn = lintOn.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> eslintConfig = <span class="built_in">require</span>(<span class="string">&#x27;../eslintOptions&#x27;</span>).config(api)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pkg = &#123;</span><br><span class="line">    scripts: &#123;</span><br><span class="line">      lint: <span class="string">&#x27;vue-cli-service lint&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    eslintConfig,</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="comment">// Move these dependencies to package.json in v4.</span></span><br><span class="line">    <span class="comment">// Now in v3 we have to add redundant eslint related dependencies</span></span><br><span class="line">    <span class="comment">// in order to keep compatibility with v3.0.x users who defaults to ESlint v4.</span></span><br><span class="line">    devDependencies: &#123;</span><br><span class="line">      <span class="string">&#x27;babel-eslint&#x27;</span>: <span class="string">&#x27;^10.0.1&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;eslint&#x27;</span>: <span class="string">&#x27;^5.8.0&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;esliint-plugin-vue&#x27;</span>: <span class="string">&#x27;^5.0.0-0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> injectEditorConfig = <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filePath = api.resolve(<span class="string">&#x27;.editorconfig&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (fs.existsSync(filePath)) &#123;</span><br><span class="line">      <span class="comment">// Append to existing .editorconfig</span></span><br><span class="line">      api.render(<span class="function"><span class="params">files</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> configPath = path.resolve(__dirname, <span class="string">`./template/<span class="subst">$&#123;config&#125;</span>/_editorconfig`</span>)</span><br><span class="line">        <span class="keyword">const</span> editorconfig = fs.readFileSync(configPath, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        files[<span class="string">&#x27;.editorconfig&#x27;</span>] += <span class="string">`\n<span class="subst">$&#123;editorconfig&#125;</span>`</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      api.render(<span class="string">`./template/<span class="subst">$&#123;config&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config === <span class="string">&#x27;airbnb&#x27;</span>) &#123;</span><br><span class="line">    eslintConfig.extends.push(<span class="string">&#x27;@vue/airbnb&#x27;</span>)</span><br><span class="line">    <span class="built_in">Object</span>.assign(pkg.devDependencies, &#123;</span><br><span class="line">      <span class="string">&#x27;@vue/eslint-config-airbnb&#x27;</span>: <span class="string">&#x27;^4.0.0&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    injectEditorConfig(<span class="string">&#x27;airbnb&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config === <span class="string">&#x27;standard&#x27;</span>) &#123;</span><br><span class="line">    eslintConfig.extends.push(<span class="string">&#x27;@vue/standard&#x27;</span>)</span><br><span class="line">    <span class="built_in">Object</span>.assign(pkg.devDependencies, &#123;</span><br><span class="line">      <span class="string">&#x27;@vue/eslint-config-standard&#x27;</span>: <span class="string">&#x27;^4.0.0&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    injectEditorConfig(<span class="string">&#x27;standard&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config === <span class="string">&#x27;prettier&#x27;</span>) &#123;</span><br><span class="line">    eslintConfig.extends.push(<span class="string">&#x27;@vue/prettier&#x27;</span>)</span><br><span class="line">    <span class="built_in">Object</span>.assign(pkg.devDependencies, &#123;</span><br><span class="line">      <span class="string">&#x27;@vue/eslint-config-prettier&#x27;</span>: <span class="string">&#x27;^4.0.0&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// prettier &amp; default config do not have any style rules</span></span><br><span class="line">    <span class="comment">// so no need to generate an editorconfig file</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// default</span></span><br><span class="line">    eslintConfig.extends.push(<span class="string">&#x27;eslint:recommended&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  api.extendPackage(pkg)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>@vue/cli-plugin-eslint/generator/index.js</code> 中的一部分代码，从代码中可以看出，利用 GeneratorAPI 的 extendPackage 方法向 package.josn 里面注入了 scripts，eslintConfig 以及 devDependencies 字段，另外也会根据选择的 eslint 模式添加对应的依赖和修改对应的配置文件，例如选择了 airbnb 模式，就会向 eslintConfig.extends 添加 @vue/airbnb 配置，并且添加 @vue/eslint-config-airbnb 依赖和修改 .editorconfig 配置文件。此时 项目 package.json 中 eslintConfig 字段内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;root&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;node&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;plugin:vue/essential&quot;</span>,</span><br><span class="line">      <span class="string">&quot;@vue/airbnb&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;rules&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 preset 的 useConfigFiles 为 true ，或者以 Manually 模式初始化 preset 的时候选择 In dedicated config files 存放配置文件，那么 extractConfigFiles 方法就会将 package.json 中 eslintConfig 字段内容提取到 .eslintrc.js 文件中，内存中 .eslintrc.js 内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  env: &#123;</span><br><span class="line">    node: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">extends</span>: [</span><br><span class="line">    <span class="string">&#x27;plugin:vue/essential&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;@vue/airbnb&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;error&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;error&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    parser: <span class="string">&#x27;babel-eslint&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>extractConfigFiles 方法的具体实现主要是调用 ConfigTransform 实例的 transform 方法，代码实现的比较清晰，各位同学可以自己看下。这里就不做详细 分析了，在配置文件提取完了以后接下来就是执行 resolveFiles 函数了。</p><p>2、 resolveFiles</p><p>resolveFiles 主要分为以下三个部分执行：</p><ul><li>fileMiddlewares</li><li>injectImportsAndOptions</li><li>postProcessFilesCbs</li></ul><p>fileMiddlewares 里面包含了 ejs render 函数，所有插件调用 api.render 时候只是把对应的渲染函数 push 到了 fileMiddlewares 中，等所有的 插件执行完以后才会遍历执行 fileMiddlewares 里面的所有函数，即在内存中生成模板文件字符串。</p><p>injectImportsAndOptions 就是将 generator 注入的 import 和 rootOption 解析到对应的文件中，比如选择了 vuex, 会在 src/main.js 中添加 import store from ‘./store’，以及在 vue 根实例中添加 router 选项。</p><p>postProcessFilesCbs 是在所有普通文件在内存中渲染成字符串完成之后要执行的遍历回调。例如将 @vue/cli-service/generator/index.js 中的 render 是放在了 fileMiddlewares 里面，而将 @vue/cli-service/generator/router/index.js 中将替换 src/App.vue 文件的方法放在了 postProcessFiles 里面，原因是对 src/App.vue 文件的一些替换一定是发生在 render 函数之后，如果在之前，修改后的 src/App.vue 在之后 render 函数执行时又会被覆盖，这样显然不合理。</p><p>3、 writeFileTree</p><p>在提取了配置文件和模板渲染之后调用了 sortPkg 对 package.json 的字段进行了排序并将 package.json 转化为 json 字符串添加到项目的 files 中。 此时整个项目的文件已经在内存中生成好了（在源码中就是对应的 this.files），接下来就调用 writeFileTree 方法将内存中的字符串模板文件生成在磁盘中。到这里 vue create 核心部分 generator 基本上就分析完了。</p><img src="/assets/emoji/04.png" width="280" /><p>接下来在 <code>../lib/Creator.js</code> 文件的 create 方法中还有一些其他额外处理，主要包括：</p><ul><li>安装额外依赖：这里的依赖来源于 preset 的 option，比如选择了 scss css 预处理器，那么就需要额外安装 node-sass 和 sass-loader 两个依赖。</li><li>执行 createCompleteCbs：所有文件都写在磁盘后执行的遍历回调。</li><li>生成 <a href="http://README.md">README.md</a>：根据 package.json 的 script 的字段生成生成对应的 <a href="http://README.md">README.md</a>。</li><li>git 初始化提交：调用 shouldInitGit 来判断是否需要 git 初始化提交，如果需要初始化提交就会执行 git add 和 git commmit 命令。</li><li>日志输出：插件的 generator 可以利用 GeneratorAPI 暴露的 exitLog 方法在项目输出其他所有的 message 之后输出一些日志。</li></ul><p><strong>总结：</strong></p><p>vue create 命令总的来说就实例化了2个类，然后各自调了一个方法。当执行 create 命令时会创建一个 Creator 实例， 然后调用其 create 方法。在 create 方法中又会创建一个 Generator 实例，然后再调用其 generator 方法，初始化整个项目会交给各个插件去完成。比如核心插件 @vue/cli-service 会渲染整个项目的文件，@vue/cli-plugin-eslint 会进行 eslint 的一些配置， @vue/cli-plugin-unit-jest 插件也会进行一些 jest 的配置，各个功能都会交给对应的插件去完成，而 GeneratorAPI 又允许一个插件的 generator 向 package.json 注入额外的依赖或字段，并向项目中添加文件，这也让插件对整个项目拥有更高的可配置性。</p><h4 id="2-add-命令"><a class="markdownIt-Anchor" href="#2-add-命令"></a> 2、add 命令</h4><p>文章前面通过解析 vue create 命令的具体执行流程介绍了项目创建初始化的主要过程，其最核心的就是插件机制，其使得用户对项目有了更高的可配置性，再完成项目初始构建后我们依然可以通过 vue add 指令添加插件，那么其实现原理有是什么呢？</p><p>vue add 命令的入口在 packages/@vue/cli/bin/vue.js 中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">program</span><br><span class="line">  .command(<span class="string">&#x27;add &lt;plugin&gt; [pluginOptions]&#x27;</span>)</span><br><span class="line">  .description(<span class="string">&#x27;install a plugin and invoke its generator in an already created project&#x27;</span>)</span><br><span class="line">  .option(<span class="string">&#x27;--registry &lt;url&gt;&#x27;</span>, <span class="string">&#x27;Use specified npm registry when installing dependencies (only for npm)&#x27;</span>)</span><br><span class="line">  .allowUnknownOption()</span><br><span class="line">  .action(<span class="function">(<span class="params">plugin</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">&#x27;../lib/add&#x27;</span>)(plugin, minimist(process.argv.slice(<span class="number">3</span>)))</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>从代码中可以看出，vue add 命令接受两个参数:</p><ul><li>plugin： 插件名称，必填。</li><li>registry： 安装插件指定的安装源，只针对于 npm 包管理器，选填。</li></ul><p>当执行了 vue add 命令后会加载 @vue/cli/lib/add.js，下面就逐步开始分析。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> add(...args).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    error(err)</span><br><span class="line">    <span class="keyword">if</span> (!process.env.VUE_CLI_TEST) &#123;</span><br><span class="line">      process.exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着来查看 add 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">pluginToAdd, options = &#123;&#125;, context = process.cwd()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">await</span> confirmIfGitDirty(context))) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for `vue add` command in 3.x projects</span></span><br><span class="line">  <span class="keyword">const</span> servicePkg = loadModule(<span class="string">&#x27;@vue/cli-service/package.json&#x27;</span>, context)</span><br><span class="line">  <span class="keyword">if</span> (servicePkg &amp;&amp; semver.satisfies(servicePkg.version, <span class="string">&#x27;3.x&#x27;</span>)) &#123;</span><br><span class="line">    <span class="comment">// special internal &quot;plugins&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^(@vue\/)?router$/</span>.test(pluginToAdd)) &#123; <span class="comment">// 匹配 @vue/router，router</span></span><br><span class="line">      <span class="keyword">return</span> addRouter(context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^(@vue\/)?vuex$/</span>.test(pluginToAdd)) &#123; <span class="comment">// 匹配 @vue/vuex，vuex</span></span><br><span class="line">      <span class="keyword">return</span> addVuex(context)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析插件名称</span></span><br><span class="line">  <span class="comment">// @bar/foo =&gt; @bar/vue-cli-plugin-foo</span></span><br><span class="line">  <span class="comment">// @vue/foo =&gt; @vue/cli-plugin-foo</span></span><br><span class="line">  <span class="comment">// foo =&gt; vue-cli-plugin-foo</span></span><br><span class="line">  <span class="keyword">const</span> pluginRe = <span class="regexp">/^(@?[^@]+)(?:@(.+))?$/</span></span><br><span class="line">  <span class="keyword">const</span> [</span><br><span class="line">    <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">    _skip,</span><br><span class="line">    pluginName,</span><br><span class="line">    pluginVersion</span><br><span class="line">  ] = pluginToAdd.match(pluginRe)</span><br><span class="line">  <span class="keyword">const</span> packageName = resolvePluginId(pluginName)</span><br><span class="line"></span><br><span class="line">  log()</span><br><span class="line">  log(<span class="string">`📦  Installing <span class="subst">$&#123;chalk.cyan(packageName)&#125;</span>...`</span>)</span><br><span class="line">  log()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pm = <span class="keyword">new</span> PackageManager(&#123; context &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pluginVersion) &#123;</span><br><span class="line">    <span class="keyword">await</span> pm.add(<span class="string">`<span class="subst">$&#123;packageName&#125;</span>@<span class="subst">$&#123;pluginVersion&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isOfficialPlugin(packageName)) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; latestMinor &#125; = <span class="keyword">await</span> getVersions()</span><br><span class="line">    <span class="keyword">await</span> pm.add(<span class="string">`<span class="subst">$&#123;packageName&#125;</span>@~<span class="subst">$&#123;latestMinor&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> pm.add(packageName, &#123; <span class="attr">tilde</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  log(<span class="string">`<span class="subst">$&#123;chalk.green(<span class="string">&#x27;✔&#x27;</span>)&#125;</span>  Successfully installed plugin: <span class="subst">$&#123;chalk.cyan(packageName)&#125;</span>`</span>)</span><br><span class="line">  log()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> generatorPath = resolveModule(<span class="string">`<span class="subst">$&#123;packageName&#125;</span>/generator`</span>, context)</span><br><span class="line">  <span class="keyword">if</span> (generatorPath) &#123;</span><br><span class="line">    invoke(pluginName, options, context)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log(<span class="string">`Plugin <span class="subst">$&#123;packageName&#125;</span> does not have a generator to invoke`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add 函数的主要功能就是安装插件包，对于 vue-cli 内部一些特殊的&quot;插件&quot;，比如 router，vuex，就不会通过包管理器安装，而是直接加载 @vue/cli-service/generator/router 和 @vue/cli-service/generator/vuex，这两个文件也是两个 generator，可以向 package.json 注入额外的依赖或字段，并向项目中添加文件，对于普通的第三方插件，则需要通过包管理器安装，示例调用的 <code>pm.add</code> 方法实现如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @vue/cli/lib/util/ProjectPackageManager.js</span></span><br><span class="line"><span class="keyword">async</span> add (packageName, &#123;</span><br><span class="line">  tilde = <span class="literal">false</span>,</span><br><span class="line">  dev = <span class="literal">true</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">const</span> args = dev ? [<span class="string">&#x27;-D&#x27;</span>] : []</span><br><span class="line">  <span class="keyword">if</span> (tilde) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.bin === <span class="string">&#x27;yarn&#x27;</span>) &#123;</span><br><span class="line">      args.push(<span class="string">&#x27;--tilde&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      process.env.npm_config_save_prefix = <span class="string">&#x27;~&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.needsPeerDepsFix) &#123;</span><br><span class="line">    args.push(<span class="string">&#x27;--legacy-peer-deps&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">this</span>.runCommand(<span class="string">&#x27;add&#x27;</span>, [packageName, ...args])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户指定插件包名称时未指定版本号那么在调用 <code>pm.add</code> 方法时会传入参数 <code>tilde: true</code>，在 <code>pm.add</code> 的内部会根据包管理器的具体类型进行判断，如果是 yarn 会添加 --tilde 参数，如果是 npm 或 pnpm 则会将 npm_config_save_prefix 的配置设为 ‘~’，这个配置的默认值为 ‘^’, 例如一个包的版本是 1.2.3，默认情况下那么在 package.json 中就会被设置为 ‘^1.2.3’，这样，对于 minor 部分的更新依然是可以的。但是如果设置了 npm config set save-prefix=”~”，那么就会被设置为 ”~1.2.3”，此时只允许最后一位数字的版本更新。最后再通过 runCommand 函数执行具体包管理器（如 yarn）的 add 指令。</p><p>在 vue-cli 官方文档中对插件 的命名有着明确的要求，即命名方式为：<code>vue-cli-plugin-&lt;name&gt;</code>，插件遵循命名约定之后就可以：</p><ul><li>被 @vue/cli-service 发现；</li><li>被其它开发者搜索到；</li><li>通过 <code>vue add &lt;name&gt;</code> 或 <code>vue invoke &lt;name&gt;</code> 安装下来。</li></ul><p>在获取第三方插件名称后，就会调用 invoke 方法安装插件包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">invoke</span> (<span class="params">pluginName, options = &#123;&#125;, context = process.cwd()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">await</span> confirmIfGitDirty(context))) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> options._</span><br><span class="line">  <span class="keyword">const</span> pkg = getPkg(context) <span class="comment">// 解析 package.json</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// attempt to locate the plugin in package.json</span></span><br><span class="line">  <span class="keyword">const</span> findPlugin = <span class="function"><span class="params">deps</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!deps) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> name</span><br><span class="line">    <span class="comment">// official</span></span><br><span class="line">    <span class="keyword">if</span> (deps[(name = <span class="string">`@vue/cli-plugin-<span class="subst">$&#123;pluginName&#125;</span>`</span>)]) &#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// full id, scoped short, or default short</span></span><br><span class="line">    <span class="keyword">if</span> (deps[(name = resolvePluginId(pluginName))]) &#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> id = findPlugin(pkg.devDependencies) || findPlugin(pkg.dependencies)</span><br><span class="line">  <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">`Cannot resolve plugin <span class="subst">$&#123;chalk.yellow(pluginName)&#125;</span> from package.json. `</span> +</span><br><span class="line">        <span class="string">`Did you forget to install it?`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pluginGenerator = loadModule(<span class="string">`<span class="subst">$&#123;id&#125;</span>/generator`</span>, context)</span><br><span class="line">  <span class="keyword">if</span> (!pluginGenerator) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Plugin <span class="subst">$&#123;id&#125;</span> does not have a generator.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve options if no command line options (other than --registry) are passed,</span></span><br><span class="line">  <span class="comment">// and the plugin contains a prompt module.</span></span><br><span class="line">  <span class="comment">// eslint-disable-next-line prefer-const</span></span><br><span class="line">  <span class="keyword">let</span> &#123; registry, $inlineOptions, ...pluginOptions &#125; = options</span><br><span class="line">  <span class="keyword">if</span> ($inlineOptions) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      pluginOptions = <span class="built_in">JSON</span>.parse($inlineOptions)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Couldn&#x27;t parse inline options JSON: <span class="subst">$&#123;e.message&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">Object</span>.keys(pluginOptions).length) &#123;</span><br><span class="line">    <span class="keyword">let</span> pluginPrompts = loadModule(<span class="string">`<span class="subst">$&#123;id&#125;</span>/prompts`</span>, context)</span><br><span class="line">    <span class="keyword">if</span> (pluginPrompts) &#123;</span><br><span class="line">      <span class="keyword">const</span> prompt = inquirer.createPromptModule()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> pluginPrompts === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        pluginPrompts = pluginPrompts(pkg, prompt)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> pluginPrompts.getPrompts === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        pluginPrompts = pluginPrompts.getPrompts(pkg, prompt)</span><br><span class="line">      &#125;</span><br><span class="line">      pluginOptions = <span class="keyword">await</span> prompt(pluginPrompts)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> plugin = &#123;</span><br><span class="line">    id,</span><br><span class="line">    apply: pluginGenerator,</span><br><span class="line">    options: &#123;</span><br><span class="line">      registry,</span><br><span class="line">      ...pluginOptions</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> runGenerator(context, plugin, pkg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法先调用 findPlugin 判断插件是否安装，如果安装也返回插件名，接着获取目标插件下的 generator 方法。然后就是判断命令行是否传入行内参数，如果没有并且传入插件参数为空则调用 inquirer.prompt 获取插件的 option，并传给其 generator，在完成这些以后，就是 runGenerator。这儿的 runGenerator 的具体实现与 vue create 命令中项目生成的阶段基本一致，实质上就是构造一个 Generator 实例，并调用其 generate 方法。在实例的 generator 方法调用完成之后执行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --exclude-standard --modified --others</span><br></pre></td></tr></table></figure><p>因为插件的 generator 可以通过 GeneratorAPI 暴露的 render 和 extendPackage 方法修改项目的文件，因此通过执行该命令将变化的文件显示在终端上，这对开发者十分地友好。</p><p>vue add 相当于只是 vue create 中的一部分，vue create 包含了插件的安装以及调用，vue add 命令只是将此功能分离了出来，而 vue invoke 命令其实是 vue add 命名去掉了插件包安装的那一部分，其他 vue 命令由于篇幅限制（wo tai lan le）此处不再介绍。</p><h3 id="三-vuecli-service"><a class="markdownIt-Anchor" href="#三-vuecli-service"></a> 三、@vue/cli-service</h3><p>在 Vue CLI 中将 webpack 及相关插件提供的功能都收敛到 @vue/cli-service 内部来实现，提供了 vue-cli-service 命令帮助使用者最基本的日常开发，下面就开始分析 @vue/cli-service 的具体实现。</p><h4 id="1-入口"><a class="markdownIt-Anchor" href="#1-入口"></a> 1、入口</h4><p>vue-cli-service m命令的入口在 @vue/cli-service/bin/vue-service-service.js 中，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @vue/cli-service/bin/vue-service-service.js</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; semver, error &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-shared-utils&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> requiredVersion = <span class="built_in">require</span>(<span class="string">&#x27;../package.json&#x27;</span>).engines.node</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node 版本校验</span></span><br><span class="line"><span class="keyword">if</span> (!semver.satisfies(process.version, requiredVersion, &#123; <span class="attr">includePrerelease</span>: <span class="literal">true</span> &#125;)) &#123;</span><br><span class="line">  error(</span><br><span class="line">    <span class="string">`You are using Node <span class="subst">$&#123;process.version&#125;</span>, but vue-cli-service `</span> +</span><br><span class="line">    <span class="string">`requires Node <span class="subst">$&#123;requiredVersion&#125;</span>.\nPlease upgrade your Node version.`</span></span><br><span class="line">  )</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Service = <span class="built_in">require</span>(<span class="string">&#x27;../lib/Service&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> service = <span class="keyword">new</span> Service(process.env.VUE_CLI_CONTEXT || process.cwd())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取命令参数 vue-cli-service serve --https</span></span><br><span class="line"><span class="keyword">const</span> rawArgv = process.argv.slice(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 在 boolean 选项当中的参数会被解析成 true，例如 args.https: true, args.modern: false</span></span><br><span class="line"><span class="keyword">const</span> args = <span class="built_in">require</span>(<span class="string">&#x27;minimist&#x27;</span>)(rawArgv, &#123;</span><br><span class="line">  boolean: [</span><br><span class="line">    <span class="comment">// build</span></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> --no-module, --no-unsafe-inline, no-clean, etc.</span></span><br><span class="line">    <span class="string">&#x27;modern&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;report&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;report-json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;inline-vue&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;watch&#x27;</span>,</span><br><span class="line">    <span class="comment">// serve</span></span><br><span class="line">    <span class="string">&#x27;open&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;copy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">    <span class="comment">// inspect</span></span><br><span class="line">    <span class="string">&#x27;verbose&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> command = args._[<span class="number">0</span>] <span class="comment">// serve</span></span><br><span class="line"></span><br><span class="line">service.run(command, args, rawArgv).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  error(err)</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>代码看着非常简洁，与一般 node 命令文件有点不同，第一就是并没有依赖 commander.js，第二就是并没有直接提供相关 CLI 命令的服务。 在 @vue/vue-cli-service 中，对于第一点是通过 Service 这个类来处理 node 命令，而对于第二点，所有的 CLI 服务都是动态注册的。从上面这段代码可以看出，执行 CLI 命令后，主要有两个操作：实例化 Service 和调用实例的 run 方法。</p><h4 id="2-service-类实例化"><a class="markdownIt-Anchor" href="#2-service-类实例化"></a> 2、Service 类实例化</h4><p>我们接着查看 Service 类的构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @vue/cli-service/lib/Service.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">context, &#123; plugins, pkg, inlineOptions, useBuiltIn &#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">    checkWebpack(context)</span><br><span class="line"></span><br><span class="line">    process.VUE_CLI_SERVICE = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.initialized = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.context = context</span><br><span class="line">    <span class="built_in">this</span>.inlineOptions = inlineOptions</span><br><span class="line">    <span class="built_in">this</span>.webpackChainFns = []</span><br><span class="line">    <span class="built_in">this</span>.webpackRawConfigFns = []</span><br><span class="line">    <span class="built_in">this</span>.devServerConfigFns = []</span><br><span class="line">    <span class="built_in">this</span>.commands = &#123;&#125;</span><br><span class="line">    <span class="comment">// Folder containing the target package.json for plugins</span></span><br><span class="line">    <span class="built_in">this</span>.pkgContext = context</span><br><span class="line">    <span class="comment">// package.json containing the plugins</span></span><br><span class="line">    <span class="built_in">this</span>.pkg = <span class="built_in">this</span>.resolvePkg(pkg)</span><br><span class="line">    <span class="comment">// If there are inline plugins, they will be used instead of those</span></span><br><span class="line">    <span class="comment">// found in package.json.</span></span><br><span class="line">    <span class="comment">// When useBuiltIn === false, built-in plugins are disabled. This is mostly</span></span><br><span class="line">    <span class="comment">// for testing.</span></span><br><span class="line">    <span class="comment">// 如果有 inline plugins 的话，就不会去加载 package.json 里 devDependencies 和 dependencies 的插件，useBuiltIn 为 false 时 builtInPlugins 会被禁用</span></span><br><span class="line">    <span class="built_in">this</span>.plugins = <span class="built_in">this</span>.resolvePlugins(plugins, useBuiltIn)</span><br><span class="line">    <span class="comment">// pluginsToSkip will be populated during run()</span></span><br><span class="line">    <span class="built_in">this</span>.pluginsToSkip = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="comment">// resolve the default mode to use for each command</span></span><br><span class="line">    <span class="comment">// this is provided by plugins as module.exports.defaultModes</span></span><br><span class="line">    <span class="comment">// so we can get the information without actually applying the plugin.</span></span><br><span class="line">    <span class="comment">// 注册的插件可以通过 module.exports.defaultModes 指定特定的模式</span></span><br><span class="line">    <span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">      serve: &#x27;development&#x27;,</span></span><br><span class="line"><span class="comment">      build: &#x27;production&#x27;,</span></span><br><span class="line"><span class="comment">      inspect: &#x27;development&#x27;,</span></span><br><span class="line"><span class="comment">      &#x27;test:unit&#x27;: &#x27;test&#x27;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">this</span>.modes = <span class="built_in">this</span>.plugins.reduce(<span class="function">(<span class="params">modes, &#123; apply: &#123; defaultModes &#125; &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(modes, defaultModes)</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化的过程主要进行了插件的解析和为每一种 CLI 命令指定模式，先看一下插件的解析：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @vue/cli-service/lib/Service.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  resolvePlugins (inlinePlugins, useBuiltIn) &#123;</span><br><span class="line">    <span class="keyword">const</span> idToPlugin = <span class="function">(<span class="params">id, absolutePath</span>) =&gt;</span> (&#123;</span><br><span class="line">      id: id.replace(<span class="regexp">/^.\//</span>, <span class="string">&#x27;built-in:&#x27;</span>),</span><br><span class="line">      apply: <span class="built_in">require</span>(absolutePath || id)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> plugins</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 内置插件</span></span><br><span class="line">    <span class="keyword">const</span> builtInPlugins = [</span><br><span class="line">      <span class="string">&#x27;./commands/serve&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;./commands/build&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;./commands/inspect&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;./commands/help&#x27;</span>,</span><br><span class="line">      <span class="comment">// config plugins are order sensitive</span></span><br><span class="line">      <span class="string">&#x27;./config/base&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;./config/assets&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;./config/css&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;./config/prod&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;./config/app&#x27;</span></span><br><span class="line">    ].map(<span class="function">(<span class="params">id</span>) =&gt;</span> idToPlugin(id)) <span class="comment">// [&#123; id: &#x27;built-in:commands/serve&#x27;, apply:&#123; [Function] defaultModes: [Object] &#125; &#125;,...]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化 Service 时传入插件</span></span><br><span class="line">    <span class="keyword">if</span> (inlinePlugins) &#123;</span><br><span class="line">      plugins = useBuiltIn !== <span class="literal">false</span></span><br><span class="line">        ? builtInPlugins.concat(inlinePlugins)</span><br><span class="line">        : inlinePlugins</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> projectPlugins = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.pkg.devDependencies || &#123;&#125;)</span><br><span class="line">        .concat(<span class="built_in">Object</span>.keys(<span class="built_in">this</span>.pkg.dependencies || &#123;&#125;))</span><br><span class="line">        .filter(isPlugin) <span class="comment">// isPlugin = id =&gt; /^(@vue\/|vue-|@[\w-]+\/vue-)cli-plugin-/.test(id)</span></span><br><span class="line">        .map(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            <span class="built_in">this</span>.pkg.optionalDependencies &amp;&amp;</span><br><span class="line">            id <span class="keyword">in</span> <span class="built_in">this</span>.pkg.optionalDependencies</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="keyword">let</span> apply = loadModule(id, <span class="built_in">this</span>.pkgContext)</span><br><span class="line">            <span class="keyword">if</span> (!apply) &#123;</span><br><span class="line">              warn(<span class="string">`Optional dependency <span class="subst">$&#123;id&#125;</span> is not installed.`</span>)</span><br><span class="line">              apply = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123; id, apply &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> idToPlugin(id, resolveModule(id, <span class="built_in">this</span>.pkgContext))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add the plugin automatically to simplify the webpack-4 tests</span></span><br><span class="line">      <span class="comment">// so that a simple Jest alias would suffice, avoid changing every</span></span><br><span class="line">      <span class="comment">// preset used in the tests</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        process.env.VUE_CLI_TEST &amp;&amp;</span><br><span class="line">        process.env.VUE_CLI_USE_WEBPACK4 &amp;&amp;</span><br><span class="line">        !projectPlugins.some(<span class="function">(<span class="params">p</span>) =&gt;</span> p.id === <span class="string">&#x27;@vue/cli-plugin-webpack-4&#x27;</span>)</span><br><span class="line">      ) &#123;</span><br><span class="line">        builtInPlugins.push(idToPlugin(<span class="string">&#x27;@vue/cli-plugin-webpack-4&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      plugins = builtInPlugins.concat(projectPlugins)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Local plugins</span></span><br><span class="line">    <span class="comment">// 项目本地的插件，针对于只需要在项目里直接访问插件 API 而不需要创建一个完整的插件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pkg.vuePlugins &amp;&amp; <span class="built_in">this</span>.pkg.vuePlugins.service) &#123;</span><br><span class="line">      <span class="keyword">const</span> files = <span class="built_in">this</span>.pkg.vuePlugins.service</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(files)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid type for option &#x27;vuePlugins.service&#x27;, expected &#x27;array&#x27; but got <span class="subst">$&#123;<span class="keyword">typeof</span> files&#125;</span>.`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      plugins = plugins.concat(files.map(<span class="function"><span class="params">file</span> =&gt;</span> (&#123;</span><br><span class="line">        id: <span class="string">`local:<span class="subst">$&#123;file&#125;</span>`</span>,</span><br><span class="line">        apply: loadModule(<span class="string">`./<span class="subst">$&#123;file&#125;</span>`</span>, <span class="built_in">this</span>.pkgContext)</span><br><span class="line">      &#125;)))</span><br><span class="line">    &#125;</span><br><span class="line">    debug(<span class="string">&#x27;vue:plugins&#x27;</span>)(plugins)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> orderedPlugins = sortPlugins(plugins)</span><br><span class="line">    debug(<span class="string">&#x27;vue:plugins-ordered&#x27;</span>)(orderedPlugins)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> orderedPlugins</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将解析的插件分为4类：</p><ul><li>内置插件</li><li>inlinePlugins</li><li>package.json 插件</li><li>package.vuePlugins 插件</li></ul><p><strong>内置插件</strong>指的是 @vue/cli-service 内部提供的插件，又可以大致分为两类，serve、build、inspect、help 这一类插件在内部动态注册新的 CLI 命令， 开发者即可通过 npm script 的形式去启动对应的 CLI 命令服务，base ,css, dev, prod, app 这一类插件主要是完成 webpack 本地编译构建时的各种相关的配置。 @vue/cli-service 将 webpack 的开发构建功能收敛到内部来完成。</p><p><strong>inlinePlugins</strong> 指的是直接在实例化 Service 时传入，执行 vue serve 和 vue build 命令时会创建一个 Service 实例，并传入 inlinePlugins。</p><p><strong>package.json 插件</strong>指的是 devDependencies 和 dependencies 中的 vue 插件，比如 @vue/cli-plugin-eslint。</p><p><strong>package.vuePlugins</strong> 也是在 package.json 中的插件，不过是在 vuePlugins 字段中，该类插件是针对于只需要在项目里直接访问插件 API 而不需要创建一个完整的插件。</p><p>我们接着查看 CLI 指定模式：</p><p>CLI 模式是 vue cli 中一个重要的概念，默认情况下，一个 Vue CLI 项目有三个模式：</p><ul><li>development 模式用于 vue-cli-service serve</li><li>test 模式用于 vue-cli-service test:unit</li><li>production 模式用于 vue-cli-service build 和 vue-cli-service test:e2e</li></ul><p>我们也可以通过传递 --mode 选项参数为命令行覆写默认的模式。详情可查看<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E6%A8%A1%E5%BC%8F">官方文档</a>。</p><p>在 Service 的构造函数中解析完插件之后就为每种插件命令指定模式，插件命令的模式可以 通过 module.exports.defaultModes 以 { [commandName]: mode } 的形式来暴露：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">api</span> =&gt;</span> &#123;</span><br><span class="line">  api.registerCommand(<span class="string">&#x27;build&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.defaultModes = &#123;</span><br><span class="line">  build: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析命令模式利用 js 内建函数 reduce 实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.modes = <span class="built_in">this</span>.plugins.reduce(<span class="function">(<span class="params">modes, &#123; apply: &#123; defaultModes &#125;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(modes, defaultModes)</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-实例的-run-方法"><a class="markdownIt-Anchor" href="#3-实例的-run-方法"></a> 3、实例的 run 方法</h4><p>在 vue-cli-service 的入口处完成 Service 类的实例化后又调用了实例的 run 方法，我们接着查看其具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @vue/cli-service/lib/Service.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">async</span> run (name, args = &#123;&#125;, rawArgv = []) &#123;</span><br><span class="line">    <span class="comment">// resolve mode</span></span><br><span class="line">    <span class="comment">// prioritize inline --mode</span></span><br><span class="line">    <span class="comment">// fallback to resolved default modes from plugins or development if --watch is defined</span></span><br><span class="line">    <span class="keyword">const</span> mode = args.mode || (name === <span class="string">&#x27;build&#x27;</span> &amp;&amp; args.watch ? <span class="string">&#x27;development&#x27;</span> : <span class="built_in">this</span>.modes[name])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --skip-plugins arg may have plugins that should be skipped during init()</span></span><br><span class="line">    <span class="built_in">this</span>.setPluginsToSkip(args)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load env variables, load user config, apply plugins</span></span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.init(mode)</span><br><span class="line"></span><br><span class="line">    args._ = args._ || []</span><br><span class="line">    <span class="keyword">let</span> command = <span class="built_in">this</span>.commands[name] <span class="comment">// 这里的 commands 就是加载插件时通过 api.registerCommand 注册的 command，后续详细介绍</span></span><br><span class="line">    <span class="keyword">if</span> (!command &amp;&amp; name) &#123;</span><br><span class="line">      error(<span class="string">`command &quot;<span class="subst">$&#123;name&#125;</span>&quot; does not exist.`</span>)</span><br><span class="line">      process.exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!command || args.help || args.h) &#123;</span><br><span class="line">      command = <span class="built_in">this</span>.commands.help</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      args._.shift() <span class="comment">// remove command itself</span></span><br><span class="line">      rawArgv.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> &#123; fn &#125; = command</span><br><span class="line">    <span class="keyword">return</span> fn(args, rawArgv)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run 方法开始会获取该命令所对应的模式值，然后调用实例的 init 方法，init 主要有三个功能：</p><ul><li>加载对应模式下本地的环境变量文件</li><li>解析 vue.config.js 或者 package.vue</li><li>执行所有被加载的插件</li></ul><p>我们来查看 init 方法的具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  init (mode = process.env.VUE_CLI_MODE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.initialized) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.initialized = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load mode .env</span></span><br><span class="line">    <span class="comment">// 加载指定的模式环境文件</span></span><br><span class="line">    <span class="keyword">if</span> (mode) &#123;</span><br><span class="line">      <span class="built_in">this</span>.loadEnv(mode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// load base .env</span></span><br><span class="line">    <span class="comment">// 加载普通环境文件</span></span><br><span class="line">    <span class="built_in">this</span>.loadEnv()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load user config</span></span><br><span class="line">    <span class="keyword">const</span> userOptions = <span class="built_in">this</span>.loadUserOptions()</span><br><span class="line">    <span class="keyword">const</span> loadedCallback = <span class="function">(<span class="params">loadedUserOptions</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.projectOptions = defaultsDeep(loadedUserOptions, defaults())</span><br><span class="line"></span><br><span class="line">      debug(<span class="string">&#x27;vue:project-config&#x27;</span>)(<span class="built_in">this</span>.projectOptions)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// apply plugins.</span></span><br><span class="line">      <span class="built_in">this</span>.plugins.forEach(<span class="function">(<span class="params">&#123; id, apply &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.pluginsToSkip.has(id)) <span class="keyword">return</span></span><br><span class="line">        apply(<span class="keyword">new</span> PluginAPI(id, <span class="built_in">this</span>), <span class="built_in">this</span>.projectOptions)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// apply webpack configs from project config file</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.projectOptions.chainWebpack) &#123;</span><br><span class="line">        <span class="built_in">this</span>.webpackChainFns.push(<span class="built_in">this</span>.projectOptions.chainWebpack)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.projectOptions.configureWebpack) &#123;</span><br><span class="line">        <span class="built_in">this</span>.webpackRawConfigFns.push(<span class="built_in">this</span>.projectOptions.configureWebpack)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPromise(userOptions)) &#123;</span><br><span class="line">      <span class="keyword">return</span> userOptions.then(loadedCallback)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> loadedCallback(userOptions)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init 执行了两次实例的 loadEnv 函数，第一次是加载指定的模式环境文件（.env.development, .env.development.local），第二次执行是加载普通环境文件 (.env, .env.local)，看一下实例 loadEnv 函数代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载本地的环境文件，环境文件的作用就是设置某个模式下特有的环境变量</span></span><br><span class="line"><span class="comment">// 加载环境变量其实要注意的就是优先级的问题，下面的代码已经体现的非常明显了，先加载 .env.mode.local，然后加载 .env.mode 最后再加载 .env</span></span><br><span class="line"><span class="comment">// 由于环境变量不会被覆盖，因此 .env.mode.local 的优先级最高，.env.mode.local 与 .env.mode 的区别就是前者会被 git 忽略掉。另外一点要</span></span><br><span class="line"><span class="comment">// 注意的就是环境文件不会覆盖Vue CLI 启动时已经存在的环境变量。</span></span><br><span class="line">loadEnv (mode) &#123;</span><br><span class="line">  <span class="keyword">const</span> logger = debug(<span class="string">&#x27;vue:env&#x27;</span>)</span><br><span class="line">  <span class="comment">// path/.env.production || path/.env.development || ...</span></span><br><span class="line">  <span class="keyword">const</span> basePath = path.resolve(<span class="built_in">this</span>.context, <span class="string">`.env<span class="subst">$&#123;mode ? <span class="string">`.<span class="subst">$&#123;mode&#125;</span>`</span> : <span class="string">``</span>&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">const</span> localPath = <span class="string">`<span class="subst">$&#123;basePath&#125;</span>.local`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> load = <span class="function"><span class="params">envPath</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> env = dotenv.config(&#123; <span class="attr">path</span>: envPath, <span class="attr">debug</span>: process.env.DEBUG &#125;) <span class="comment">// 加载指定路径的环境变量</span></span><br><span class="line">      dotenvExpand(env)</span><br><span class="line">      logger(envPath, env)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// only ignore error if file is not found</span></span><br><span class="line">      <span class="keyword">if</span> (err.toString().indexOf(<span class="string">&#x27;ENOENT&#x27;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        error(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  load(localPath)</span><br><span class="line">  load(basePath)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// by default, NODE_ENV and BABEL_ENV are set to &quot;development&quot; unless mode</span></span><br><span class="line">  <span class="comment">// is production or test. However the value in .env files will take higher</span></span><br><span class="line">  <span class="comment">// priority.</span></span><br><span class="line">  <span class="keyword">if</span> (mode) &#123;</span><br><span class="line">    <span class="comment">// always set NODE_ENV during tests</span></span><br><span class="line">    <span class="comment">// as that is necessary for tests to not be affected by each other</span></span><br><span class="line">    <span class="keyword">const</span> shouldForceDefaultEnv = (</span><br><span class="line">      process.env.VUE_CLI_TEST &amp;&amp;</span><br><span class="line">      !process.env.VUE_CLI_TEST_TESTING_ENV</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">const</span> defaultNodeEnv = (mode === <span class="string">&#x27;production&#x27;</span> || mode === <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">      ? mode</span><br><span class="line">      : <span class="string">&#x27;development&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (shouldForceDefaultEnv || process.env.NODE_ENV == <span class="literal">null</span>) &#123;</span><br><span class="line">      process.env.NODE_ENV = defaultNodeEnv</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldForceDefaultEnv || process.env.BABEL_ENV == <span class="literal">null</span>) &#123;</span><br><span class="line">      process.env.BABEL_ENV = defaultNodeEnv</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码我们可以看到 loadEnv 方法的主要作用就是向 node process 中添加环境变量。我们接着查看 loadUserOptions：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: we intentionally make this function synchronous by default</span></span><br><span class="line"><span class="comment">// because eslint-import-resolver-webpack does not support async webpack configs.</span></span><br><span class="line">loadUserOptions () &#123;</span><br><span class="line">  <span class="comment">// fileConfig: import(fileConfigPath)/require(fileConfigPath), fileConfigPath: path.resolve(context, &#x27;./vue.config.js&#x27;)</span></span><br><span class="line">  <span class="keyword">const</span> &#123; fileConfig, fileConfigPath &#125; = loadFileConfig(<span class="built_in">this</span>.context)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isPromise(fileConfig)) &#123;</span><br><span class="line">    <span class="keyword">return</span> fileConfig</span><br><span class="line">      .then(<span class="function"><span class="params">mod</span> =&gt;</span> mod.default)</span><br><span class="line">      .then(<span class="function"><span class="params">loadedConfig</span> =&gt;</span> resolveUserConfig(&#123;</span><br><span class="line">        inlineOptions: <span class="built_in">this</span>.inlineOptions,</span><br><span class="line">        pkgConfig: <span class="built_in">this</span>.pkg.vue,</span><br><span class="line">        fileConfig: loadedConfig,</span><br><span class="line">        fileConfigPath</span><br><span class="line">      &#125;))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resolveUserConfig(&#123;</span><br><span class="line">    inlineOptions: <span class="built_in">this</span>.inlineOptions,</span><br><span class="line">    pkgConfig: <span class="built_in">this</span>.pkg.vue, <span class="comment">// package.json 里面的 vue config</span></span><br><span class="line">    fileConfig,</span><br><span class="line">    fileConfigPath</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码中的 loadFileConfig 方法的主要作用是配置文件路径的获取及内容解析，其首先会在遍历 ‘./vue.config.js’、’./vue.config.cjs’、’./vue.config.mjs’ 查看当前项目目录下是否存在对应文件，如果存在则判断文件内容是否遵从 ESModule 规范？如果遵从则通过 import 方法获取文件内容，如果不是则通过 require 方法获取。在获取到配置文件内容后紧接着调用了 resolveUserConfig 函数，我们接着查看其实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">resolveUserConfig</span> (<span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  inlineOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  pkgConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  fileConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">  fileConfigPath</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fileConfig) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fileConfig === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      fileConfig = fileConfig()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fileConfig || <span class="keyword">typeof</span> fileConfig !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">`Error loading <span class="subst">$&#123;chalk.bold(fileConfigPath)&#125;</span>: `</span> +</span><br><span class="line">        <span class="string">`should export an object or a function that returns object.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// package.vue</span></span><br><span class="line">  <span class="keyword">if</span> (pkgConfig &amp;&amp; <span class="keyword">typeof</span> pkgConfig !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">`Error loading Vue CLI config in <span class="subst">$&#123;chalk.bold(<span class="string">`package.json`</span>)&#125;</span>: `</span> +</span><br><span class="line">      <span class="string">`the &quot;vue&quot; field should be an object.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> resolved, resolvedFrom</span><br><span class="line">  <span class="comment">// 既有 vue.config.js 而且在 package.json 里面又包含了 vue 的配置，将会取 vue.config.js 的配置</span></span><br><span class="line">  <span class="keyword">if</span> (fileConfig) &#123;</span><br><span class="line">    <span class="keyword">const</span> configFileName = path.basename(fileConfigPath)</span><br><span class="line">    <span class="keyword">if</span> (pkgConfig) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`&quot;vue&quot; field in package.json ignored `</span> +</span><br><span class="line">        <span class="string">`due to presence of <span class="subst">$&#123;chalk.bold(configFileName)&#125;</span>.`</span></span><br><span class="line">      )</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`You should migrate it into <span class="subst">$&#123;chalk.bold(configFileName)&#125;</span> `</span> +</span><br><span class="line">        <span class="string">`and remove it from package.json.`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    resolved = fileConfig</span><br><span class="line">    resolvedFrom = configFileName</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkgConfig) &#123;</span><br><span class="line">    resolved = pkgConfig</span><br><span class="line">    resolvedFrom = <span class="string">&#x27;&quot;vue&quot; field in package.json&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolved = inlineOptions || &#123;&#125;</span><br><span class="line">    resolvedFrom = <span class="string">&#x27;inline options&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// normalize some options</span></span><br><span class="line">  <span class="keyword">if</span> (resolved.publicPath !== <span class="string">&#x27;auto&#x27;</span>) &#123;</span><br><span class="line">    ensureSlash(resolved, <span class="string">&#x27;publicPath&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> resolved.publicPath === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    resolved.publicPath = resolved.publicPath.replace(<span class="regexp">/^\.\//</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  removeSlash(resolved, <span class="string">&#x27;outputDir&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// validate options</span></span><br><span class="line">  validate(resolved, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    error(<span class="string">`Invalid options in <span class="subst">$&#123;chalk.bold(resolvedFrom)&#125;</span>: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resolved</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码首先会加载项目中 vue.config.js，然后会加载 package.json 中的 vue 字段中的配置信息。如果既有 vue.config.js 而且在 package.json 里面又包含了 vue 的配置，将会取 vue.config.js 的配置，如果两者都没有配置信息的话会取 this.inlineOptions || {}， 在获取到配置以后还会进行一些处理和验证，最后返回配置 resolved 。</p><p>在通过 loadUserOptions 方法完成了配置文件的解析及获取后紧接着便开始加载插件，核心代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply plugins.</span></span><br><span class="line"><span class="built_in">this</span>.plugins.forEach(<span class="function">(<span class="params">&#123; id, apply &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.pluginsToSkip.has(id)) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// service 插件接受两个参数，一个 PluginAPI 实例，一个包含 vue.config.js 内指定的项目本地选项的对象，或者在 package.json 内的 vue 字段。</span></span><br><span class="line">  apply(<span class="keyword">new</span> PluginAPI(id, <span class="built_in">this</span>), <span class="built_in">this</span>.projectOptions)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>PluginAPI 类的核心代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: if a plugin-registered command needs to run in a specific default mode,</span></span><br><span class="line"><span class="comment">// the plugin needs to expose it via `module.exports.defaultModes` in the form</span></span><br><span class="line"><span class="comment">// of &#123; [commandName]: mode &#125;. This is because the command mode needs to be</span></span><br><span class="line"><span class="comment">// known and applied before loading user options / applying plugins.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PluginAPI</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">id</span></span> - Id of the plugin.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Service&#125;</span> <span class="variable">service</span></span> - A vue-cli-service instance.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">id, service</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id</span><br><span class="line">    <span class="built_in">this</span>.service = service</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get version () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;../package.json&#x27;</span>).version</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assertVersion (range) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> range === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(range)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected string or integer value.&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      range = <span class="string">`^<span class="subst">$&#123;range&#125;</span>.0.0-0`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> range !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Expected string or integer value.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (semver.satisfies(<span class="built_in">this</span>.version, range, &#123; <span class="attr">includePrerelease</span>: <span class="literal">true</span> &#125;)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="string">`Require @vue/cli-service &quot;<span class="subst">$&#123;range&#125;</span>&quot;, but was loaded with &quot;<span class="subst">$&#123;<span class="built_in">this</span>.version&#125;</span>&quot;.`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Current working directory.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getCwd () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.service.context</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Resolve path for a project.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">_path</span></span> - Relative path from project root</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;string&#125;</span> </span>The resolved absolute path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  resolve (_path) &#123;</span><br><span class="line">    <span class="keyword">return</span> path.resolve(<span class="built_in">this</span>.service.context, _path)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Check if the project has a given plugin.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">id</span></span> - Plugin id, can omit the (<span class="doctag">@vue</span>/|vue-|<span class="doctag">@scope</span>/vue)-cli-plugin- prefix</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  hasPlugin (id) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.service.plugins.some(<span class="function"><span class="params">p</span> =&gt;</span> matchesPluginId(id, p.id))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Register a command that will become available as `vue-cli-service [name]`.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">name</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>[opts]</span></span><br><span class="line"><span class="comment">   *   &#123;</span></span><br><span class="line"><span class="comment">   *     description: string,</span></span><br><span class="line"><span class="comment">   *     usage: string,</span></span><br><span class="line"><span class="comment">   *     options: &#123; [string]: string &#125;</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">fn</span></span></span></span><br><span class="line"><span class="comment">   *   (args: &#123; [string]: string &#125;, rawArgs: string[]) =&gt; ?Promise</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  registerCommand (name, opts, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> opts === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      fn = opts</span><br><span class="line">      opts = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.service.commands[name] = &#123; fn, <span class="attr">opts</span>: opts || &#123;&#125; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Register a function that will receive a chainable webpack config</span></span><br><span class="line"><span class="comment">   * the function is lazy and won&#x27;t be called until `resolveWebpackConfig` is</span></span><br><span class="line"><span class="comment">   * called</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">fn</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  chainWebpack (fn) &#123;</span><br><span class="line">    <span class="built_in">this</span>.service.webpackChainFns.push(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Register</span></span><br><span class="line"><span class="comment">   * - a webpack configuration object that will be merged into the config</span></span><br><span class="line"><span class="comment">   * OR</span></span><br><span class="line"><span class="comment">   * - a function that will receive the raw webpack config.</span></span><br><span class="line"><span class="comment">   *   the function can either mutate the config directly or return an object</span></span><br><span class="line"><span class="comment">   *   that will be merged into the config.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;object | function&#125;</span> <span class="variable">fn</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  configureWebpack (fn) &#123;</span><br><span class="line">    <span class="built_in">this</span>.service.webpackRawConfigFns.push(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Register a dev serve config function. It will receive the express `app`</span></span><br><span class="line"><span class="comment">   * instance of the dev server.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">fn</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  configureDevServer (fn) &#123;</span><br><span class="line">    <span class="built_in">this</span>.service.devServerConfigFns.push(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Resolve the final raw webpack config, that will be passed to webpack.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;ChainableWebpackConfig&#125;</span> </span>[chainableConfig]</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;object&#125;</span> </span>Raw webpack config.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  resolveWebpackConfig (chainableConfig) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.service.resolveWebpackConfig(chainableConfig)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Resolve an intermediate chainable webpack config instance, which can be</span></span><br><span class="line"><span class="comment">   * further tweaked before generating the final raw webpack config.</span></span><br><span class="line"><span class="comment">   * You can call this multiple times to generate different branches of the</span></span><br><span class="line"><span class="comment">   * base webpack config.</span></span><br><span class="line"><span class="comment">   * See https://github.com/mozilla-neutrino/webpack-chain</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;ChainableWebpackConfig&#125;</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  resolveChainableWebpackConfig () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.service.resolveChainableWebpackConfig()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Generate a cache identifier from a number of variables</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  genCacheConfig (id, partialIdentifier, configFiles = []) &#123;</span><br><span class="line">    <span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> cacheDirectory = <span class="built_in">this</span>.resolve(<span class="string">`node_modules/.cache/<span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replace \r\n to \n generate consistent hash</span></span><br><span class="line">    <span class="keyword">const</span> fmtFunc = <span class="function"><span class="params">conf</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> conf === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> conf.toString().replace(<span class="regexp">/\r\n?/g</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> conf</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> variables = &#123;</span><br><span class="line">      partialIdentifier,</span><br><span class="line">      <span class="string">&#x27;cli-service&#x27;</span>: <span class="built_in">require</span>(<span class="string">&#x27;../package.json&#x27;</span>).version,</span><br><span class="line">      env: process.env.NODE_ENV,</span><br><span class="line">      test: !!process.env.VUE_CLI_TEST,</span><br><span class="line">      config: [</span><br><span class="line">        fmtFunc(<span class="built_in">this</span>.service.projectOptions.chainWebpack),</span><br><span class="line">        fmtFunc(<span class="built_in">this</span>.service.projectOptions.configureWebpack)</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      variables[<span class="string">&#x27;cache-loader&#x27;</span>] = <span class="built_in">require</span>(<span class="string">&#x27;cache-loader/package.json&#x27;</span>).version</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// cache-loader is only intended to be used for webpack 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(configFiles)) &#123;</span><br><span class="line">      configFiles = [configFiles]</span><br><span class="line">    &#125;</span><br><span class="line">    configFiles = configFiles.concat([</span><br><span class="line">      <span class="string">&#x27;package-lock.json&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;yarn.lock&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;pnpm-lock.yaml&#x27;</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> readConfig = <span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> absolutePath = <span class="built_in">this</span>.resolve(file)</span><br><span class="line">      <span class="keyword">if</span> (!fs.existsSync(absolutePath)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (absolutePath.endsWith(<span class="string">&#x27;.js&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// should evaluate config scripts to reflect environment variable changes</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="built_in">require</span>(absolutePath))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="keyword">return</span> fs.readFileSync(absolutePath, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fs.readFileSync(absolutePath, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    variables.configFiles = configFiles.map(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> content = readConfig(file)</span><br><span class="line">      <span class="keyword">return</span> content &amp;&amp; content.replace(<span class="regexp">/\r\n?/g</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cacheIdentifier = hash(variables)</span><br><span class="line">    <span class="keyword">return</span> &#123; cacheDirectory, cacheIdentifier &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = PluginAPI</span><br></pre></td></tr></table></figure><p>简单介绍一些 PluginAPI 常用的方法：</p><ul><li>registerCommand: 注册 cli 命令服务</li><li>chainWebpack: 通过 webpack-chain 修改 webpack 配置</li><li>configureWebpack: 通过 webpack-merge 对 webpack 配置进行合并</li><li>resolveWebpackConfig: 调用之前通过 chainWebpack 和 configureWebpack 上完成的对于 webpack 配置的改造，并返回最终的 webpack 配置</li><li>genCacheConfig: 返回 cacheDirectory, cacheIdentifier</li><li>…</li></ul><p>系统的内置插件 builtInPlugins 例如 ‘./commands/serve’、’./commands/build’ 等也是通过调用 PluginAPI 提供的具体方法实现其功能，我们以 serve 命令为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @vue/cli-service/lib/commands/serve.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">api, options</span>) =&gt;</span> &#123;</span><br><span class="line">  api.registerCommand(<span class="string">&#x27;serve&#x27;</span>, &#123;</span><br><span class="line">    description: <span class="string">&#x27;start development server&#x27;</span>,</span><br><span class="line">    usage: <span class="string">&#x27;vue-cli-service serve [options] [entry]&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="string">&#x27;--open&#x27;</span>: <span class="string">`open browser on server start`</span>,</span><br><span class="line">      <span class="string">&#x27;--copy&#x27;</span>: <span class="string">`copy url to clipboard on server start`</span>,</span><br><span class="line">      <span class="string">&#x27;--mode&#x27;</span>: <span class="string">`specify env mode (default: development)`</span>,</span><br><span class="line">      <span class="string">&#x27;--host&#x27;</span>: <span class="string">`specify host (default: <span class="subst">$&#123;defaults.host&#125;</span>)`</span>,</span><br><span class="line">      <span class="string">&#x27;--port&#x27;</span>: <span class="string">`specify port (default: <span class="subst">$&#123;defaults.port&#125;</span>)`</span>,</span><br><span class="line">      <span class="string">&#x27;--https&#x27;</span>: <span class="string">`use https (default: <span class="subst">$&#123;defaults.https&#125;</span>)`</span>,</span><br><span class="line">      <span class="string">&#x27;--public&#x27;</span>: <span class="string">`specify the public network URL for the HMR client`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">serve</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// resolveWebpackConfig</span></span><br><span class="line">   <span class="comment">// create server</span></span><br><span class="line">   <span class="comment">// ....</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 api.registerCommand 注册了 serve 命名，并将 serve 命令的处理函数挂载到 Service 实例的 serve 命令中，当然你还可以通过 module.exports.defaultModes 以 <code>&#123; [commandName]: mode &#125;</code> 的形式来指定命令的运行模式。</p><p>分析到这里你应该逐渐熟悉 vue-cli 3.0 的插件机制了，vue-cli 3.0 将所有的工作都交给插件去执行，开发模式执行内置 serve 插件，打包执行内置 build 插件，检查代码规范由 @vue/cli-plugin-eslint 插件完成。</p><p>在加载完所有的插件以后，实例的 init 方法在最后会读取项目配置中的 webpack 配置信息，即 chainWebpack 和 configureWebpack，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply webpack configs from project config file</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.projectOptions.chainWebpack) &#123;</span><br><span class="line">  <span class="built_in">this</span>.webpackChainFns.push(<span class="built_in">this</span>.projectOptions.chainWebpack)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.projectOptions.configureWebpack) &#123;</span><br><span class="line">  <span class="built_in">this</span>.webpackRawConfigFns.push(<span class="built_in">this</span>.projectOptions.configureWebpack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例的 run 函数中执行了实例 init 函数对 Service 实例的属性进行初始化后就会解析 CLI 命令，具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">args._ = args._ || []</span><br><span class="line"><span class="keyword">let</span> command = <span class="built_in">this</span>.commands[name] <span class="comment">// 加载插件时注册了 command，api.registerCommand</span></span><br><span class="line"><span class="keyword">if</span> (!command &amp;&amp; name) &#123; <span class="comment">// 非法命令</span></span><br><span class="line">  error(<span class="string">`command &quot;<span class="subst">$&#123;name&#125;</span>&quot; does not exist.`</span>)</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!command || args.help) &#123; <span class="comment">// vue-cli-service || vue-cli-service -h</span></span><br><span class="line">  command = <span class="built_in">this</span>.commands.help</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  args._.shift() <span class="comment">// remove command itself</span></span><br><span class="line">  rawArgv.shift()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; fn &#125; = command</span><br><span class="line"><span class="keyword">return</span> fn(args, rawArgv)</span><br></pre></td></tr></table></figure><p>会先对 CLI 命令进行一个判断，主要有一下三种情况：</p><ul><li>输入了命令 name ，但是并没有通过 api.registerCommand 注册，即非法命令，process.exit(1)</li><li>直接输入了 vue-cli-service 或者 vue-cli-service --help，加载内置 help 插件</li><li>正常输入，eg: vue-cli-service test:unit，这种情况会加载对应地单元测试插件 @vue/cli-plugin-unit-jest || @vue/cli-plugin-unit-mocha，并执行插件内与对应 test 命令指定的处理函数。</li></ul><h4 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4、总结</h4><p>至此 @vue/cli-service 的分析就完成了，@vue/cli-service 的主要作用就是提供了 vue-cli-service 命令，但是与一般 node 命令文件有点不同，@vue/cli-service 并没有直接提供相关 serve、build 等 CLI 命令的服务。具体实现主要是通过 Service 实例的 run 方法，run 方法主要执行了环境变量文件加载，获取项目配置信息，合并项目配置，加载插件，加载项目配置中的 webpack 信息，最后 执行 CLI 服务，常见的 serve 和 build 指令也是通过系统提供的内置插件实现的，在下面我们将详细介绍 Vue CLI 的最后一个核心内容：插件。</p><h3 id="四-插件"><a class="markdownIt-Anchor" href="#四-插件"></a> 四、插件</h3><p>（已经六万字了，，，我当时论文都没这么多字😭）</p><p>通过前文对于 @vue/cli 和 @vue/cli-service 的介绍我们也已经初步知道了 Vue CLI 中插件的重要性，一个 CLI 插件是一个 npm 包，它能够为 Vue CLI 创建的项目添加额外的功能，这些功能包括：</p><ul><li>修改项目的 webpack 配置 - 例如，如果你的插件希望去针对某种类型的文件工作，你可以为这个特定的文件扩展名添加新的 webpack 解析规则。比如说，@vue/cli-plugin-typescript 就添加这样的规则来解析 .ts 和 .tsx 扩展的文件；</li><li>添加新的 vue-cli-service 命令 - 例如，@vue/cli-plugin-unit-jest 添加了 test:unit 命令，允许开发者运行单元测试；</li><li>扩展 package.json - 当你的插件添加了一些依赖到项目中，你需要将他们添加到 package 的 dependencies 部分时，这是一个有用的选项；</li><li>在项目中创建新文件、或者修改老文件。有时创建一个示例组件或者通过给入口文件（main.js）添加导入（imports）是一个好的主意；</li><li>提示用户选择一个特定的选项 - 例如，你可以询问用户是否创建我们前面提到的示例组件。</li></ul><p>CLI 插件应该总是包含一个 service 插件 做为主的导出，并且他能够选择性的包含 generator, prompt 文件 和 Vue UI 集成。</p><p>作为一个 npm 包，CLI 插件必须有一个 package.json 文件。通常建议在 <a href="http://README.md">README.md</a> 中包含插件的描述，来帮助其他人在 npm 上发现你的插件。</p><p>所以，通常的 CLI 插件目录结构看起来像下面这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── generator.js  <span class="comment"># generator（可选）</span></span><br><span class="line">├── index.js      <span class="comment"># service 插件</span></span><br><span class="line">├── package.json</span><br><span class="line">├── prompts.js    <span class="comment"># prompt 文件（可选）</span></span><br><span class="line">└── ui.js         <span class="comment"># Vue UI 集成（可选）</span></span><br></pre></td></tr></table></figure><h4 id="1-packagejson"><a class="markdownIt-Anchor" href="#1-packagejson"></a> 1、package.json</h4><p>为了让一个 CLI 插件在 Vue CLI 项目中被正常使用，它必须遵循 vue-cli-plugin-<name> 或者 @scope/vue-cli-plugin-<name> 这样的命名惯例。这样你的插件才能够：</p><ul><li>被 @vue/cli-service 发现;</li><li>被其他开发者通过搜索发现;</li><li>通过 <code>vue add &lt;name&gt;</code> 或者 <code>vue invoke &lt;name&gt;</code> 安装;</li></ul><p>为了能够被用户在搜索时更好的发现，keywords 尽可能多写一些项目相关的词，同时可以将插件的关键描述放到 description 字段中。</p><p>例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;vue-cli-plugin-apollo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.7.7&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;vue-cli plugin to add Apollo and GraphQL&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你应该在 homepage 或者 repository 字段添加创建插件的官网地址或者仓库的地址，这样你的插件详情里就会出现一个 查看详情 按钮：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;repository&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;git+https://github.com/Akryum/vue-cli-plugin-apollo.git&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span>: <span class="string">&quot;https://github.com/Akryum/vue-cli-plugin-apollo#readme&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-generator"><a class="markdownIt-Anchor" href="#2-generator"></a> 2、generator</h4><p>插件的 Generator 部分通常在你想要为项目扩展包依赖，创建新的文件或者编辑已经存在的文件时需要。在 CLI 插件内部，generator 应该放在 generator.js 或者 generator/index.js 文件中。它将在以下两个场景被调用：</p><ul><li>项目初始创建期间，CLI 插件被作为项目创建 preset 的一部分被安装时。</li><li>当插件在项目创建完成和通过 vue add 或者 vue invoke 单独调用被安装时。</li></ul><p>一个 generator 应该导出一个接收三个参数的函数：</p><p>1、一个 GeneratorAPI 实例；</p><p>2、插件的 generator 选项。这些选项在项目创建，或者从 ~/.vuerc 载入预设时被解析。例如：如果保存的 ~/.vuerc 像这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;foo&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;plugins&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@vue/cli-plugin-foo&quot;</span>: &#123; <span class="attr">&quot;option&quot;</span>: <span class="string">&quot;bar&quot;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户使用 preset foo 创建了一个项目，那么 @vue/cli-plugin-foo 的 generator 就会收到 { option: ‘bar’ } 作为第二个参数。</p><p>对于第三方插件，这个选项将在用户执行 vue invoke 时，从提示或者命令行参数中被解析。</p><p>3、整个 preset (presets.foo) 将会作为第三个参数传入。</p><p>关于 GeneratorAPI 我们已经在前面解析 @vue/cli 的过程中进行了详细介绍，那么我们通过 GeneratorAPI 可以实现哪些功能呢？</p><p><strong>1、创建新的模板</strong></p><p>当你调用 api.render(’./template’) 时，该 generator 将会使用 EJS 渲染 ./template 中的文件 (相对于 generator 中的文件路径进行解析)</p><p>想象我们正在创建 vue-cli-auto-routing 插件，我们希望当插件在项目中被引用时做以下的改变：</p><ul><li>创建一个 layouts 文件夹包含默认布局文件；</li><li>创建一个 pages 文件夹包含 about 和 home 页面；</li><li>在 src 文件夹中添加 router.js 文件</li></ul><p>为了渲染这个结构，你需要在 generator/template 文件夹内创建它：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── src</span><br><span class="line"> ├── layouts</span><br><span class="line">  ├── default.vue</span><br><span class="line"> ├── pages</span><br><span class="line">  ├── about.vue</span><br><span class="line">  ├── home.vue</span><br><span class="line"> ├── router</span><br><span class="line">  └── index.js</span><br></pre></td></tr></table></figure><p>模板创建完之后，我们就可以在 generator/index.js 文件中添加 api.render(’./template’) 来调用。</p><p>不过需要注意文件名的边界情况，如果你想要渲染一个以点开头的模板文件 (例如 .env)，则需要遵循一个特殊的命名约定，因为以点开头的文件会在插件发布到 npm 的时候被忽略：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以点开头的模板需要使用下划线取代那个点：</span></span><br><span class="line"></span><br><span class="line">/generator/template/_env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当调用 api.render(&#x27;./template&#x27;) 时，它在项目文件夹中将被渲染为：</span></span><br><span class="line"></span><br><span class="line">/generator/template/.env</span><br></pre></td></tr></table></figure><p>同时这也意味着当你想渲染以下划线开头的文件时，同样需要遵循一个特殊的命名约定：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这种模板需要使用两个下划线来取代单个下划线：</span></span><br><span class="line"></span><br><span class="line">/generator/template/__variables.scss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当调用 api.render(&#x27;./template&#x27;) 时，它在项目文件夹中将被渲染为：</span></span><br><span class="line"></span><br><span class="line">/generator/template/_variable.scss</span><br></pre></td></tr></table></figure><p><strong>2、编辑已经存在的模板</strong></p><p>此外，你可以使用 YAML 前置元信息继承并替换已有的模板文件的一部分（即使来自另一个包）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">extend:</span> <span class="string">&#x27;@vue/cli-service/generator/template/src/App.vue&#x27;</span></span><br><span class="line"><span class="attr">replace:</span> <span class="type">!!js/regexp</span> <span class="string">/&lt;script&gt;[^]*?&lt;\/script&gt;/</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">export</span> <span class="string">default</span> &#123;</span><br><span class="line">  <span class="string">//</span> <span class="string">替换默认脚本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>也可以替换多处，只不过你需要将替换的字符串包裹在 &lt;%# REPLACE %&gt; 和 &lt;%# END_REPLACE %&gt; 块中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">extend:</span> <span class="string">&#x27;@vue/cli-service/generator/template/src/App.vue&#x27;</span></span><br><span class="line"><span class="attr">replace:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="type">!!js/regexp</span> <span class="string">/Welcome</span> <span class="string">to</span> <span class="string">Your</span> <span class="string">Vue\.js</span> <span class="string">App/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="type">!!js/regexp</span> <span class="string">/&lt;script&gt;[^]*?&lt;\/script&gt;</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line">&lt;%<span class="ruby"><span class="comment"># REPLACE </span></span>%&gt;</span><br><span class="line"><span class="string">替换欢迎信息</span></span><br><span class="line">&lt;%<span class="ruby"><span class="comment"># END_REPLACE </span></span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%<span class="ruby"><span class="comment"># REPLACE </span></span>%&gt;</span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">export</span> <span class="string">default</span> &#123;</span><br><span class="line">  <span class="string">//</span> <span class="string">替换默认脚本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line">&lt;%<span class="ruby"><span class="comment"># END_REPLACE </span></span>%&gt;</span><br></pre></td></tr></table></figure><p><strong>3、扩展包</strong></p><p>如果你需要向项目中添加额外的依赖，创建一个 npm 脚本或者修改 package.json 的其他任何一处，你可以使用 API extendPackage 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">api</span> =&gt;</span> &#123;</span><br><span class="line">  api.extendPackage(&#123;</span><br><span class="line">    dependencies: &#123;</span><br><span class="line">      <span class="string">&#x27;vue-router-layout&#x27;</span>: <span class="string">&#x27;^0.1.2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，我们添加了一个依赖：vue-router-layout。在插件调用时，这个 npm 模块将被安装，这个依赖将被添加到用户项目的 package.json 文件。</p><p>同样使用这个 API 我们可以添加新的 npm 任务到项目中。为了实现这个，我们需要定义一个任务名和一个命令，这样他才能够在用户 package.json 文件的 scripts 部分运行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">api</span> =&gt;</span> &#123;</span><br><span class="line">  api.extendPackage(&#123;</span><br><span class="line">    scripts: &#123;</span><br><span class="line">      greet: <span class="string">&#x27;vue-cli-service greet&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，我们添加了一个新的 greet 任务来执行一个创建在 Service 部分 的自定义 vue-cli 服务命令。</p><p><strong>4、修改主文件</strong></p><p>通过 generator 方法你能够修改项目中的文件。最有用的场景是针对 main.js 或 main.ts 文件的一些修改：新的导入，新的 Vue.use() 调用等。</p><p>让我们来思考一个场景，当我们通过 模板 创建了一个 router.js 文件，现在我们希望导入这个路由到主文件中。我们将用到两个 generator API 方法： entryFile 将返回项目的主文件（main.js 或 main.ts），injectImports 用于添加新的导入到主文件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator/index.js</span></span><br><span class="line"></span><br><span class="line">api.injectImports(api.entryFile, <span class="string">`import router from &#x27;./router&#x27;`</span>)</span><br></pre></td></tr></table></figure><p>现在，当我们路由被导入时，我们可以在主文件中将这个路由注入到 Vue 实例。我们可以使用 afterInvoke 钩子，这个钩子将在文件被写入硬盘之后被调用。</p><p>首先，我们需要通过 Node 的 fs 模块（提供了文件交互 API）读取文件内容，将内容拆分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.hooks = <span class="function">(<span class="params">api</span>) =&gt;</span> &#123;</span><br><span class="line">  api.afterInvoke(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> contentMain = fs.readFileSync(api.resolve(api.entryFile), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> lines = contentMain.split(<span class="regexp">/\r?\n/g</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们需要找到包含 render 单词的字符串（它通常是 Vue 实例的一部分），router 就是下一个字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.hooks = <span class="function">(<span class="params">api</span>) =&gt;</span> &#123;</span><br><span class="line">  api.afterInvoke(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> contentMain = fs.readFileSync(api.resolve(api.entryFile), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> lines = contentMain.split(<span class="regexp">/\r?\n/g</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> renderIndex = lines.findIndex(<span class="function"><span class="params">line</span> =&gt;</span> line.match(<span class="regexp">/render/</span>))</span><br><span class="line">    lines[renderIndex] += <span class="string">`\n router,`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，你需要将内容写入主文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.hooks = <span class="function">(<span class="params">api</span>) =&gt;</span> &#123;</span><br><span class="line">  api.afterInvoke(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; EOL &#125; = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> contentMain = fs.readFileSync(api.resolve(api.entryFile), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> lines = contentMain.split(<span class="regexp">/\r?\n/g</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> renderIndex = lines.findIndex(<span class="function"><span class="params">line</span> =&gt;</span> line.match(<span class="regexp">/render/</span>))</span><br><span class="line">    lines[renderIndex] += <span class="string">`<span class="subst">$&#123;EOL&#125;</span>  router,`</span></span><br><span class="line"></span><br><span class="line">    fs.writeFileSync(api.entryFile, lines.join(EOL), &#123; <span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-service-插件"><a class="markdownIt-Anchor" href="#3-service-插件"></a> 3、service 插件</h4><p>Service 插件可以修改 webpack 配置，创建新的 vue-cli service 命令或者修改已经存在的命令（如 serve 和 build）。</p><p>Service 插件在 Service 实例被创建后自动加载 - 例如，每次 vue-cli-service 命令在项目中被调用的时候。它位于 CLI 插件根目录的 index.js 文件。</p><p>一个 service 插件应该导出一个函数，这个函数接受两个参数：</p><ul><li>一个 PluginAPI 实例</li><li>一个包含 vue.config.js 内指定的项目本地选项的对象，或者在 package.json 内的 vue 字段。</li></ul><p>PluginAPI 为 service 插件提供了针对不同的环境扩展/修改内部的 webpack 配置的能力。例如，这里我们在 webpack-chain 中添加 vue-auto-routing 这个 webpack 插件，并指定参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueAutoRoutingPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-auto-routing/lib/webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">api, options</span>) =&gt;</span> &#123;</span><br><span class="line">  api.chainWebpack(<span class="function"><span class="params">webpackConfig</span> =&gt;</span> &#123;</span><br><span class="line">    webpackConfig</span><br><span class="line">    .plugin(<span class="string">&#x27;vue-auto-routing&#x27;</span>)</span><br><span class="line">      .use(VueAutoRoutingPlugin, [</span><br><span class="line">        &#123;</span><br><span class="line">          pages: <span class="string">&#x27;src/pages&#x27;</span>,</span><br><span class="line">          nested: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以使用 configureWebpack 方法修改 webpack 配置或者返回一个对象，返回的对象将通过 webpack-merge 被合并到配置中。</p><p>除了修改 webpack 配置之外我们还可以通过 Service 插件实现如下功能：</p><p><strong>1、添加一个新的 cli-service 命令</strong></p><p>通过 service 插件你可以注册一个新的 cli-service 命令，除了标准的命令（即 serve 和 build）。你可以使用 registerCommand API 方法实现。</p><p>下面的例子创建了一个简单的新命令，可以向开发控制台输出一条问候语：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">api.registerCommand(</span><br><span class="line">  <span class="string">&#x27;greet&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    description: <span class="string">&#x27;Write a greeting to the console&#x27;</span>,</span><br><span class="line">    usage: <span class="string">&#x27;vue-cli-service greet&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`👋  Hello`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们提供了命令的名字（‘greet’）、一个有 description 和 usage 选项的对象，和一个在执行 vue-cli-service greet 命令时会调用的函数。</p><p>如果你在已经安装了插件的项目中运行新命令，你将看到下面的输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vue-cli-service greet</span><br><span class="line">👋 Hello!</span><br></pre></td></tr></table></figure><p>你也可以给新命令定义一系列可能的选项。接下来我们添加一个 --name 选项，并修改实现函数，当提供了 name 参数时把它也打印出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">api.registerCommand(</span><br><span class="line">  <span class="string">&#x27;greet&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    description: <span class="string">&#x27;Writes a greeting to the console&#x27;</span>,</span><br><span class="line">    usage: <span class="string">&#x27;vue-cli-service greet [options]&#x27;</span>,</span><br><span class="line">    options: &#123; <span class="string">&#x27;--name&#x27;</span>: <span class="string">&#x27;specifies a name for greeting&#x27;</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  args =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.name) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`👋 Hello, <span class="subst">$&#123;args.name&#125;</span>!`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`👋 Hello!`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>现在，如果 greet 命令携带了特定的 --name 选项，这个 name 被添加到控制台输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vue-cli-service greet --name <span class="string">&#x27;John Doe&#x27;</span></span><br><span class="line">👋 Hello, John Doe!</span><br></pre></td></tr></table></figure><p><strong>2、修改已经存在的 cli-service 命令</strong></p><p>如果你想修改一个已经存在的 cli-service 命令，你可以使用 api.service.commands 获取到命令对象并且做些改变。我们将在应用程序运行的端口打印一条信息到控制台：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; serve &#125; = api.service.commands</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serveFn = serve.fn</span><br><span class="line"></span><br><span class="line">serve.fn = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> serveFn(...args).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">res &amp;&amp; res.url</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Project is running now at <span class="subst">$&#123;res.url&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的这个例子中，我们从已经存在的命令列表中获取到命令对象 serve；然后我们修改了他的 fn 部分（fn 是创建这个新命令时传入的第三个参数；它定义了在执行这个命令时要执行的函数）。修改完后，这个控制台消息将在 serve 命令成功运行后打印。</p><p><strong>3、为命令指定模式</strong></p><p>如果一个已注册的插件命令需要运行在特定的默认模式下，则该插件需要通过 module.exports.defaultModes 以 { [commandName]: mode } 的形式来暴露：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">api</span> =&gt;</span> &#123;</span><br><span class="line">  api.registerCommand(<span class="string">&#x27;build&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.defaultModes = &#123;</span><br><span class="line">  build: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为我们需要在加载环境变量之前知道该命令的预期模式，所以需要提前加载用户选项/应用插件。</p><h4 id="4-prompt-文件"><a class="markdownIt-Anchor" href="#4-prompt-文件"></a> 4、prompt 文件</h4><p>对话是在创建一个新的项目或者在已有项目中添加新的插件时处理用户选项时需要的。所有的对话逻辑都存储在 prompts.js 文件中。对话内部是通过 inquirer 实现。</p><p>当用户通过调用 vue invoke 初始化插件时，如果插件根目录包含 prompts.js，它将在调用时被使用。这个文件应该导出一个问题数组 – 将被 Inquirer.js 处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prompts.js </span></span><br><span class="line"><span class="comment">// 直接返回问题数组</span></span><br><span class="line"><span class="built_in">module</span>.exports = [</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;locale&#x27;</span>,</span><br><span class="line">    message: <span class="string">&#x27;The locale of project localization.&#x27;</span>,</span><br><span class="line">    validate: <span class="function"><span class="params">input</span> =&gt;</span> !!input,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">&#x27;en&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回问题数组的函数</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">pkg</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> prompts = [</span><br><span class="line">    &#123;</span><br><span class="line">      type: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;locale&#x27;</span>,</span><br><span class="line">      message: <span class="string">&#x27;The locale of project localization.&#x27;</span>,</span><br><span class="line">      validate: <span class="function"><span class="params">input</span> =&gt;</span> !!input,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">&#x27;en&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加动态对话</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;@vue/cli-plugin-eslint&#x27;</span> <span class="keyword">in</span> (pkg.devDependencies || &#123;&#125;)) &#123;</span><br><span class="line">    prompts.push(&#123;</span><br><span class="line">      type: <span class="string">&#x27;confirm&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;useESLintPluginVueI18n&#x27;</span>,</span><br><span class="line">      message: <span class="string">&#x27;Use ESLint plugin for Vue I18n ?&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prompts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析到的答案对象将作为选项传入到插件的 generator。如果我们想在 generator 中使用用户的选择结果，可以通过对话名字获得。例如我们可以修改一下 generator/index.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.useESLintPluginVueI18n) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-vue-ui-集成"><a class="markdownIt-Anchor" href="#5-vue-ui-集成"></a> 5、Vue UI 集成</h4><p>Vue CLI 有一个非常强大的 UI 工具 – 允许用户通过图形接口来架构和管理项目。Vue CLI 插件能够集成到接口中。UI 为 CLI 插件提供了额外的功能：</p><ul><li>可以执行 npm 任务，直接在 UI 中执行插件中定义的命令；</li><li>可以展示插件的自定义配置。</li><li>当创建项目时，你可以展示对话</li><li>如果你想支持多种语言，你可以为你的插件添加本地化</li><li>你可以使插件在 Vue UI 搜索中被搜索到</li></ul><p>图形化配置及管理也是 Vue CLI 最新架构的一个重要亮点，个人感觉实际插件开发比较少用，所以此处不再展开，详细配置方法请查看<a href="https://cli.vuejs.org/zh/dev-guide/plugin-dev.html#ui-%E9%9B%86%E6%88%90">官方文档</a></p><p>至此对于 Vue CLI 的架构的主要分析全部完成，这种基于插件机制的架构为开发者提供了终端命令行工具、零配置脚手架、插件体系、图形化管理界面等诸多功能，相较于早前的  vue-cli 其可配置性强，极为灵活并且版本依赖易于管理与升级，就很牛皮！</p><img src="/assets/emoji/05.jpg" width="280" /><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://kuangpf.com/vue-cli-analysis">vue-cli-analysis</a></p><p><a href="https://cloud.tencent.com/developer/article/1781202">剖析 Vue CLI 实现原理</a></p><p><a href="https://cli.vuejs.org/">Vue CLI官方文档</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;vue-cli&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#vue-cli&quot;&gt;&lt;/a&gt; Vue CLI&lt;/h2&gt;
&lt;p&gt;vue-cli 在 3.0 版本进行了彻底的重构，为了区别也将其普遍称为 Vue CLI，是目前 Vue 官方推荐的 Vue 项目快速开发的完整系统，它基于 Webpack 实现，提供了终端命令行工具、零配置脚手架、插件体系、图形化管理界面等诸多功能，近乎提供了前端项目工程化的所有步骤的完整工具链，也是当前 Vue 项目构建的主流工具。&lt;/p&gt;
&lt;h3 id=&quot;一-整体架构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-整体架构&quot;&gt;&lt;/a&gt; 一、整体架构&lt;/h3&gt;
&lt;p&gt;vue-cli 为了尽可能覆盖项目工程化需求所以模版项目往往引入了大量第三方库，但实际开发过程中开发者可能并不需要这些功能模块，虽然可以通过在模版项目的 meta.js 或 meta.json 文件配置 prompts 在命令行交互然后在 filterFiles 函数中对生成项目的文件目录结构进行筛选，但是依然可配置性不强，会存在较多冗余依赖或功能，并且依赖项的升级极为痛苦，因此为了给开发者提供更灵活的配置能力 Vue CLI 实现了一种极为巧妙的架构设计：&lt;/p&gt;</summary>
    
    
    
    <category term="前端工程化" scheme="http://kyleezhang.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="cli" scheme="http://kyleezhang.com/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的 Number 类型</title>
    <link href="http://kyleezhang.com/2021/04/21/javascript-number/"/>
    <id>http://kyleezhang.com/2021/04/21/javascript-number/</id>
    <published>2021-04-21T23:17:59.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中数值只有一种，即 Number 类型，内部表示为双精度浮点型，即其他语言中的 double 类型，所以在 JavaScript 中实际上是没有整数类型的，数值都是按浮点数来处理的，存储方法相同，遵循 IEEE 754 国际标准，因此在 JavaScript 中 3 和 3.0 被视为同一个值，示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.0</span> === <span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>对于整数情况，能够准确计算的整数范围为在 -2<sup>53</sup>~2<sup>53</sup> 之间，不包含两个端点，因此只要在这个范围内整数可以放心使用。除了十进制以外整数还可以通过八进制或十六进制的字面值来表示，其中八进制字面值的第一位必须是零，然后是八进制数字序列（0 ~ 7），如果字面值中的数值超出范围，那么前导零将被忽略，后面的数值被当作十进制解析，这儿需要注意在严格模式中八进制的这种表示会报错，ES6中进一步明确，八进制的表示要使用前缀0o，示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">0</span>11)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">0</span>11)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// Uncaught GyntaxError</span></span><br></pre></td></tr></table></figure><p>十六进制字面值前两位必须是 0x，后跟任何十六进制数字（0 ~ 9以及A ~ F）,其中 A ~ F 可以大写，也可以小写。ES6中又扩展了二进制的写法，使用前缀0b（或0B）。</p><p>虽然在 JavaScript 中无论是小数还是整数都是按照64位的浮点数形式存储，但是进行整数运算会自动转换为32位的有符号整数，例如位运算，有符号整数使用31位表示整数的数值，用第32位表示整数的符号，数值范围是-2<sup>31</sup> ~ 2<sup>31</sup>。</p><p>接下来我们来分析这些范围到底是怎么产生的？</p><img src="/assets/emoji/01.gif" /><h2 id="一-浮点型数值的保存"><a class="markdownIt-Anchor" href="#一-浮点型数值的保存"></a> 一、浮点型数值的保存</h2><p>JavaScript 中的 Number 类型使用的是双精度浮点型，即其他语言中的 double 类型，双精度浮点数使用 8 个字节即 64bit 来进行存储，现代计算机中浮点数大多是以国际标准 IEEE 754 来存储，存储过程分两步，</p><ol><li>把浮点数转换为对应的二进制数，并用科学计数法表示</li><li>将转换之后的数通过 IEEE 754 标准表示成真正会在计算机存储的值。</li></ol><p>根据 IEEE 754 标准任何一个二进制浮点数 V 都可以表示成：</p><img src="/assets/javascript-number/01.png" /><ul><li>(-1)<sup>S</sup>表示符号位，当S=0，V为正数，当S=1，V为负数</li><li>M表示有效数字，大于等于1，小于2</li><li>2<sup>E</sup>表示指数位</li></ul><p>举个🌰，十进制的 5.0，写成二进制是 101.0，相当于 1.01x2<sup>2</sup>，其中 S=0，M=1.01，E=2。</p><p>IEEE 754规定对于32位浮点数最高1位是符号位S，接下来8位是指数E，剩下的23位为有效数字M，具体如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190918235407940.png" alt="" /></p><p>对于64位的浮点数最高1位是符号位S，接下来11位是指数E，剩下的52位是有效数字M，具体如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190918235556672.png" alt="" /></p><p>注意：IEEE754 对于有效数字M和指数E还有一些特别的规定。</p><p>前面说过，1 &lt;= M &lt; 2，也就是说 M 总是可以写成 1.xxxxxxx 的形式，其中 xxxxxxx 表示效数部分。IEEE 754 规定，在计算机内部保存 M 时默认这个数的第一位总是1，因此可以被舍去，只保存后面的 xxxxxxx 部分。比如保存1.01的时候只保存01，等到读取的时候再把第一位的1加上去，这样做的目的就是为了节省一位有效数字，以32位浮点数为例，留给有效数字M的只有23位，将第一位的1舍去以后等于保存24位有效数字。</p><p>至于指数E，情况较为复杂。首先，E为一个无符号指数，这意味着，如果E为8位，它的取值范围为 0 ~ 255，如果E为11位，它的取值范围为0 ~ 2047。但是我们知道科学计数中的E是是可以出现负值的，所以IEEE 754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127，对于11位的E，这个中间数是1023。<br />比如2<sup>10</sup>的E是10，所以保存成32位浮点数时，必须保存成 10+127=137，即 10001001。</p><p>然后指数E还可以分成三种情况：</p><ul><li>E不全为0或不全为1：这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。</li><li>E全为0：这时，浮点数的指数E等于1 ~ 127（或1 ~ 1023），有效数字M不再加上第一位的1，而是还原成0.xxxxxxx的小数，这样做是为了表示±0，以及接近0的很小的数字。</li><li>E全为1：这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位S）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。</li></ul><p>示例：浮点数 9.0 如何用二进制表示？还原成十进制又是多少？</p><p>首先，浮点数 9.0 等于二进制的 1001.0，即 1.001x2<sup>3</sup><br />那么，第一位的符号位 S=0，有效数字 M 等于 001 后面再加 20 个 0，凑满 23 位，指数 E 等于 3+127=130，即 10000010。<br />所以，写成二进制形式，应该是 S+E+M，即0 10000010 001 0000 0000 0000 0000 0000。这个 32 位的二进制数，还原成十进制，正是 1091567616。</p><h2 id="二-数值范围"><a class="markdownIt-Anchor" href="#二-数值范围"></a> 二、数值范围</h2><p>ECMAScript能够表示的数字的绝对值范围是 5e-324 ~ 1.7976931348623157e+308，这两个取值可以通过 Number.MIN_VALUE 和 Number.MAX_VALUE 这两个字段来表示，如果某次计算的结果得到了一个超出 JavaScript 数值范围的，那么这个数值会自动被转换为特殊的 Infinity 值，具体来说，如果这个数是负数，则会被转换成 -Infinity（负无穷），如果这个数值是正数，则会被转换成 Infinity（正无穷）。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE) <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE) <span class="comment">// 5e-324</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>那么这个取值范围是如何得到的呢？</p><p>前面说到 JavaScript 中数值的保存采用的是双精度浮点型，遵循 IEEE 754 标准，在 ECMAScript 规范中规定指数 E 的范围在 -1074 ~ 971，双精度浮点型中有效数字 M 的存储位为52，但是有效数字 M 由于可以省略第一位1，节省一个存储位，因此有效数字M可以存储的范围为 1 ~ 2<sup>53</sup>，因此 JavaScript 中 Number 能表示的最大数字绝对值范围是 2<sup>-1074</sup> ~ 2<sup>(53+971)</sup>。</p><p>注：通过 Number.isFinite()（ES6引入）和 isFinite() 方法可以判断一个数值是不是有穷的，即如果参数位于最小与最大数值之间时会返回 true。</p><h2 id="三-精度丢失"><a class="markdownIt-Anchor" href="#三-精度丢失"></a> 三、精度丢失</h2><p>众所周知在 JavaScript 中 0.1+0.2 不等于 0.3，实际上所有浮点数值存储遵循 IEEE 754 标准的编程语言中都会存在这个问题，这是因为计算机中小数的存储先是转换成二进制进行存储的，而 0.1、0.2 转换成二进制分别为：</p><blockquote><p>(0.1)10 =&gt; (00011001100110011001(1001)…)2<br />(0.2)10 =&gt; (00110011001100110011(0011)…)2</p></blockquote><p>可以发现，0.1 和 0.2 转成二进制之后都是一个无限循环的数，前面提到尾数位只能存储最多 53 位有效数字，这时候就必须来进行四舍五入了，而这个取舍的规则就是在 IEEE 754 中定义的，0.1 最终能被存储的有效数字是</p><blockquote><p>0001(1001)(1001)(1001)(1001)(1001)(1001)(1001)(1001)(1001)(1001)(1001)(1001)101<br />+<br />(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)(0011)01<br />=<br />0100(1100)(1100)(1100)(1100)(1100)(1100)(1100)(1100)(1100)(1100)(1100)(1100)111</p></blockquote><p>最终的这个二进制数转换成十进制的就是 0.30000000000000004 ，这儿需要注意，53 位的存储位指的是能存 53 位有效数字，因此前置的 0 不算，要往后再取到  53 位有效数字为止。</p><p>因此精度丢失的问题实际上用一句话概括就是计算机中用二进制存储小数，而大部分小数转成二进制后都是无限循环的值，因此存在取舍问题，也就是精度丢失。</p><p>ES6 在 Number 对象上新增了一个极小常量：Number.EPSILON，值为 2.220446049250313e-16，引入这么一个常量就是为了为浮点数计算设置一个误差范围，如果这个误差小于 Number.EPSILON 我们就认为得到了准确结果。</p><h2 id="四-最大安全整数"><a class="markdownIt-Anchor" href="#四-最大安全整数"></a> 四、 最大安全整数</h2><p>JavaScript 中最大安全整数的范围是 2<sup>53</sup> ~ 2<sup>53</sup>，不包括两个端点，即 -9007199254740991 ~ 9007199254740991，可以通过 Number.MIN_SAFE_INTEGER 和 Number.MAX_SAFE_INTEGER 字段查询，超出这个范围的整数计算都是不准确的，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) <span class="comment">// 9007199254740991</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_SAFE_INTEGER) <span class="comment">// -9007199254740991</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">9007199254740991</span> + <span class="number">2</span>) <span class="comment">// 9007199254740992</span></span><br></pre></td></tr></table></figure><p>最大安全整数9007199254740991对应的二进制数如图：</p><p><img src="https://img-blog.csdnimg.cn/20190921230804742.png" alt="" /></p><p>53位有效数字都存储满了之后，想要表示更大的数字，就只能往指数数加一位，这时候尾数因为没有多余的存储空间，因此只能补0。</p><p><img src="https://img-blog.csdnimg.cn/20190921230854349.png" alt="" /></p><p>如图所示，在指数位为53的情况下，最后一位尾数位为0的数字可以被精确表示，而最后一位尾数为为1的数字都不能被精确表示。也就是可以被精确表示和不能被精确表示的比例是1:1。<br />同理，当指数为54的时候，只有最后两位尾数为00的可以被精确表示，也就是可以被精确表示和不能被精确表示的比例是1:3，当有效位数达到 x(x&gt;53) 的时候，可以被精确表示和不能被精确表示的比例将是1 : 2<sup>(x-53)</sup> - 1。</p><p>可以预见的是，在指数越来越高的时候，这个指数会成指数增长，因此在 Number.MAX_SAFE_INTEGER ~ Number.MAX_VALUE 之间可以被精确表示的整数可以说是凤毛麟角。</p><p>之所以会有最大安全整数这个概念，本质上还是因为数字类型在计算机中的存储结构。在尾数位不够补零之后，只要是多余的尾数为1所对应的整数都不能被精确表示。</p><p>可以发现，不管是浮点数计算的计算结果错误和大整数的计算结果错误，最终都可以归结到JS的精度只有53位（尾数只能存储53位的有效数字）。那么我们在日常工作中碰到这两个问题该如何解决呢？<br />大而全的解决方案就是使用 mathjs，看一下 mathjs 的输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">math.config(&#123;</span><br><span class="line">    number: <span class="string">&#x27;BigNumber&#x27;</span>,      </span><br><span class="line">    precision: <span class="number">64</span> </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(math.format(math.eval(<span class="string">&#x27;0.1 + 0.2&#x27;</span>))); <span class="comment">// &#x27;0.3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(math.format(math.eval(<span class="string">&#x27;0.23 * 0.34 * 0.92&#x27;</span>))); <span class="comment">// &#x27;0.071944&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(math.format(math.eval(<span class="string">&#x27;9007199254740991 + 2&#x27;</span>))); </span><br><span class="line"><span class="comment">// &#x27;9.007199254740993e+15&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://juejin.im/post/5a6fce10f265da3e261c3c71#heading-2">从0.1+0.2=0.30000000000000004再看JS中的Number类型</a></p><p><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">浮点数的二进制表示</a></p><p>《ES6标准入门》 阮一峰</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 JavaScript 中数值只有一种，即 Number 类型，内部表示为双精度浮点型，即其他语言中的 double 类型，所以在 JavaScript 中实际上是没有整数类型的，数值都是按浮点数来处理的，存储方法相同，遵循 IEEE 754 国际标准，因此在 JavaScript 中 3 和 3.0 被视为同一个值，示例：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt; === &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="深入理解 JavaScript" scheme="http://kyleezhang.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://kyleezhang.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中基于原型的继承</title>
    <link href="http://kyleezhang.com/2021/04/20/javascript-proto/"/>
    <id>http://kyleezhang.com/2021/04/20/javascript-proto/</id>
    <published>2021-04-20T12:37:42.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<p>继承是面向对象语言最为重要的概念之一，许多面向对象语言都支持两种继承方式：接口继承和实现继承，接口继承只继承方法签名，而实现继承则继承实际的方法，由于JavaScript中函数没有签名，因此JavaScript中无法实现接口继承，只支持实现继承。<br />在传统的基于类面向对象的语言如Java、C++中，继承的本质是扩展一个已有的类，并生成新的子类。由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript其实现继承主要是依靠原型链来实现的，本文主要介绍JavaScript中基于原型实现继承的几种主要方式：</p><a id="more"></a><h2 id="一-原型链继承"><a class="markdownIt-Anchor" href="#一-原型链继承"></a> 一、原型链继承</h2><p>核心：父类型的实例作为子类型的原型。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SupType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SupType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了Suptotype</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> Suptotype;</span><br><span class="line"><span class="comment">// 添加新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> subType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>原型继承的实现本质是重写原型对象，代之以一个新类型的实例，在上面示例中原来存在于Suptype的所有实例中的属性和方法，现在也存在于SubType.prototype中了。在确定了继承关系后我们给Subtype.prototype添加了一个方法，这样就在继承了SuperType属性的方法和方法的基础上又添加了一个新方法，示例中的继承关系如下图所示</p><p><img src="https://img-blog.csdnimg.cn/20191127223528684.png" alt="" /></p><p>优点：</p><ul><li>非常纯粹的继承关系，实例是子类型的实例，也是父类型的实例</li><li>父类型新增原型方法或原型属性，子类型都能访问到</li><li>简单，易于实现</li></ul><p>缺点：</p><ul><li>可以在SubType构造函数中，为SubType实例增加实例属性。如果要新增原型属性和方法，则必须放在new SupType()这样的语句之后执行</li><li>无法实现多继承</li><li>来自原型对象的所有属性被所有实例共享</li><li>创建子类型实例时，无法向父类型构造函数传参</li><li>不能使用对象字面量创建原型方法，会重写原型链</li></ul><h2 id="二-借用构造函数继承"><a class="markdownIt-Anchor" href="#二-借用构造函数继承"></a> 二、借用构造函数继承</h2><p>核心：子类型构造函数的内部调用父类型构造函数，等于是复制父类的实例属性给子类（JavaScript中的函数本质上是在特定环境中执行代码的对象，因此也可以通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数）</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承了SupType</span></span><br><span class="line">  SupType.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// &quot;red, blue, green, black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red, blue, greeen&quot; </span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>解决了原型继承中，子类型实例共享父类型引用属性的问题</li><li>创建子类型实例时，可以向父类型传递参数</li><li>可以实现多继承（call多个父类对象）</li></ul><p>缺点：</p><ul><li>实例并不是父类型的实例，只是子类型的实例</li><li>只能继承父类型的实例属性和方法，不能继承原型属性/方法</li><li>无法实现函数复用，每个子类型都有父类型实例函数的副本，影响性能</li></ul><h2 id="三-组合继承"><a class="markdownIt-Anchor" href="#三-组合继承"></a> 三、组合继承</h2><p>核心：使用原型链实现原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SupType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承实例属性</span></span><br><span class="line">  SupType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承原型方法 </span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">&#x27;xiaozhang&#x27;</span>, <span class="number">23</span>);</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors) <span class="comment">// &quot;red, blue, green, black&quot;</span></span><br><span class="line">instance1.sayName() <span class="comment">// &quot;xiaozhang&quot;</span></span><br><span class="line">instance1.sayAge() <span class="comment">// 23 </span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">&#x27;xiaoli&#x27;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// &quot;red, blue, green, black&quot;</span></span><br><span class="line">instance2.sayName() <span class="comment">// &quot;xiaoli&quot;</span></span><br><span class="line">instance2.sayAge() <span class="comment">// 22</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>弥补了借用构造函数继承的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li><li>既是子类型的实例，也是父类型的实例，可以使用 instanceof 和 isPrototypeOf() 来识别组合继承的对象</li><li>不存在引用属性共享问题</li><li>可传参</li><li>函数可复用</li></ul><p>缺点：</p><ul><li>调用了两次父类构造函数，生成了两份实例（后文会进行详细解释）</li></ul><h2 id="四-原型式继承"><a class="markdownIt-Anchor" href="#四-原型式继承"></a> 四、原型式继承</h2><p>核心：对传入对象进行浅复制，作为原型对象<br />示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建临时性构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="comment">// 返回临时类型的新实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;xiaozhang&#x27;</span>,</span><br><span class="line">  colors: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(Person);</span><br><span class="line">anotherPerson.name = <span class="string">&#x27;xiaoli&#x27;</span>;</span><br><span class="line">anotherPerson.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.colors.push(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.colors) <span class="comment">// &quot;red, blue, green, black, yellow&quot;</span></span><br></pre></td></tr></table></figure><p>ES5中新增了Object.create()方法规范了原型式继承，这个方法接受两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象，第二个参数与 Object.defineProperties() 方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。<br />因此上面的示例可重写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;xiaozhang&#x27;</span>,</span><br><span class="line">  colors: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = object.create(Person);</span><br><span class="line">anotherPerson.name = <span class="string">&#x27;xiaoli&#x27;</span>;</span><br><span class="line">anotherPerson.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object.create(person);</span><br><span class="line">yetAnotherPerson.colors.push(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.colors) <span class="comment">// &quot;red, blue, green, black, yellow&quot;</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>支持多继承</li><li>简单方便</li></ul><p>缺点：</p><ul><li>包含引用类型的属性始终都会共享相应的值</li></ul><h2 id="五-寄生式继承"><a class="markdownIt-Anchor" href="#五-寄生式继承"></a> 五、寄生式继承</h2><p>核心：创建一个仅用于封装继承过程的函数。<br />示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过调用Object.create()创建一个新对象</span></span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(original);</span><br><span class="line">  <span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回这个对象</span></span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;xiaozhang&quot;</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">another.sayHi(); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>示例中使用的Object.create()方法并不是必须的，任何能够返回新对象的函数都适用于此模式。</li><li>在主要考虑对象而不是自定义对象或者构造函数的情况下，寄生式继承显得更为灵活与方便。</li></ul><p>缺点：</p><ul><li>使用寄生式继承来为对象添加函数时会由于不能做到函数复用而降低效率，这一点与构造函数模式类似。</li></ul><h2 id="六-寄生组合式继承"><a class="markdownIt-Anchor" href="#六-寄生组合式继承"></a> 六、寄生组合式继承</h2><p>核心：通过寄生方式，砍掉父类型的实例属性，这样，在调用两次父类型的构造函数的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点。<br />组合继承是JavaScript最常用的继承模式，但是它最大的不足就是无论在什么情况下都会调用两次父类型构造函数，一次是在创建子类型原型的时候，另一次是在子类型构造函数内部，因此这导致子类型的原型上创建了不必要的实例属性，只不过当我们在子类型的实例中进行访问时被子类型构造函数中的实例属性所覆盖。以我们之前组合继承模式的示例为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SupType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第二次调用父类型方法</span></span><br><span class="line">  SupType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一次调用父类型方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合式继承的主要思路是通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，而寄生式组合继承的优化主要是不必为了制定子类型的原型而调用父类型的构造函数，我们所需的无非就是父类型原型的副本而已，因此我们可以通过寄生式继承来继承父类型原型，然后再将结果制定给子类型的原型。<br />示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SupType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name,</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SupType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现寄生式继承的另一种思路</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个实例方法的类</span></span><br><span class="line">  <span class="keyword">var</span> clone = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  clone.prototype = SupType.prototype;</span><br><span class="line">  <span class="comment">// 将实例作为子类型的原型</span></span><br><span class="line">  SubType.prototype = <span class="keyword">new</span> SupType;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 向子类型的原型添加专属方法</span></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(<span class="string">&quot;xiaozhang&quot;</span>, <span class="number">23</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance.age) <span class="comment">// 23</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.name) <span class="comment">// &quot;xiaozhang&quot;</span></span><br><span class="line">instance.getAge() <span class="comment">// 23</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>只调用了一次父类型构造函数，因此避免了在子类型的原型上创建不必要的、多余的属性。</li><li>原型链保持不变，能够正常使用instanceof和isPrototypeOf()。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;继承是面向对象语言最为重要的概念之一，许多面向对象语言都支持两种继承方式：接口继承和实现继承，接口继承只继承方法签名，而实现继承则继承实际的方法，由于JavaScript中函数没有签名，因此JavaScript中无法实现接口继承，只支持实现继承。&lt;br /&gt;
在传统的基于类面向对象的语言如Java、C++中，继承的本质是扩展一个已有的类，并生成新的子类。由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript其实现继承主要是依靠原型链来实现的，本文主要介绍JavaScript中基于原型实现继承的几种主要方式：&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解 JavaScript" scheme="http://kyleezhang.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://kyleezhang.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的类型</title>
    <link href="http://kyleezhang.com/2021/04/18/javascript-type/"/>
    <id>http://kyleezhang.com/2021/04/18/javascript-type/</id>
    <published>2021-04-18T09:51:21.000Z</published>
    <updated>2022-06-12T11:24:41.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-javascript-中的类型"><a class="markdownIt-Anchor" href="#一-javascript-中的类型"></a> 一、JavaScript 中的类型</h2><p>JavaScript中的类型可以分为基本数据类型和引用类型两种：</p><ul><li>基本类型值：指的是保存在栈内存中的简单数据段；</li><li>引用类型值：指的是那些保存在堆内存中的对象，意思是，栈内存中保存的实际上只是一个指针，这个指针指向内存堆中实际的值；</li></ul><p>JavaScript 中的的每一个值都属于某一种数据类型。</p><a id="more"></a><p>基本数据类型定义是按值访问，可操作保存在变量中的实际的值。基本类型值指的是简单的数据段。JavaScript 语言规定了 6 种基本数据类型。数据类型广泛用于变量、函数参数、表达式、函数返回值等场合。根据最新的语言标准，这 6 种数据类型是：Undefined、Null、Boolean、String、Number、Symbol。</p><p>引用类型：当复制保存着对象的某个变量时，操作的是对象的引用，但在为对象添加属性时，操作的是实际的对象。引用类型值指那些可能为多个值构成的对象。引用类型有这几种：Object、Array、RegExp、Date、Function、特殊的基本包装类型(String、Number、Boolean)以及单体内置对象(Global、Math)。其中Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的核心机制之一。Object 表示对象的意思，它是一切有形和无形物体的总称。</p><h2 id="二-基本类型值和引用类型值的区别"><a class="markdownIt-Anchor" href="#二-基本类型值和引用类型值的区别"></a> 二、基本类型值和引用类型值的区别</h2><p>1、引用类型值可添加属性和方法，而基本类型值则不可以。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为引用类型值添加属性</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">p.age = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.age); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为基本类型值添加属性</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">name.age = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>2、在复制变量值时，基本类型会在变量对象上创建一个新值，再复制给新变量。此后，两个变量的任何操作都不会影响到对方。而引用类型在创建一个对象类型时，计算机会在内存中开辟一个空间来存放值，我们要找到这个空间，需要知道这个空间的地址，变量存放的就是这个地址，复制变量时其实就是将地址复制了一份给新变量，两个变量的值都指向存储在堆中的一个对象，也就是说，其实他们引用了同一个对象，改变其中一个变量就会影响到另一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本类型值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用类型值,以数组为例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.对其中一个变量直接赋值不会影响到另一个变量（并未操作引用的对象）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//1,2,3,4</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用push(操作了引用的对象)</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//1,2,3,4</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//1,2,3,4</span></span><br></pre></td></tr></table></figure><h2 id="三-类型的检测"><a class="markdownIt-Anchor" href="#三-类型的检测"></a> 三、类型的检测</h2><h3 id="1-typeof"><a class="markdownIt-Anchor" href="#1-typeof"></a> 1、typeof</h3><p>typeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。其返回值是一个字符串，该字符串说明运算数的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> o = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> flag); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> rg); <span class="comment">// object(sarari5、chrome7前返回function)</span></span><br></pre></td></tr></table></figure><p>事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JS 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。</p><table><thead><tr><th>示例表达式</th><th>typeof结果</th><th>运行时类型行为</th></tr></thead><tbody><tr><td>null</td><td>object</td><td>Object</td></tr><tr><td>(function () {})</td><td>function</td><td>Object</td></tr><tr><td>3</td><td>number</td><td>Number</td></tr><tr><td>“ok”</td><td>string</td><td>String</td></tr><tr><td>true</td><td>boolean</td><td>Boolean</td></tr><tr><td>void 0</td><td>undefined</td><td>Undefined</td></tr><tr><td>Symbol(“a”)</td><td>symbol</td><td>Symbol</td></tr></tbody></table><p>总结：</p><ul><li>typeof对于基本类型来说，除了null都可以显示正确类型</li><li>typeof对于引用类型来说，除了函数都会显示object（判断数组可以使用Array.isArray()方法）</li></ul><p>注：使用未声明的变量只有一种情况 不报错，就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(a); <span class="comment">// undefined   </span></span><br></pre></td></tr></table></figure><p>这是因为 typeof 返回的是一个字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="keyword">typeof</span>(a)); <span class="comment">// string </span></span><br></pre></td></tr></table></figure><p>其他示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">NaN</span>); <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>); <span class="comment">// object</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123abc&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span>(+a); <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span>(!!a); <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span>(a + <span class="string">&quot;&quot;</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure><h3 id="2-instanceof"><a class="markdownIt-Anchor" href="#2-instanceof"></a> 2、instanceof</h3><p>用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</p><ul><li>语法：object instanceof constructor</li><li>参数：object（要检测的对象）constructor（某个构造函数）</li><li>描述：instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true, 这是因为 Array 是 Object 的子类。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> test();</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> test) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>instanceof 的主要作用是在继承关系中用来判断一个实例是否属于它的父类型，其优点在于即使在多层继承关系中，instanceof 运算符同样适用，示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">Foo.prototype = <span class="keyword">new</span> Aoo(); <span class="comment">// JavaScript 原型继承 </span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); </span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> Foo); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(foo <span class="keyword">instanceof</span> Aoo); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>综上所述，无论是 typeof 还是 instanceof 都不能准确判断出正确的类型，因此在需要判断类型时我们还是需要结合场景选择使用。</p><h2 id="四-为什么给对象添加的方法可以用在基本类型上"><a class="markdownIt-Anchor" href="#四-为什么给对象添加的方法可以用在基本类型上"></a> 四、为什么给对象添加的方法可以用在基本类型上？</h2><p>在 JavaScript 的学习过程中我们往往会产生一个疑问，为什么给对象添加的方法能用在基本类型上？</p><p>实际上这是因为在 JavaScript 中，对象的定义是“属性的集合”。属性分为数据属性和访问器属性，二者都是 key-value 结构，key 可以是字符串或者 Symbol 类型。</p><p>提到对象，我们必须要提到一个概念：类。因为 C++ 和 Java 的成功，在这两门语言中，每个类都是一个类型，二者几乎等同，以至于很多人常常会把 JavaScript 的“类”与类型混淆。事实上，<strong>JavaScript 中的“类”仅仅是运行时对象的一个私有属性，而 JavaScript 中是无法自定义类型的</strong>。JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：Number、String、Boolean、Symbol。所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。</p><p>Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。</p><p>JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;abc&quot;</span>.charAt(<span class="number">0</span>)); <span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>甚至我们在原型上添加方法，都可以应用于基本类型，比如以下代码，在 Symbol 原型上添加了 hello 方法，在任何 Symbol 类型变量都可以调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.prototype.hello = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// symbol，a 并非对象</span></span><br><span class="line">a.hello(); <span class="comment">// hello，有效</span></span><br></pre></td></tr></table></figure><p>所以这个问题的答案就是. 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。以下面例子为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> up = <span class="string">&quot;he is a super man&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> output = up.charAt(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(output); <span class="comment">// a</span></span><br></pre></td></tr></table></figure><p>当执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> output = up.charAt(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>这个步骤的时候后台会这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> up = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;he is a super man&quot;</span>);</span><br></pre></td></tr></table></figure><p>找到对应的包装对象,包装成一个和up值相等的对象返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> output = up.charAt(<span class="number">6</span>); <span class="comment">// 调用方法返回给output</span></span><br><span class="line">up = <span class="literal">null</span>; <span class="comment">// 然后销毁</span></span><br></pre></td></tr></table></figure><p>同理，数字、布尔值在读取属性的时候也可以通过自己的构造函数来创建自己的一个临时对象，并像对象一样（就是一个对象）引用各自的属性，所以，字符串、数字、布尔值都可以看成是对象，注意，这里是看成对象，他们并不是真正的对象，也就是严格来说，它们并不是对象，因为对象是可变的，可以修改属性，而原始值是不可变的是不可修改的(看下面)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.toUpperCase()); <span class="comment">// ABCDEFG</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// abcdefg</span></span><br></pre></td></tr></table></figure><p>它只是返回一个变成大写的副本没有改变原始的变量，而且不能在原始数据类型上添加属性和方法。因为<strong>创建的只是一个临时对象，写的属性和方法只存在于临时对象上，引用完后随即销毁</strong>。<br />这儿需要注意 null 和 undefined，首先是 null  它是一个关键字，表示为 “空&quot;,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>由此可见它是一个对象，但是它只是指向一个空对象的引用。</p><p>然后是 undefined，undefined 是另一个表示“空值”特殊值，它表示未定义，当我们对变量只声明没有初始化时(赋值)，输出为 undefined，当我们引用一个不存在的属性时，输出也为 undefined，但是需要注意注意它并不是一个关键字，它是一个变量，而且是一个全局变量，我们可以验证一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> <span class="keyword">in</span> <span class="built_in">window</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>而且</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>这严格表明 undefined 是这个类型的唯一成员，除了 undefined，JavaScript 里面其他一切的都可以看作是对象。</p><h2 id="五-装箱转换与拆箱转换"><a class="markdownIt-Anchor" href="#五-装箱转换与拆箱转换"></a> 五、装箱转换与拆箱转换</h2><h3 id="1-装箱转换"><a class="markdownIt-Anchor" href="#1-装箱转换"></a> 1、装箱转换</h3><p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象，它是类型转换中一种相当重要的种类。</p><p>我们都知道全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。我们定义一个函数，函数里面只有 <code>return this</code>，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 <code>symbol Object</code>。我们可以用 <code>console.log</code> 看一下这个东西的 type of，它的值是 object，我们使用 <code>symbolObject instanceof</code> 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbolObject = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;).call(<span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbolObject);  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolObject <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolObject.constructor == <span class="built_in">Symbol</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbolObject = <span class="built_in">Object</span>(<span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbolObject);  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolObject <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolObject.constructor == <span class="built_in">Symbol</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbolObject = <span class="built_in">Object</span>(<span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(symbolObject)); <span class="comment">// [object Symbol]</span></span><br></pre></td></tr></table></figure><p>在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。但需要注意的是，call 本身会产生装箱操作，所以需要配合 typeof 来区分基本类型还是对象类型。</p><h3 id="2-拆箱转换"><a class="markdownIt-Anchor" href="#2-拆箱转换"></a> 2、拆箱转换</h3><p>对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。</p><p><strong>拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    valueOf : <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;valueOf&quot;</span>); <span class="keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">    toString : <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;toString&quot;</span>); <span class="keyword">return</span> &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o * <span class="number">2</span></span><br><span class="line"><span class="comment">// valueOf</span></span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o*2 这个运算的时候，你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。到 String 的拆箱转换会优先调用 toString。我们把刚才的运算换成 String(o)，那么你会看到调用顺序就变了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    valueOf : <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;valueOf&quot;</span>); <span class="keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">    toString : <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;toString&quot;</span>); <span class="keyword">return</span> &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(o)</span><br><span class="line"><span class="comment">// toString</span></span><br><span class="line"><span class="comment">// valueOf</span></span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>可以看到，toString 和 valueOf 的执行顺序并不固定，而是根据某个条件来决定的，那么是根据什么呢？</p><p>实际上每个对象都有一个 <code>Symbol.toPrimitive</code> 属性，其指向一个方法。当对象需要被转为基本类型的值时，会调用这个方法，返回该对象对应的基本类型值。<code>Symbol.toPrimitive</code> 被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p><ul><li>Number：该场合需要转成数值</li><li>String：该场合需要转成字符串</li><li>Default：该场合可以转成数值，也可以转成字符串</li></ul><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> * obj <span class="comment">// 246</span></span><br><span class="line"><span class="number">3</span> + obj <span class="comment">// &#x27;3default&#x27;</span></span><br><span class="line">obj == <span class="string">&#x27;default&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>(obj) <span class="comment">// &#x27;str&#x27;</span></span><br></pre></td></tr></table></figure><p>因此实际上拆箱转换的具体规则如下：</p><ol><li>检查对象中是否有用户显式定义的 <code>[Symbol.toPrimitive]</code> 方法，如果有，直接调用；</li><li>如果没有，则执行原内部函数 ToPrimitive，然后判断传入的 hint 值，如果其值为 string，顺序调用对象的 toString 和 valueOf 方法（其中 toString 方法一定会执行，如果其返回一个基本类型值，则返回、终止运算，否则继续调用 valueOf 方法）；</li><li>如果判断传入的 hint 值不为 string，则就可能为 number 或者 default 了，均会顺序调用对象的 valueOf 和 toString 方法（其中 valueOf 方法一定会执行，如果其返回一个基本类型值，则返回、终止运算，否则继续调用 toString 方法）；</li></ol><p>因此对象可以通过显式指定 toPrimitive Symbol 来覆盖原有的行为，示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  valueOf : <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;valueOf&quot;</span>); <span class="keyword">return</span> &#123;&#125;&#125;,</span><br><span class="line">  toString : <span class="function">() =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">&quot;toString&quot;</span>); <span class="keyword">return</span> &#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;toPrimitive&quot;</span>); </span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o + <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// toPrimitive</span></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h2 id="六-类型转换方法"><a class="markdownIt-Anchor" href="#六-类型转换方法"></a> 六、类型转换方法</h2><p>JavaScript 中类型转换的基本原理就是上述的装箱转换和拆箱转换，下面我们一起来看一下我们平时常用的内省转换</p><h3 id="1-显式类型转换"><a class="markdownIt-Anchor" href="#1-显式类型转换"></a> 1、显式类型转换</h3><p><strong>Number(mix)</strong>  ：把 mix 转化成数字类型  可以转为数字的就转化为相应的数字，不能转化的就转为NaN ，其中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><strong>parseInt(mix,radix)</strong> ：把 mix 转化成整数 除了数字和能转化为数字的字符串，其他都转化为 NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="literal">true</span>) <span class="comment">// NaN； </span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">false</span>) <span class="comment">// NaN；</span></span><br></pre></td></tr></table></figure><p>当 mix 为字符串时，则从第一位一直到非数字截止，即该方法可以截断，但 <code>Number()</code> 不能 ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;123qqq&quot;</span>) <span class="comment">// 123；</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;123qqq&quot;</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>radix 是目标值的进制，将 mix 看成 radix 进制来进行转化，若有小数部分则是直接去掉。例如将二进制 10100 转化为 16 进制的过程是：先 parseInt() 转化为10进制，然后在 toString() 转化为16进制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10100</span>;</span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">parseInt</span>(num, <span class="number">2</span>);</span><br><span class="line">num.toString(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p><strong>parseFloat(number)</strong> ：转化成浮点类型，从一位开始看，到除了第一个点以外的非数字位截止。</p><p><strong>Boolean(mix)</strong> ： 转化为 boolean 类型。</p><p><strong>String(mix)</strong> ：转化为字符串类型。</p><p>注：<code>mix.toString(radix)</code> 与 <code>String(mix)</code> 用法不同，且 undefined 和 null 不能使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>.toString() <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-隐式类型转换"><a class="markdownIt-Anchor" href="#2-隐式类型转换"></a> 2、隐式类型转换</h3><p><strong>isNaN()</strong>：内部隐式调用 Number()进行类型转化，再判断 Number()返回的值是否是NaN。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>（<span class="literal">null</span>）<span class="comment">// false   </span></span><br><span class="line"><span class="built_in">isNaN</span>（underfined) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>++、–、+、-</strong>：内部隐式调用 <code>Number()</code> 转化后再进行相应计算。</p><p><strong>+</strong>: 当加号两边有一个是字符串的话，就会调用 <code>String()</code>，然后进行字符串的拼接。</p><p><strong>-    *    /    %</strong>：内部隐式调用 <code>Number()</code> 进行类型后再计算。</p><p><strong>&lt; &gt; &lt;=  &gt;=</strong>：字符串和数字比会调用 <code>Number()</code> 转化为数字。</p><p><strong>== 、!=</strong>：转换规则如下表所示：</p><table><thead><tr><th>类型1</th><th>类型2</th><th>转换结果</th></tr></thead><tbody><tr><td>null</td><td>undefined</td><td>不发生类型转换，直接返回 true</td></tr><tr><td>null 或 undefined</td><td>其它任何非 null 或 undefined 的类型</td><td>不发生类型转换，直接返回 false</td></tr><tr><td>NaN</td><td>基本类型或引用类型</td><td>false，NaN 不等于任何东西，包括自身</td></tr><tr><td>string、number 或 boolean 等基本类型</td><td>Date 等对象</td><td>Date 等对象发生拆箱转换</td></tr><tr><td>string、number 或 boolen 等基本类型</td><td>string、number 或 boolea 等基本类型</td><td>基本类型转换为数字进行比较</td></tr></tbody></table><p><strong>&amp;&amp;、||、 ！</strong>：</p><p>&amp;&amp;：先看第一个表达式转化成布尔值的值，如果为真，那么看第二个表达式转化为布尔值的值，。。。。依次进行，直到碰到假；如果只有两个表达式，则会在第一个表达式转化为布尔值为真时，直接返回第二个表达式的值；否则返回第一个表达式的值进行赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> &amp;&amp; <span class="number">2</span>+<span class="number">2</span>; <span class="comment">//4</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0</span> &amp;&amp; <span class="number">2</span>+<span class="number">2</span>; <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>||：与&amp;&amp;类似，但先看第一个表达式转化为布尔值后的值，如果为真，直接返回第一个表达式的值，如果为假，则接着往下进行判断。</p><p><strong>判断真假只是决定是否接着“往下走”，但返回的仍是其本身的值，而不是转化的布尔值</strong></p><p>!：将后面的表达式转换为布尔值。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>极客时间《重学前端》专栏<br />《ES6标准入门》第三版</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一-javascript-中的类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#一-javascript-中的类型&quot;&gt;&lt;/a&gt; 一、JavaScript 中的类型&lt;/h2&gt;
&lt;p&gt;JavaScript中的类型可以分为基本数据类型和引用类型两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本类型值：指的是保存在栈内存中的简单数据段；&lt;/li&gt;
&lt;li&gt;引用类型值：指的是那些保存在堆内存中的对象，意思是，栈内存中保存的实际上只是一个指针，这个指针指向内存堆中实际的值；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JavaScript 中的的每一个值都属于某一种数据类型。&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解 JavaScript" scheme="http://kyleezhang.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://kyleezhang.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器安全</title>
    <link href="http://kyleezhang.com/2021/03/17/client-security/"/>
    <id>http://kyleezhang.com/2021/03/17/client-security/</id>
    <published>2021-03-17T20:06:09.000Z</published>
    <updated>2022-06-12T11:24:41.821Z</updated>
    
    <content type="html"><![CDATA[<p>WEB 世界出现的最初目的就是开放与共享，任何资源都可以接入其中，我们的网站可以加载并执行别人网站的脚本文件、图片、音频、视频等资源，甚至可以下载其他站点的可执行文件。但是如果这种自由没有任何限制反而会引起彻底的混乱和无序，我们的数据与隐私将被肆意窃取。随着 WEB2.0 的时代来临，互联网从C/S架构（客服端/服务端结构）转变为 B/S 架构(浏览器/服务器结构），后者相比于前者更加方便快捷，因此浏览器便成为了我们访问网站的窗口，浏览器安全也随之变得越来越重要。</p><p>浏览器安全主要可以分为<strong>Web页面安全</strong>、<strong>浏览器网络安全</strong>和<strong>浏览器系统安全</strong>，接下来我们按照这三个方面分别进行介绍：</p><a id="more"></a><h2 id="页面安全"><a class="markdownIt-Anchor" href="#页面安全"></a> 页面安全</h2><h3 id="一-同源策略"><a class="markdownIt-Anchor" href="#一-同源策略"></a> 一、同源策略</h3><p>同源策略（Same-origin policy）是浏览器页面最基础、最核心的安全策略，主要用于限制不同源站点之间的交互。那么首先什么是同源呢？</p><p><strong>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源</strong>。举个🌰</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://time.geekbang.org/?category=1</span><br><span class="line">https://time.geekbang.org/?category=0</span><br></pre></td></tr></table></figure><p>这两个 URL，它们具有相同的协议 HTTPS、相同的域名 <a href="http://time.geekbang.org">time.geekbang.org</a>，以及相同的端口 443，所以我们就说这两个 URL 是同源的。</p><p>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p><p><strong>1、DOM层面</strong></p><p>同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作，举个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent</span></span><br><span class="line"><span class="built_in">window</span>.open(<span class="string">&#x27;https://www.****.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line"><span class="keyword">const</span> pdom = <span class="built_in">window</span>.opener.document;</span><br><span class="line">pdom.body.style.color = <span class="string">&quot;red&quot;</span>;</span><br></pre></td></tr></table></figure><p>在上述示例中我们在父页面中打开了子页面并在子页面中操作父页面中 DOM 节点的样式，如果此时子页面与父页面同源那么上述操作会成功，如果不是页面会抛出异常信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blocked a frame <span class="keyword">with</span> origin <span class="string">&quot;https://www.****.ccom&quot;</span> <span class="keyword">from</span> accessing a cross-origin frame.</span><br></pre></td></tr></table></figure><p><strong>2、数据层面</strong></p><p>同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。</p><p><strong>3、网络层面</strong></p><p>同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</p><p>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现 Web 页面的安全性。不过安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这也会使得 Web 项目难以开发和使用。因此我们要在这二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型。总结起来，它具备以下三个特点：</p><ol><li>两个不同源之间无法读取数据并且 DOM 也是不能相互操纵的，因此，浏览器中实现了跨文档消息机制，让其可以比较安全地通信。</li><li>使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略(CORS)，让其可以安全地进行跨域操作。</li><li>页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了内容安全策略(CSP)来限制其自由程度。</li></ol><h3 id="二-xss攻击"><a class="markdownIt-Anchor" href="#二-xss攻击"></a> 二、XSS攻击</h3><p>XSS 全称是 Cross Site Scripting，即跨站脚本，XSS 攻击是指黑客<strong>往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击</strong>的一种手段。最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。但是发展到现在，往 HTML 文件中注入恶意代码的方式越来越多了，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。我们根据恶意脚本的注入方式将其主要分为存储型 XSS 攻击、反射型 XSS 攻击和基于 DOM 的 XSS 攻击三种：</p><p><strong>1、存储型 XSS 攻击</strong></p><img src="/assets/client-security/01.png" width="600"/><p>通过上图，我们可以看出存储型 XSS 攻击大致需要经过如下步骤：</p><ul><li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li><li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li></ul><p><strong>2、反射型 XSS 攻击</strong></p><p>在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。</p><p><strong>3、基于 DOM 的 XSS 攻击</strong></p><p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p><p>存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。</p><p>但无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现，常用的阻止 XSS 攻击的策略有：</p><p>（1）服务器对输入脚本进行过滤或转码</p><p>不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code:<span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;你被xss攻击了&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这段代码过滤后，只留下了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br></pre></td></tr></table></figure><p>这样，当用户再次请求该页面时，由于 script 标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</p><p>除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code:&amp;lt;script&amp;gt;alert(&amp;#39;你被xss攻击了&amp;#39;)&amp;lt;/script&amp;gt;</span><br></pre></td></tr></table></figure><p>经过转码之后的内容，如<code>&lt;script&gt;</code>标签被转换为<code>&amp;lt;script&amp;gt;</code>，因此即使这段脚本返回给页面，页面也不会执行这段脚本。</p><p>（2）充分利用CSP</p><p>虽然在服务器端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：</p><ul><li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li><li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li><li>禁止执行内联脚本和未授权的脚本；</li><li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。因此，利用好 CSP 能够有效降低 XSS 攻击的概率。</li></ul><p>（3）使用 HttpOnly 属性</p><p>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly</span><br></pre></td></tr></table></figure><p>我们可以看到，set-cookie 属性值最后使用了 HttpOnly 来标记该 Cookie。顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。我们还可以通过 Chrome 开发者工具来查看哪些 Cookie 被标记了 HttpOnly，如下图：</p><img src="/assets/client-security/02.png" width="500" /><p>从图中可以看出，NID 这个 Cookie 的 HttpOlny 属性是被勾选上的，所以 NID 的内容是无法通过 document.cookie 是来读取的。由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。</p><h3 id="三-csrf攻击"><a class="markdownIt-Anchor" href="#三-csrf攻击"></a> 三、CSRF攻击</h3><p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客<strong>利用了用户的登录状态，并通过第三方的站点来做一些坏事</strong>。和 XSS 不同，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击</p><p>由于 CSRF 攻击核心是是利用用户的登录状态来攻击目标站点，因此发起 CSRF 攻击的三个必要条件：</p><ul><li>目标站点一定要有 CSRF 漏洞；</li><li>用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；</li><li>需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li></ul><p>满足以上三个条件之后，黑客就可以对用户进行 CSRF 攻击了。这里还需要额外注意一点，与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</p><p>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径。</p><p>（1）<strong>充分利用好 Cookie 的 SameSite 属性</strong></p><p>由于黑客会利用用户的登录状态来发起 CSRF 攻击，而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击，我们首先就要考虑在 Cookie 上来做文章。通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：</p><ul><li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；</li><li>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。</li></ul><p>在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none</span><br></pre></td></tr></table></figure><p>SameSite 选项通常有 Strict、Lax 和 None 三个值。</p><ul><li>Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。</li><li>Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。</li><li>而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</li></ul><p>（2）<strong>验证请求的来源站点</strong></p><p>防止 CSRF 攻击的另一种策略就是在服务器端验证请求来源的站点。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？这就需要介绍 HTTP 请求头中的 Referer 和 Origin 属性了。Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址，虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考 Referrer Policy。但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 Origin 属性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性，</p><img src="/assets/client-security/03.webp" width="800" /><p>从上图可以看出，Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</p><p>（3）<strong>CSRF Token</strong></p><p>除了使用以上两种方式来防止 CSRF 攻击之外，还可以采用 CSRF Token 来验证，这个流程比较好理解，大致分为两步。第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://time.geekbang.org/sendcoin&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;csrf-token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;nc98P987bcpncYhoadjoiydc9ajDlcn&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</p><p>页面安全问题的主要原因就是浏览器为同源策略开的两个“后门”：一个是在页面中可以任意引用第三方资源，另外一个是通过 CORS 策略让 XMLHttpRequest 和 Fetch 去跨域请求资源。为了解决这些问题，我们引入了 CSP 来限制页面任意引入外部资源，引入了 HttpOnly 机制来禁止 XMLHttpRequest 或者 Fetch 发送一些关键 Cookie，引入了 SameSite 和 Origin 来防止 CSRF 攻击。这也是浏览器页面安全的主要内容。</p><h2 id="浏览器系统安全"><a class="markdownIt-Anchor" href="#浏览器系统安全"></a> 浏览器系统安全</h2><p>在最开始的阶段，浏览器是单进程的，这意味着渲染过程、JavaScript 执行过程、网络加载过程、UI 绘制过程和页面显示过程等都是在同一个进程中执行的，这种结构虽然简单，但是也带来了很多问题，浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用缓冲区溢出，不过需要注意这种类型的攻击和 XSS 注入的脚本是不一样的。</p><ul><li>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。</li><li>而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</li></ul><p>和 XSS 攻击页面相比，这类攻击无疑是枚“核弹”，它会将整个操作系统的内容都暴露给黑客，这样我们操作系统上所有的资料都是不安全的了。</p><h3 id="一-安全视角下的多进程架构"><a class="markdownIt-Anchor" href="#一-安全视角下的多进程架构"></a> 一、安全视角下的多进程架构</h3><p>现代浏览器采用了多进程架构，将渲染进程和浏览器主进程做了分离，具体如下图所示：</p><img src="/assets/client-security/04.webp" width="600" /><p>观察上图，我们知道浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。那如果我们在浏览器中打开一个页面，这两个模块是怎么配合的呢？所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</p><p>因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的，都是不安全的。但谁也不能保证浏览器不存在漏洞，只要出现漏洞，黑客就可以通过网络内容对用户发起攻击。我们知道，如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同理，浏览器之于网络内容也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。基于以上原因，我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。将渲染进程和操作系统隔离的这道墙就是安全沙箱了。</p><h3 id="二-安全沙箱"><a class="markdownIt-Anchor" href="#二-安全沙箱"></a> 二、安全沙箱</h3><p>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。</p><p>由于安全沙箱最小的保护单位是进程，并且能限制进程对操作系统资源的访问和修改，这就意味着如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。渲染进程和浏览器内核各自的职责如下图所示：</p><img src="/assets/client-security/05.webp" width="600" /><p>通过该图，我们可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。</p><p>那么安全沙箱对哥哥们模块的功能有何影响呢？</p><h4 id="1-持久存储"><a class="markdownIt-Anchor" href="#1-持久存储"></a> 1、持久存储</h4><p>由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。</p><p>具体地讲，如下文件内容的读写都是在浏览器内核中完成的：</p><ul><li>存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。</li><li>一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。</li></ul><h4 id="2-网络访问"><a class="markdownIt-Anchor" href="#2-网络访问"></a> 2. 网络访问</h4><p>同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。</p><h4 id="3-用户交互"><a class="markdownIt-Anchor" href="#3-用户交互"></a> 3、用户交互</h4><p>渲染进程实现了安全沙箱，还影响到了一个非常重要的用户交互功能。通常情况下，如果你要实现一个 UI 程序，操作系统会提供一个界面给你，该界面允许应用程序与用户交互，允许应用程序在该界面上进行绘制，比如 Windows 提供的是 HWND，Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为窗口句柄。应用程序可以在窗口句柄上进行绘制和接收键盘鼠标消息。</p><p>不过在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。由于渲染进程不能直接访问窗口句柄，所以渲染进程需要完成以下两点大的改变。</p><ul><li>第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。</li><li>第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。</li></ul><p>之所以这样设计，就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进程。</p><h3 id="三-站点隔离"><a class="markdownIt-Anchor" href="#三-站点隔离"></a> 三、站点隔离</h3><p>不过出于安全考虑浏览器对渲染进程还采取了进一步的安全手段，也就是———站点隔离。</p><p>所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。最开始 Chrome 划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内容通过 iframe 同时运行在同一个渲染进程中。目前所有操作系统都面临着两个 A 级漏洞——幽灵（Spectre）和熔毁（Meltdown），这两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。所以如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe 利用这两个 A 级漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用户来说就存在很大的风险了。因此 Chrome 几年前就开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。</p><h2 id="浏览器网络安全"><a class="markdownIt-Anchor" href="#浏览器网络安全"></a> 浏览器网络安全</h2><p>起初设计 HTTP 协议的目的很单纯，就是为了传输超文本文件，那时候也没有太强的加密传输的数据需求，所以 HTTP 一直保持着明文传输数据的特征。但这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，你们在通信过程中的一切内容都在中间人的掌握中，具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改，我们将这种攻击称为中间人攻击。</p><p>由于 HTTP 的明文传输使得传输过程毫无安全性可言，而这制约了网上购物、在线转账等一系列场景应用，这也催生了网络安全协议 HTTPS 的诞生。HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP，因此要搞清楚 HTTPS 是如何工作的，就要弄清楚安全层是怎么工作的。</p><h3 id="一-安全层"><a class="markdownIt-Anchor" href="#一-安全层"></a> 一、安全层</h3><p>目前 HTTPS 安全层的加密方案的核心是：<strong>传输数据阶段依然使用对称加密，但是对称加密的密钥采用非对称加密来传输</strong>，具体过程如下图所示：</p><img src="/assets/client-security/06.webp" width="800" /><p>如图所示，具体流程是这样的：</p><ul><li>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</li><li>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</li><li>浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</li><li>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</li></ul><p>到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。</p><p>需要特别注意的一点，<strong>pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了</strong>。</p><h3 id="二-数字证书"><a class="markdownIt-Anchor" href="#二-数字证书"></a> 二、数字证书</h3><p>通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着问题，比如我要打开极客时间的官网，但是黑客通过 DNS 劫持将极客时间官网的 IP 地址替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。</p><p>所以我们还需要服务器向浏览器提供证明“我就是我”，那怎么证明呢？这里我们结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面积等信息。在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个权威机构，并通过这个权威机构给你颁发一个证书：房产证。</p><p>同理，极客时间要证明这个服务器就是极客时间的，也需要使用权威机构颁发的证书，这个权威机构称为 CA（Certificate Authority），颁发的证书就称为数字证书（Digital Certificate)。对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。</p><p>因此含有数字证书的 HTTPS 的请求流程具体如下图：</p><img src="/assets/client-security/07.webp" width="800" /><p>这里主要有两点改变：</p><ul><li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；</li><li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</li></ul><p><strong>如何申请数字证书?</strong></p><p>我们先来看看如何向 CA 申请证书。</p><p>比如极客时间需要向某个 CA 去申请数字证书，通常的申请流程分以下几步：</p><ul><li>首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；</li><li>然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；</li><li>CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；</li><li>如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。</li></ul><p>这样我们就完成了极客时间数字证书的申请过程。前面几步都很好理解，不过最后一步数字签名的过程还需要解释下：首先 CA 使用 Hash 函数来计算极客时间提交的明文信息，并得出信息摘要；然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是 CA 颁给极客时间的数字签名。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我们也可以通过数字签名来验证是否是该 CA 颁发的。</p><p><strong>浏览器如何验证数字证书?</strong></p><p>有了 CA 签名过的数字证书，当浏览器向极客时间服务器发出请求时，服务器会返回数字证书给浏览器。浏览器接收到数字证书之后，会对数字证书进行验证。</p><p>首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。另外，在申请和使用证书的过程中，还需要注意以下三点：</p><ul><li>申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；</li><li>数字证书最核心的是 CA 使用它的私钥生成的数字签名；</li><li>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名</li></ul><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>极客时间《重学前端》专栏</p><p>极客时间《浏览器工作原理与实践》专栏</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;WEB 世界出现的最初目的就是开放与共享，任何资源都可以接入其中，我们的网站可以加载并执行别人网站的脚本文件、图片、音频、视频等资源，甚至可以下载其他站点的可执行文件。但是如果这种自由没有任何限制反而会引起彻底的混乱和无序，我们的数据与隐私将被肆意窃取。随着 WEB2.0 的时代来临，互联网从C/S架构（客服端/服务端结构）转变为 B/S 架构(浏览器/服务器结构），后者相比于前者更加方便快捷，因此浏览器便成为了我们访问网站的窗口，浏览器安全也随之变得越来越重要。&lt;/p&gt;
&lt;p&gt;浏览器安全主要可以分为&lt;strong&gt;Web页面安全&lt;/strong&gt;、&lt;strong&gt;浏览器网络安全&lt;/strong&gt;和&lt;strong&gt;浏览器系统安全&lt;/strong&gt;，接下来我们按照这三个方面分别进行介绍：&lt;/p&gt;</summary>
    
    
    
    <category term="浏览器工作原理" scheme="http://kyleezhang.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Chrome" scheme="http://kyleezhang.com/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存</title>
    <link href="http://kyleezhang.com/2021/03/16/client-cache/"/>
    <id>http://kyleezhang.com/2021/03/16/client-cache/</id>
    <published>2021-03-16T19:36:17.000Z</published>
    <updated>2022-06-12T11:24:41.821Z</updated>
    
    <content type="html"><![CDATA[<p>Web 缓存按存储位置来区分，包括数据库缓存、服务端缓存、CDN 缓存和浏览器缓存，浏览器缓存的实现方式主要有两种：HTTP 和 ServiceWorker 。</p><h2 id="http-缓存"><a class="markdownIt-Anchor" href="#http-缓存"></a> HTTP 缓存</h2><p>使用缓存最大的问题往往不在于将资源缓存在什么位置或者如何读写资源，而在于如何保证缓存与实际资源一致的同时，提高缓存的命中率。也就是说尽可能地让浏览器从缓存中获取资源，但同时又要保证被使用的缓存与服务端最新的资源保持一致。</p><p>为了达到这个目的，需要制定合适的缓存过期策略（简称“缓存策略”），HTTP 支持的缓存策略有两种：<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><a id="more"></a><h3 id="1-强制缓存"><a class="markdownIt-Anchor" href="#1-强制缓存"></a> 1、强制缓存</h3><p>强制缓存是在浏览器加载资源的时候，先直接从缓存中查找请求结果，如果不存在该缓存结果，则直接向服务端发起请求。</p><p><strong>(1) Expires</strong></p><p>HTTP/1.0 中可以使用响应头部字段 Expires 来设置缓存时间，它对应一个未来的时间戳。客户端第一次请求时，服务端会在响应头部添加 Expires 字段。当浏览器再次发送请求时，先会对比当前时间和 Expires 对应的时间，如果当前时间早于 Expires 时间，那么直接使用缓存；反之，需要再次发送请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Tue Mar 16 2021 00:00:00 GMT</span><br></pre></td></tr></table></figure><p>上述 Expires 信息告诉浏览器：在 2021.03.16 日之前，可以直接使用该请求的缓存。但是使用 Expires 响应头时容易产生一个问题，那就是服务端和浏览器的时间很可能不同，因此这个缓存过期时间容易出现偏差。同样的，客户端也可以通过修改系统时间来继续使用缓存或提前让缓存失效。</p><p>为了解决这个问题，HTTP/1.1 提出了 Cache-Control 响应头部字段。</p><p><strong>(2) Cache-Control</strong></p><p>它的常用值有下面几个：</p><ul><li>no-cache，表示使用协商缓存，即每次使用缓存前必须向服务端确认缓存资源是否更新；</li><li>no-store，禁止浏览器以及所有中间缓存存储响应内容；</li><li>public，公有缓存，表示可以被代理服务器缓存，可以被多个用户共享；</li><li>private，私有缓存，不能被代理服务器缓存，不可以被多个用户共享；</li><li>max-age，以秒为单位的数值，表示缓存的有效时间；</li><li>must-revalidate，当缓存过期时，需要去服务端校验缓存的有效性。</li></ul><p>这几个值可以组合使用，比如像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cache-control: public max-age&#x3D;31536000</span><br></pre></td></tr></table></figure><p>告诉浏览器该缓存为公有缓存，有效期 1 年。</p><p>需要注意的是，cache-control 的 max-age 优先级高于 Expires，也就是说如果它们同时出现，浏览器会使用 max-age 的值。</p><h3 id="2-协商缓存"><a class="markdownIt-Anchor" href="#2-协商缓存"></a> 2、协商缓存</h3><p>协商缓存的更新策略是不再指定缓存的有效时间了，而是浏览器直接发送请求到服务端进行确认缓存是否更新，如果请求响应返回的 HTTP 状态为 304，则表示缓存仍然有效。控制缓存的难题就是从浏览器端转移到了服务端。</p><p><strong>(1) Last-Modified 和 If-Modified-Since</strong></p><p>服务端要判断缓存有没有过期，只能将双方的资源进行对比。若浏览器直接把资源文件发送给服务端进行比对的话，网络开销太大，而且也会失去缓存的意义，所以显然是不可取的。有一种简单的判断方法，那就是通过响应头部字段 Last-Modified 和请求头部字段 If-Modified-Since 比对双方资源的修改时间。</p><p>具体工作流程如下：</p><ol><li><p>浏览器第一次请求资源，服务端在返回资源的响应头中加入 Last-Modified 字段，该字段表示这个资源在服务端上的最近修改时间；</p></li><li><p>当浏览器再次向服务端请求该资源时，请求头部带上之前服务端返回的修改时间，这个请求头叫 If-Modified-Since；</p></li><li><p>服务端再次收到请求，根据请求头 If-Modified-Since 的值，判断相关资源是否有变化，如果没有，则返回 304 Not Modified，并且不返回资源内容，浏览器使用资源缓存值；否则正常返回资源内容，且更新 Last-Modified 响应头内容。</p></li></ol><p>这种方式虽然能判断缓存是否失效，但也存在两个问题：</p><ol><li><p>精度问题，Last-Modified 的时间精度为秒，如果在 1 秒内发生修改，那么缓存判断可能会失效；</p></li><li><p>准度问题，考虑这样一种情况，如果一个文件被修改，然后又被还原，内容并没有发生变化，在这种情况下，浏览器的缓存还可以继续使用，但因为修改时间发生变化，也会重新返回重复的内容。</p></li></ol><p><strong>(2) ETag 和 If-None-Match</strong></p><p>为了解决精度问题和准度问题，HTTP 提供了另一种不依赖于修改时间，而依赖于文件哈希值的精确判断缓存的方式，那就是响应头部字段 ETag 和请求头部字段 If-None-Match。</p><p>具体工作流程如下：</p><ol><li><p>浏览器第一次请求资源，服务端在返响应头中加入 Etag 字段，Etag 字段值为该资源的哈希值；</p></li><li><p>当浏览器再次跟服务端请求这个资源时，在请求头上加上 If-None-Match，值为之前响应头部字段 ETag 的值；</p></li><li><p>服务端再次收到请求，将请求头 If-None-Match 字段的值和响应资源的哈希值进行比对，如果两个值相同，则说明资源没有变化，返回 304 Not Modified；否则就正常返回资源内容，无论是否发生变化，都会将计算出的哈希值放入响应头部的 ETag 字段中。</p></li></ol><p>这种缓存比较的方式也会存在一些问题，具体表现在以下两个方面。</p><ol><li><p>计算成本。生成哈希值相对于读取文件修改时间而言是一个开销比较大的操作，尤其是对于大文件而言。如果要精确计算则需读取完整的文件内容，如果从性能方面考虑，只读取文件部分内容，又容易判断出错。</p></li><li><p>计算误差。HTTP 并没有规定哈希值的计算方法，所以不同服务端可能会采用不同的哈希值计算方式。这样带来的问题是，同一个资源，在两台服务端产生的 Etag 可能是不相同的，所以对于使用服务器集群来处理请求的网站来说，使用 Etag 的缓存命中率会有所降低。</p></li></ol><p>需要注意的是，强制缓存的优先级高于协商缓存，在协商缓存中，Etag 优先级比 Last-Modified 高。既然协商缓存策略也存在一些缺陷，那么我们转移到浏览器端看看 ServiceWorker 能不能给我们带来惊喜。</p><h2 id="serviceworker"><a class="markdownIt-Anchor" href="#serviceworker"></a> ServiceWorker</h2><p>ServiceWorker 是浏览器在后台独立于网页运行的脚本，也可以这样理解，它是浏览器和服务端之间的代理服务器，是一种可编程网络代理，使我们能够控制页面所发送网络请求的处理方式。。ServiceWorker 非常强大，可以实现包括推送通知和后台同步等功能，更多功能还在进一步扩展，但其最主要的功能是通过拦截拦截浏览器请求并返回缓存的资源文件从而实现<strong>离线缓存</strong>。</p><h3 id="1-使用限制"><a class="markdownIt-Anchor" href="#1-使用限制"></a> 1、使用限制</h3><p>越强大的东西往往越危险，所以浏览器对 ServiceWorker 做了很多限制：</p><ol><li><p>在 ServiceWorker 中无法直接访问 DOM，但可以通过 postMessage 接口发送的消息来与其控制的页面进行通信，页面可在必要时对 DOM 执行操作；</p></li><li><p>ServiceWorker 只能在本地环境下或 HTTPS 网站中使用；</p></li><li><p>ServiceWorker 有作用域的限制，一个 ServiceWorker 脚本只能作用于当前路径及其子路径；</p></li><li><p>由于 ServiceWorker 属于实验性功能，所以兼容性方面会存在一些问题，可以在 Jake Archibald 的 <a href="https://jakearchibald.github.io/isserviceworkerready/#moar">is Serviceworker ready</a> 网站上查看浏览器的具体支持情况。</p></li><li><p>Service Worker 在不用时会被中止，并在下次有需要时重启，因此不能依赖 Service Worker onfetch 和 onmessage 处理程序中的全局状态。 如果存在需要持续保存并在重启后加以重用的信息可通过访问 IndexedDB API 实现。</p></li></ol><h3 id="2-使用方法"><a class="markdownIt-Anchor" href="#2-使用方法"></a> 2、使用方法</h3><p>通常遵循以下基本步骤来使用 service workers：</p><ol><li><p>service worker URL 通过 serviceWorkerContainer.register() 来获取和注册。</p></li><li><p>如果注册成功，service worker 就在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊类型的 worker 上下文运行环境，与主运行线程（执行脚本）相独立，同时也没有访问 DOM 的能力。</p></li><li><p>service worker 现在可以处理事件了。</p></li><li><p>受 service worker 控制的页面打开后会尝试去安装 service worker。最先发送给 service worker 的事件是安装事件(在这个事件里可以开始进行填充 IndexDB 和缓存站点资源)。这个流程同原生 APP 或者 Firefox OS APP 是一样的 — 让所有资源可离线访问。</p></li><li><p>当 oninstall 事件的处理程序执行完毕后，可以认为 service worker 安装完成了。</p></li><li><p>下一步是激活。当 service worker 安装完成后，会接收到一个激活事件(activate event)。 onactivate 主要用途是清理先前版本的 service worker 脚本中使用的资源。</p></li><li><p>Service Worker 现在可以控制页面了，但仅是在 register()  成功后的打开的页面。也就是说，页面起始于有没有 service worker ，且在页面的接下来生命周期内维持这个状态。所以，页面不得不重新加载以让 service worker 获得完全的控制。</p></li></ol><p>下图展示了 service worker 所有支持的事件：</p><img src="/assets/client-cache/01.png" /><p>下面我们通过示例来具体演示，在使用 ServiceWorker 脚本之前先要通过“注册”的方式加载它。常见的注册代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span>.navigator) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.navigator.serviceWorker</span><br><span class="line"></span><br><span class="line">    .register(<span class="string">&#x27;./sw.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    .then(<span class="built_in">console</span>.log)</span><br><span class="line"></span><br><span class="line">    .catch(<span class="built_in">console</span>.error)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.warn(<span class="string">&#x27;浏览器不支持 ServiceWorker!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先考虑到浏览器的兼容性，判断 window.navigator 中是否存在 serviceWorker 属性，然后通过调用这个属性的 register 函数来告诉浏览器 ServiceWorker 脚本的路径。</p><p>浏览器获取到 ServiceWorker 脚本之后会进行解析，解析完成会进行安装。可以通过监听 “install” 事件来监听安装，但这个事件只会在第一次加载脚本的时候触发。要让脚本能够监听浏览器的网络请求，还需要激活脚本。</p><p>在脚本被激活之后，我们就可以通过监听 fetch 事件来拦截请求并加载缓存的资源了。</p><p>下面是一个利用 ServiceWorker 内部的 caches 对象来缓存文件的示例代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CACHE_NAME = <span class="string">&#x27;ws&#x27;</span></span><br><span class="line"><span class="keyword">let</span> preloadUrls = [<span class="string">&#x27;/index.css&#x27;</span>]</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(CACHE_NAME)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(preloadUrls);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> caches.open(CACHE_NAME).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">const</span> path = event.request.url.replace(self.location.origin, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span> cache.add(path)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.error(e))</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码首先监听 install 事件，在回调函数中调用了 event.waitUntil() 函数并传入了一个 Promise 对象。event.waitUntil 用来监听多个异步操作，包括缓存打开和添加缓存路径。如果其中一个操作失败，则整个 ServiceWorker 启动失败。</p><p>然后监听了 fetch 事件，在回调函数内部调用了函数 event.respondWith() 并传入了一个 Promise 对象，当捕获到 fetch 请求时，会直接返回 event.respondWith 函数中 Promise 对象的结果。</p><p>在这个 Promise 对象中，我们通过 caches.match 来和当前请求对象进行匹配，如果匹配上则直接返回匹配的缓存结果，否则返回该请求结果并缓存。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p><a href="https://developers.google.com/web/fundamentals/primers/service-workers?hl=zh-cn">ServiceWorker简介</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers">使用 Service Workers</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Web 缓存按存储位置来区分，包括数据库缓存、服务端缓存、CDN 缓存和浏览器缓存，浏览器缓存的实现方式主要有两种：HTTP 和 ServiceWorker 。&lt;/p&gt;
&lt;h2 id=&quot;http-缓存&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#http-缓存&quot;&gt;&lt;/a&gt; HTTP 缓存&lt;/h2&gt;
&lt;p&gt;使用缓存最大的问题往往不在于将资源缓存在什么位置或者如何读写资源，而在于如何保证缓存与实际资源一致的同时，提高缓存的命中率。也就是说尽可能地让浏览器从缓存中获取资源，但同时又要保证被使用的缓存与服务端最新的资源保持一致。&lt;/p&gt;
&lt;p&gt;为了达到这个目的，需要制定合适的缓存过期策略（简称“缓存策略”），HTTP 支持的缓存策略有两种：&lt;strong&gt;强制缓存&lt;/strong&gt;和&lt;strong&gt;协商缓存&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="浏览器工作原理" scheme="http://kyleezhang.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Chrome" scheme="http://kyleezhang.com/tags/Chrome/"/>
    
  </entry>
  
</feed>
