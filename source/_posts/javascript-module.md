---
title: NodeJS中的模块机制
date: 2020-11-02 20:18:05
toc: true
tags:
- node
---

JavaScript自诞生以来很长一段时间大部分开发者都没有将其当成一门真正的编程语言，认为其只不过是一种又小又简单的网页脚本，没必要将其模块化，因此相较于Java、Python等其他高级语言JavaScript直到ES6才真正意义上拥有语言级的模块语法，在这之前JavaScript通过`<script>`标签引入代码的方式显得杂乱无章，而且如果一些无关的代码一不小心重名了全局变量，就会引起“命名空间污染”的问题，因此不得不采用命名空间的方案人为地约束代码，除此之外模块间的依赖关系完全依赖于文件引入的顺序，极易发生错误，CommonJS规范的提出主要就是为了弥补当时JavaScript没有标准模块系统的缺陷，以达到像Java、Python等语言一样开发大型应用的基础能力。

## CommonJS模块规范
CommonJS对模块的定义十分简单，主要分为**模块引用**、**模块定义**和**模块标识**3个部分。
1、 模块引用
在CommonJS规范中，存在require()方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中。
<!-- more -->
2、 模块定义
ommonJS规范提供了exports对象用于导出当前模块的方法或者变量，并且它是上下文唯一导出的出口。在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式：
```javascript
// math.js￼   
exports.add = function () {￼
    var sum = 0,￼         
    i = 0,￼           
    args = arguments,￼         
    l = args.length;￼       
    while (i < l) {￼          
        sum += args[i++];￼       
    }￼        
    return sum;￼      
};
```
3、 模块标识
模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以．、.．开头的相对路径，或者绝对路径。它可以没有文件名后缀．js。

CommonJS规范中模块的定义十分简单，接口也十分简洁。它的意义在于将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见，因此用户完全不必考虑变量污染，同时用户可以在模块内引入其他模块内引入其他模块，方便了模块之间依赖关系的管理。

## Node中模块的实现
Node在实现中并非完全按照规范实现，而是对模块规范进行了一定的取舍，同时也增加了少许自身需要的特性，在Node中引入模块，需要经历如下3个步骤。
1、 路径分析
2、 文件定位
3、 编译执行
在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。
> 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的。
> 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

接下来，我们展开详细的模块加载过程：

### 1、优先从缓存加载
与前端浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的地方在于，浏览器仅仅缓存文件，而Node缓存的是编译和执行之后的对象。不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

### 2、模块标识符分析
require()方法接受一个标识符作为参数。在Node实现中，正是基于这样一个标识符进行模块查找的。模块标识符在Node中主要分为以下几类：
- 核心模块，如http、fs、path等。
- .或..开始的相对路径文件模块。
- 以/开始的绝对路径文件模块。
- 非路径形式的文件模块，如自定义的connect模块。

核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快，同时由于核心模块在模块标识符分析的过程中判断优先级最高，因此如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。

以.或..开始的相对路径标识符和/开始的绝对路径标识符在分析过程中都会被当做文件模块来处理。在分析文件模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度仅慢于核心模块。

自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。Node在自定义模块定位具体文件时制定的查找策略称为**模块路径**，具体表现为一个路径组成的数组，我们可以通过在模块内打印module.paths属性查看，模块路径的生成规则如下所示：
❑ 当前文件目录下的node_modules目录。
❑ 父目录下的node_modules目录。
❑ 父目录的父目录下的node_modules目录。
❑ 沿路径向上逐级递归，直到根目录下的node_modules目录。
它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。

### 3、文件定位
从缓存加载的优化策略使得二次引入时不需要路径分析、文件定位和编译执行的过程，大大提高了再次加载模块时的效率。
但在文件的定位过程中，还有一些细节需要注意，这主要包括文件扩展名的分析、目录和包的处理

#### 文件扩展名分析
equire()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按．js、.json、.node的次序补足扩展名，依次尝试，在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的，所以这里是一个会引起性能问题的地方。小诀窍是：如果是．node和．json文件，在传递给require()的标识符中带上扩展名，会加快一点速度。另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。

#### 目录分析和包的处理
在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。
在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。

### 3、模块编译
在Node中，每个文件模块都是一个对象，它的定义如下：
```javascript
function Module(id, parent) {
    this.id = id;
    this.exports = {};
    this.parent = parent;

    if (parent && parent.children) {
        parent.children.push(this);
    }

    this.filename = null;
    this.loaded = false;
    this.children = [];
}
```
编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同，具体如下所示:
> .js文件: 通过fs模块同步读取文件后编译执行
> .node文件: 这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件
> .json文件: 通过fs模块同步读取文件后，用JSON.parse()解析并返回结果
> 其余扩展文件: 都被当作.js文件载入

每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。
根据不同的文件扩展名，Node会调用不同的读取方式，如．json文件的调用如下
```javascript
// Native extension for .json￼       
Module._extensions['.json'] = function(module, filename) {￼         
    var content = NativeModule.require('fs').readFileSync(filename, 'utf8');￼
    try {￼       
        module.exports = JSON.parse(stripBOM(content));￼
    } catch (err) {￼
        err.message = filename + ': ' + err.message;￼
        throw err;￼
    }￼
};
```
其中，Module._extensions会被赋值给require()的extensions属性，所以通过在代码中访问require.extensions可以知道系统中的已有的扩展加载方式，如果想对自定义的扩展名进行特殊的加载，可以通过类似require.extensions['.ext']的方式实现。早期的CoffeeScript文件就是通过添加require.extensions['.coffee']扩展的方式来实现加载的。