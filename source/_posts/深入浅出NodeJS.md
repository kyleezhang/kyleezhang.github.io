---
title: 《深入浅出NodeJS》读书笔记
date: 2021-07-17 16:53:05
toc: true
mathjax: false
categories: 
- 读书笔记
tags:
- Node
- 读书笔记
---

之前在微信读书零零散散看了一些章节，这次特意买了实体书认真全部看一遍，希望能用这篇博客去做一个记录和思考。

## 一、Node 简介

### 1、Node 的特点

- 异步IO: Node 在底层构建了很多异步 I/O 的 API，从文件的读取到网络请求等，这样的意义在于在 Node 中我们可以从语言层面很自然地进行并行 I/O 操作而无须等待之前的调用结束，在编程模型上可以极大的提升效率。
- 事件与回调函数: 事件的编程方式具有轻量级、松耦合、只关注事务点等优势，Node 将前端浏览器中应用广泛且成熟的事件引入后端，配合异步 I/O，将事件点暴露给业务逻辑，极大程度上方便了业务层的编码处理。但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是个主要的问题，Node 为此提供了回调函数，而且纵观下来回调函数也是最好的接受异步调用返回数据的方式。
- 单线程: Node 保持了 JavaScript 在浏览器中单线程的特点，而且在 Node 中 JavaScript 与其他线程是无法共享任何状态的，单线程最大的好处是不用在线线程间的状态同步问题，没有频繁切换线程上下文所带来的性能损耗，缺点在于无法利用多核 CPU、错误会引起整个应用退出、CPU 阻塞会导致无法继续调用异步 I/O。
- 跨平台: Node 借助 libuv 成功在操作系统与上层 Node 模块之间构建了一层平台层架构，因此借助 libuv 良好的架构设计 Node 实现了跨平台开发。

<!-- more -->
### 2、Node 的应用场景

- Node 本身面向网络的设计且擅长并行 I/O，因此能够有效地组织起更多的硬件资源，并且其基于事件循环强大的处理能力其非常适合 I/O 密集型的应用场景。
- 虽然由于 JavaScript 是单线程的原因并不能完美释放多核 CPU 的计算能力，但是由于 V8 实现的深度优化，同时借助 C/C++ 扩展模块或子进程的方式同样适用于处理 CPU 密集型场景
- 与遗留系统和平相处
- 分布式应用对于可伸缩性的要求非常高，借用 Node 并行 I/O 的能力可加速数据的获取流程。

## 二、模块机制

### 1、Node 的模块实现

在 Node 中引入模块需要经历如下三步：

- 路径分析
- 文件定位
- 编译执行

在 Node 中模块分为两类：一类是 Node 提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。核心模块在 Node 源码编译的过程中编译进了二进制执行文件。在 Node 进程启动时，部分核心模块就被直接加载进内存中，因此核心模块引入时会忽略掉文件定位与编译执行的两步，而且路径分析的优先级也是最高的，因此其加载速度要比文件模块快很多。文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程。

详细的模块加载过程如下：

（1）**优先从缓存加载**

需要注意以下两点：

- 浏览器仅仅缓存文件而 Node 缓存的是编译和执行后的对象；
- 核心模块的缓存检查会优于文件模块。

（2）**路径分析**

- 核心模块：优先级仅次于缓存加载，加载过程最快
- 路径形式的文件模块：require 方法会将路径转换为真实路径，并以真实路径为索引将编译结果存放到缓存中，由于指明了确切的文件位置，因此加载速度仅次于核心模块
- 自定义模块：指的是非核心模块也不是路径形式的标识符，是一种特殊的文件模块，由于其在加载过程中 Node 会逐个尝试**模块路径**中的路径，直到找到目标文件为止，因此其加载速度也是最慢的

> 注：模块路径是 Node 在定位文件模块的具体文件时指定的查找策略，具体表现为一个路径组成的数组，在代码中我们可以通过 module.paths 属性查看。

（3）**文件定位**

- 文件扩展名分析：CommonJS 模块规范允许标识符中不包含文件扩展名的情况，这时 Node 会按照 .js、.json、.node 的次序补足扩展名并调用 fs 模块同步阻塞式地判断文件是否存在。
- 目录分析和包：Node 会首先在当前目录下查找 package.json 文件并通过 JSON.parse 方法解析，获取到包描述对象后会根据 main 属性指定的文件名进行定位。

（4）**模块编译**

在定位到文件后首先是文件的读取，对于不同的文件扩展名其载入方式也有很大的不同：

- .js 文件：通过 fs 模块同步读取文件后编译执行
- .node 文件：C/C++ 编写的扩展文件，通过 dlopen 方法加载最后编译生成的文件
- .json 文件：通过 fs 模块同步读取文件后，用 JSON.parse 解析返回的结果
- 其余扩展名文件：都被当作 .js 文件载入

> 注：通过 require.extensions 属性可知道系统中已有的扩展加载方式，我们也可通过类似 require.extensions['.ext'] 的方式来实现加载，但是官方更支持先将其他语言编译成 js 文件后再加载，这样可避免将繁琐的编译加载等过程引入 Node 的执行过程中。

在读取到文件内容后紧接着就是根据不同的文件扩展名进行对应模块的编译

**JavaScript 文件**：

Node 会首先对获取到的 JavaScript 文件内容进行头尾包装，一个正常的 JavaScript 文件会被包装成如下的样子：

```js
(function (exports, require, module, __filename, __dirname) {
    ...
});
```

这样就对每个模块文件实现了作用域隔离，包装之后的代码会通过 vm 原生模块的 runInThisContext 方法执行，返回一个具体的 function 对象，然后将当前模块对象的 exports 属性、require 方法、module（模块对象自身）以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个 function 执行，执行后模块的 exports 属性被返回给调用方，这样 exports 属性上的任何属性及方法都可以被外部调用到，但是模块中的其余变量则不可直接被调用。

> 注：在 CommonJS 中每个文件都是一个模块对象，其具体定义如下：
```js
function Module(id, parent) {
    this.id = id;
    this.exports = {};
    this.parent = parent;
    if (parent && parent.children) {
        parent.children.push(this)
    }
    this.filename = null;
    this.loaded = false;
    this.children = [];
}
```

由于函数入参中传入的 exports 属性本质上是模块对象 module 的 exports 属性的引用，因此如果文件中对 exports 直接赋值会改变 exports 属性的引用，从而导致模块暴露异常。

**Node 文件**：

.node 文件是在编写了 C/C++ 模块之后编译产生的，所以这里 Node 主要是调用 process.dlopen 方法来加载和执行，在 Node 的架构下 dlopen 方法在 Windows 和 *nix 平台下分别有不同的实现，通过 libuv 层进行了封装。

**JSON 文件**：

JSON 文件的编译在 Node 中是最简单的，Node 利用 fs 模块同步读取 JSON 文件的内容之后再调用 JSON.parse 方法得到对象，然后将它赋给模块对象的 exports 以供外部调用。

### 2、核心模块
