<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/config/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/config/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/config/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kyleezhang.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"enable":true,"style":"tabs","active":false,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="学源于思">
<meta property="og:type" content="website">
<meta property="og:title" content="kyleezhang&#96;s Blog">
<meta property="og:url" content="http://kyleezhang.com/index.html">
<meta property="og:site_name" content="kyleezhang&#96;s Blog">
<meta property="og:description" content="学源于思">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="kyleezhang">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://kyleezhang.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>kyleezhang`s Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2KR3NK700N"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-2KR3NK700N');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f1621cb3fb0792bb294fce1b938d5eef";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="kyleezhang`s Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
    <a target="_blank" rel="noopener" href="https://github.com/kyleezhang " class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kyleezhang`s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2022/06/12/%E5%89%8D%E7%AB%AF%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/12/%E5%89%8D%E7%AB%AF%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">前端应该知道的服务端知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-12 19:29:55" itemprop="dateCreated datePublished" datetime="2022-06-12T19:29:55+00:00">2022-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">应用架构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分布式"><a class="markdownIt-Anchor" href="#分布式"></a> 分布式</h1>
<h2 id="一-大型网站系统的特点"><a class="markdownIt-Anchor" href="#一-大型网站系统的特点"></a> 一、大型网站系统的特点</h2>
<h3 id="1-高并发大流量"><a class="markdownIt-Anchor" href="#1-高并发大流量"></a> 1、<strong>高并发，大流量</strong></h3>
<p>需要面对高并发用户，大流量访问。Google 日均 PV 35 亿，日 IP 访问数 3 亿；腾讯 QQ 的最大在线用户数 1.4 亿（2011年数据）。</p>
<h3 id="2-高可用"><a class="markdownIt-Anchor" href="#2-高可用"></a> 2、<strong>高可用</strong></h3>
<p>系统 7 x 24 小时不间断服务。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/06/12/%E5%89%8D%E7%AB%AF%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9F%A5%E8%AF%86/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/12/28/node-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/28/node-principle/" class="post-title-link" itemprop="url">NodeJS的底层原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-28 00:08:45" itemprop="dateCreated datePublished" datetime="2021-12-28T00:08:45+00:00">2021-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文的内容主要分为两部分：</p>
<ul>
<li>NodeJS 的基础和架构</li>
<li>NodeJS 核心模块的实现</li>
</ul>
<h2 id="nodejs-的基础和架构"><a class="markdownIt-Anchor" href="#nodejs-的基础和架构"></a> NodeJS 的基础和架构</h2>
<h3 id="一-nodejs-的组成"><a class="markdownIt-Anchor" href="#一-nodejs-的组成"></a> 一、NodeJS 的组成</h3>
<p>Node.js 主要由 V8、Libuv 和第三方库组成。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/12/28/node-principle/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/09/13/graphql-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/graphql-01/" class="post-title-link" itemprop="url">GraphQL原理浅析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-13 23:10:16" itemprop="dateCreated datePublished" datetime="2021-09-13T23:10:16+00:00">2021-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文首先会从GraphQL规范讲起，先了解GraphQL语言本身，为什么会有这门语言，以及GraphQL规范中核心定义，然后再去了解GraphQL实现，graphql-js是如何解析，校验，执行GraphQL的。</p>
<h2 id="graphql-规范"><a class="markdownIt-Anchor" href="#graphql-规范"></a> GraphQL 规范</h2>
<blockquote>
<p>GraphQL规范是对GraphQL语法的抽象，规范中详细的定义了GraphQL语言的规则，以及GraphQL校验，执行等流程，不同语言的实现都应遵守GraphQL的规范。<a target="_blank" rel="noopener" href="https://graphql.github.io/graphql-spec/">https://graphql.github.io/graphql-spec/</a></p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/09/13/graphql-01/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/09/10/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/10/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS-02/" class="post-title-link" itemprop="url">《深入浅出NodeJS》读书笔记（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-10 08:13:07" itemprop="dateCreated datePublished" datetime="2021-09-10T08:13:07+00:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="七-网络编程"><a class="markdownIt-Anchor" href="#七-网络编程"></a> 七、网络编程</h2>
<h3 id="1-构建-tcp-服务"><a class="markdownIt-Anchor" href="#1-构建-tcp-服务"></a> 1、构建 TCP 服务</h3>
<p>TCP 全名传输控制协议，在 OSI 模型中属于传输层协议。具体如下图所示：</p>
<img src="/assets/深入浅出NodeJS/12.png">
<p>TCP 是面向连接的协议，其显著的特征是在传输之前需要 3 次握手形成会话，只有会话形成后，服务端和客户端之间才能互相发送数据。在创建会话的过程中，服务器端和客户端分别提供一个套接字，这两个套接字共同形成一个连接。服务器端与客户端则通过套接字实现两者之间的连接操作。</p>
<h4 id="1创建-tcp-服务器端"><a class="markdownIt-Anchor" href="#1创建-tcp-服务器端"></a> (1)创建 TCP 服务器端</h4>
<p>我们可以通过 net.createServer(listener) 即可创建一个 TCP 服务器，listener 是连接事件 connection 的侦听器，举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">socket</span>) &#123;</span><br><span class="line">    socket.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">        socket.<span class="title function_">write</span>(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;连接断开&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.<span class="title function_">write</span>(<span class="string">&quot;欢迎光临《深入浅出NodeJS》&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8124</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server bound&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们可以利用 Telnet 工具作为客户端与服务器进行会话交流:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telent 127.0.0.1 8124</span><br></pre></td></tr></table></figure>
<p>除了端口外我们也可以对 Domain Socket 进行监听：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.<span class="title function_">listen</span>(<span class="string">&#x27;tmp/echo.sock&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>Domain Socket 我们可以通过 nc 工具进行会话测试：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -U /tem/echo.sock</span><br></pre></td></tr></table></figure>
<p>除了使用上述工具外我们还可以自己创建客户端：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = net.<span class="title function_">connect</span>(&#123; <span class="attr">port</span>: <span class="number">8124</span> &#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client connected&#x27;</span>);</span><br><span class="line">    client.<span class="title function_">write</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">client.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">    client.<span class="title function_">end</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">client.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;client disconnected&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>执行上述客户端代码文件与使用 Telnet 和 nc 的会话结果别无差别，如果是 Domain Socket 在填写选项时，填写 path 即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = net.<span class="title function_">connect</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/tmp/echo.sock&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="2tcp-服务的事件"><a class="markdownIt-Anchor" href="#2tcp-服务的事件"></a> (2)TCP 服务的事件</h4>
<p><strong>服务器事件</strong></p>
<p>对于通过 net.createServer() 创建的服务器而言，它是一个 EventEmitter 实例，它的自定义事件有如下几种。</p>
<ul>
<li>listening：在调用 server.listen() 绑定端口或者 Domain Socket 后触发，简洁的写法为 server.listen(port, listeningListener)，通过 listen 方法的第二个参数传入。</li>
<li>connection：每个客户端套接字连接到服务器端时触发，简洁的写法为通过 net.createServer()，最后一个参数传递。</li>
<li>close：当服务器关闭时触发，在调用 server.close() 后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后会触发该事件。</li>
<li>error：当服务器发生异常时，将会触发该事件。</li>
</ul>
<p><strong>连接事件</strong></p>
<p>服务器可以同时与多个客户端保持连接，每个连接都是典型的可写可读的 Stream 对象，它具有如下自定义事件：</p>
<ul>
<li>data：当一端调用 write() 发送数据时，另一端会触发 data 事件，事件传递的数据即是 write() 发送的数据。</li>
<li>end：当连接中的任意一端发送了 FIN 数据时将会触发该事件。</li>
<li>connect：该事件用于客户端，当套接字与服务器端连接成功时会触发该事件。</li>
<li>drain：当任意一段调用 write() 发送数据时，当前这端会触发该事件。</li>
<li>error：当异常发生时，触发该事件。</li>
<li>close： 当套接字完全关闭时，触发该事件。</li>
<li>timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知该用户连接已经被闲置了。</li>
</ul>
<h3 id="2-构建-udp-服务"><a class="markdownIt-Anchor" href="#2-构建-udp-服务"></a> 2、构建 UDP 服务</h3>
<p>UDP 又称用户数据包协议，提供面向事务的简单不可靠信息传输服务，与 TCP 一样同属于网络传输层。其与 TCP 最大的不同在于 UDP 不是面向连接的。TCP 中连接一旦建立所有的会话都基于连接完成，客户端如果要与另一个服务端通信必须新建一个套接字来完成连接。但在 UDP 中一个套接字可以与多个 UDP 服务通信。</p>
<h4 id="1创建-udp-服务器端"><a class="markdownIt-Anchor" href="#1创建-udp-服务器端"></a> (1)创建 UDP 服务器端</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = dgram.<span class="title function_">createSocket</span>(<span class="string">&quot;udp4&quot;</span>)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span> (<span class="params">msg, rinfo</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server got:&quot;</span> + msg + <span class="string">&quot;from&quot;</span> + rinfo.<span class="property">address</span> + <span class="string">&quot;:&quot;</span> + rinfo.<span class="property">port</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&quot;lessoning&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> address = server.<span class="property">address</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;server listening&quot;</span> + <span class="string">&quot;:&quot;</span> + address.<span class="property">port</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">bind</span>(<span class="number">41234</span>)</span><br></pre></td></tr></table></figure>
<p>如上述示例所示，创建 UDP 服务端的核心在于创建 UDP 套接字，UDP 套接字一旦创建既可以作为客户端发送数据，也可以作为服务器端接收数据。想要让 UDP 套接字接收网络信息只需要调用 <code>dgram.bind(port, [address])</code> 方法对网卡和端口进行绑定即可。</p>
<h4 id="2创建-udp-客户端"><a class="markdownIt-Anchor" href="#2创建-udp-客户端"></a> (2)创建 UDP 客户端</h4>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">&quot;dgram&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="string">&quot;深入浅出NodeJS&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> client = dgram.<span class="title function_">createSocket</span>(<span class="string">&quot;udp4&quot;</span>)</span><br><span class="line">client.<span class="title function_">send</span>(message, <span class="number">0</span>, message.<span class="property">length</span>, <span class="number">41234</span>, <span class="string">&quot;localhost&quot;</span>, <span class="keyword">function</span> (<span class="params">err, bytes</span>) &#123;</span><br><span class="line">    client.<span class="title function_">close</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当使用套接字作为客户端时可以调用 send 方法发送消息到网络中，send 方法的参数如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="title function_">send</span>(buf, offset, length, port, address, [callback])</span><br></pre></td></tr></table></figure>
<p>与 TCP 连接的 write 方法相比 send 方法的参数列表要复杂的多，但是它更灵活的地方在于可以随意发送数据到网络中的服务器端。</p>
<h4 id="3udp套接字事件"><a class="markdownIt-Anchor" href="#3udp套接字事件"></a> (3)UDP套接字事件</h4>
<p>UDP 的套接字与 TCP 的不同，它只是 EventEmitter 实例，而非 Stream 实例，它具备如下自定义事件：</p>
<ul>
<li>message: 当 UDP 套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的事件为消息 Buffer 对象和一个远程地址信息。</li>
<li>listening: 当 UDP 套接字开始侦听时触发该事件。</li>
<li>close: 调用 close 方法时触发该事件，并不再触发 message 事件，如需再次触发 message 事件重新绑定即可。</li>
<li>error: 当异常发生时触发该事件，如果不侦听异常抛出，使进程退出。</li>
</ul>
<h3 id="3-构建-http-服务"><a class="markdownIt-Anchor" href="#3-构建-http-服务"></a> 3、构建 HTTP 服务</h3>
<p>HTTP 的全称是超文本传输协议，HTTP 构建于 TCP 之上，属于应用层协议。从协议的角度来说现在的应用如浏览器，其实是一个 HTTP 的代理，用户的行为将会转化为 HTTP 报文发送给服务器端。服务器端在处理请求后，发送响应报文给代理，因此 HTTP 服务只做两件事：处理 HTTP 请求和发送 HTTP 响应。</p>
<h4 id="1http-模块"><a class="markdownIt-Anchor" href="#1http-模块"></a> (1)http 模块</h4>
<p>Node 的 http 模块包含了对于 HTTP 处理的封装。在 Node 中 HTTP 服务继承自 TCP 服务器（net 模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP 服务与 TCP 服务有区别的地方在于，在开启了 keep-alive 之后，一个 TCP 会话可以用于多次请求和响应。TCP 以 connection 为单位进行服务，HTTP 服务以 request 为单位进行服务，http 模块是将 connection 到 request 的过程进行了封装。</p>
<p>除此之外，http 模块将连接所用的套接字读写抽象为 ServerRequest 和 ServerResponse 对象，它们分别对应请求和响应操作。在请求产生的过程中，http 模块拿到连接中传来的数据，调用二进制模块 http_parser 进行解析，在解析完请求报文的报头后，触发 request 事件，调用用户的业务逻辑，流程如下图所示：</p>
<img src="/assets/深入浅出NodeJS/13.png">
<p><strong>http 请求</strong></p>
<p>对于 TCP 连接的读操作，http 模块将其封装为 ServerRequest 对象。请求报文通过 http_parser 进行解析，报文头被解析为如下部分：</p>
<ul>
<li>req.method 属性: 标识请求方法，常见的请求方法有 GET、POST、DELETE等。</li>
<li>req.url 属性: 请求 url 路径</li>
<li>req.httpVersion属性: 请求的 http 版本，通常为 1.1</li>
<li>其余报头被解析为很规律的 <code>Key: Value</code> 格式，被解析后放置在 req.headers属性上</li>
</ul>
<p>报文体部分则被抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能进行操作，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> buffers = [];</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">trunk</span>) &#123;</span><br><span class="line">        buffers.<span class="title function_">push</span>(trunk)</span><br><span class="line">    &#125;).<span class="property">on</span> (<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(buffers);</span><br><span class="line">        res.<span class="title function_">end</span>(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>http 响应</strong></p>
<p>HTTP 响应相对简单一些，它封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部信息的 API 为 res.setHeader() 和 res.writeHeader()。可以调用 setHeader 进行多次设置，但只有调用了 writeHeader 后，报头才会写入到连接中，除此之外，http 模块会自动帮你设置一些头信息，如Date、Connection 等。</p>
<p>报文体部分则是调用 res.write() 和 res.end() 方法实现，后者与前者的区别在于 res.end() 会先调用 write() 发送数据，然后发送信号告知服务器这次响应结束。</p>
<p><strong>http 服务的事件</strong></p>
<p>HTTP 服务器也是 EventEmitter 的实例，实现的自定义事件列表如下所示：</p>
<ul>
<li>connection 事件: 在开始 HTTP 请求和响应前，客户端与服务端需要建立底层的 TCP 连接，这个连接可能因为开启了 keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次 conection 事件。</li>
<li>request 事件: 建立 TCP 连接后，http 模块底层将在数据流中抽象出 HTTP 请求和 HTTP 响应，当请求数据发送到服务器端，在解析出 HTTP 请求头后，将会触发该事件；在 res.end() 后，TCP 连接可能将用于下次请求响应。</li>
<li>data 事件: 与 TCP 服务器的行为一致，调用 server.close() 方法停止接受新的连接，当已有的连接都断开时触发该事件。</li>
<li>checkContinue 事件: 某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部为带 <code>Except：100-continue</code> 的请求到服务器，服务器将会触发 checkContinue 事件；如果没有为服务监听这个事件，服务器将会自动响应客户端 100 Continue 状态码，表示接受数据上传；如果不接受较多的数据时，响应客户端 400 Bad Request 拒绝客户端继续发送数据即可。需要注意的是，当该事件发生时不会触发 request 事件，两个事件之间互斥。当客户端收到 100 Continue 后重新发起请求时，才会触发 request 事件。</li>
<li>connect事件: 当客户端发起 CONNECT 请求时触发，而发起 CONNECT 请求通常在 HTTP 代理时出现；如果不监听该事件，发起该请求的连接将会关闭。</li>
<li>upgrade 事件: 当客户端要求升级连接的协议时，需要和服务器协商，客户端会在请求头中带上 Upgrade 字段，服务器端会在接收到这样的请求时触发该事件，如果不监听该事件，发起请求的连接将会关闭。</li>
<li>clientError 事件: 连接的客户端触发 error 事件时，这个错误会传递到服务器端，此时触发该事件。</li>
</ul>
<h4 id="2http-客户端"><a class="markdownIt-Anchor" href="#2http-客户端"></a> (2)http 客户端</h4>
<p>http 模块提供了一个底层 API：<code>http.request(options, connect)</code> 用于构造 HTTP 客户端，其中 options 参数决定了这个 HTTP 请求头中的内容，它的选项有如下这些：</p>
<ul>
<li>host: 服务器的域名或 IP 地址，默认 localhost。</li>
<li>hostname: 服务器名称。</li>
<li>port: 服务器端口，默认 80。</li>
<li>localAddress: 建立网络连接的本地网卡</li>
<li>socketPath: Domain 套接字路径。</li>
<li>method: HTTP请求方法。默认 GET。</li>
<li>path: 请求路径，默认为 /。</li>
<li>headers: 请求头对象。</li>
<li>auth: Basic 认证，这个值被计算成请求头中的 Authorization 部分。</li>
</ul>
<p>报文体的内容由请求对象的 write() 方法和 end() 方法实现：通过 write() 方法向连接中写入数据，通过 end() 方法告知报文结束。它与浏览器中的 Ajax 调用几近相同，Ajax 的实质就是一个异步的网络 HTTP 请求。</p>
<p><strong>http 响应</strong></p>
<p>HTTP 客户端的响应对象与服务器端较为类似，在 ClientRequest 对象中，它的事件叫做 response。ClientRequest 在解析响应报文时，一解析完响应头就触发 response 事件，同时传递一个响应对象以供操作 ClientResponse。后续响应报文体以只读流的方式提供。</p>
<p><strong>http 代理</strong></p>
<p>如同服务器端的实现一般，http 提供的 ClientRequest 对象也是基于 TCP 层实现的，在 keep-alive 的情况下，一个底层会话连接可以多次用于请求。为了重用 TCP 连接，http 模块包含一个默认的客户端代理对象 http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过 ClientRequest 对象对同一个服务器端发起的 HTTP 请求最多可以创建 5 个连接，其实质上就是一个连接池。</p>
<p>我们也可以通过自行构造代理对象来对限制数量进行修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> agent = <span class="keyword">new</span> http.<span class="title function_">agent</span>(&#123;</span><br><span class="line">    <span class="attr">maxSockets</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    <span class="attr">hostname</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">1234</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">agent</span>: agent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外还可以设置 agent 选项为 false 来脱离连接池的管理，使请求不受并发的限制。</p>
<p>Agent 对象的 sockets 和 requests 属性分别表示当前连接池中使用中的连接数和处于等待状态的请求数，在业务中监视这两个值有助于发现业务状态的繁忙程度。</p>
<p><strong>http 客户端事件</strong></p>
<ul>
<li>response: 与服务器端的 request 事件对应的客户端在请求发出后得到服务端响应时，会触发该事件。</li>
<li>socket: 当底层连接池中建立的连接分配给当前请求对象时，触发该事件。</li>
<li>connect: 当客户端向服务器端发起 Upgrate 请求时，如果服务器端响应了 101 Switching Protocal 状态，客户端将会触发该事件。</li>
<li>continue: 客户端向服务器端发起 <code>Expect: 100-continue</code> 头信息，以试图发送较大数据量，如果服务器端响应 100 Continue 状态，客户端将触发该事件。</li>
</ul>
<h3 id="4-构建-websocket-服务"><a class="markdownIt-Anchor" href="#4-构建-websocket-服务"></a> 4、构建 WebSocket 服务</h3>
<p>WebSocket 协议与 Node 之间的配合堪称完美，主要有两点：</p>
<ul>
<li>WebSocket 客户端基于事件的编程模型与 Node 中自定义事件相差无几。</li>
<li>WebSocket 实现了客户端与服务器端之间的长连接，而 Node 事件驱动的方式十分擅长与大量客户端保持高并发连接。</li>
</ul>
<p>除此之外 WebSocket 相较于 HTTP 还有如下好处：</p>
<ul>
<li>客户端与服务器端只建立一个 TCP 连接，可以使用更少的连接。</li>
<li>WebSocket 服务器端可以推送数据到客户端，这远比 HTTP 请求响应模式更灵活、更高效。</li>
<li>有更轻量级的协议头，减少数据传送量。</li>
</ul>
<p>相比于 HTTP，WebSocket 更接近于传输层协议，它并没有在 HTTP 的基础上模拟服务器端的推送，而是在 TCP 上定义独立的协议，HTTP 协议只是完成了其握手部分。</p>
<h4 id="1websocket-握手"><a class="markdownIt-Anchor" href="#1websocket-握手"></a> (1)WebSocket 握手</h4>
<p>客户端建立连接时，通过 HTTP 发起请求报文，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrate: websocket</span><br><span class="line">Connection: Upgrate</span><br><span class="line">Set-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Sec-WebScoket-Protocal: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13 </span><br></pre></td></tr></table></figure>
<p>与普通的 HTTP 请求协议略有区别的部分在于如下协议头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Upgrate: websocket</span><br><span class="line">Connection: Upgrate</span><br></pre></td></tr></table></figure>
<p>上述字段表示请求服务器端升级协议为 WebSocket。</p>
<p>Set-WebSocket-Key 的值是随机生成的 Base64 编码的字符串，主要用于安全校验，服务器端接收到之后将其与字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 相连形成字符串 “GhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后通过 sha1 安全散列算法计算出结果后，再进行 Base64 编码，最后返回客户端。</p>
<p>而 Sec-WebScoket-Protocal 和 Sec-WebSocket-Version 字段主要用于指定子协议和版本号。</p>
<p>服务端在处理完请求后响应报文如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrate: websocket</span><br><span class="line">Connection: Upgrate</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">Sec-WebSocket-Protocal: chat</span><br></pre></td></tr></table></figure>
<p>上面的报文告知客户端正在更换协议，更新应用层协议为 WebSocket 协议，并在当前的套接字连接上应用新协议。剩余的字段分别表示服务器端基于 Sec-WebSocket-Key 生成的字符串和选中的子协议。客户端将会校验 Sec-WebSocket-Accept 的值，如果成功将开始接下来的传输。</p>
<p>我们以如下代码进行演示：</p>
<p>浏览器端：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">WebSocket</span> = <span class="keyword">function</span> (<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// 伪代码，解析 ws://127.0.0.1/updates，用于请求</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">options</span> = <span class="title function_">parseUrl</span>(url)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">connect</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">WebSocket</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">WebSocket</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setSocket</span> = <span class="keyword">function</span> (<span class="params">socket</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">socket</span> = socket</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">WebSocket</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">connect</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="keyword">new</span> <span class="title class_">Buffer</span>(<span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">protocalVersion</span> + <span class="string">&#x27;-&#x27;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>()).<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> shasum = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;sha1&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> expected = shasum.<span class="title function_">update</span>(key + <span class="string">&#x27;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#x27;</span>).<span class="title function_">digest</span>(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">        <span class="attr">port</span>: <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">port</span>, <span class="comment">// 12010</span></span><br><span class="line">        <span class="attr">host</span>: <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">hostname</span>, <span class="comment">// 127.0.0.1</span></span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;Upgrade&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade&#x27;</span>: <span class="string">&#x27;websocket&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-WebSocket-Version&#x27;</span>: <span class="variable language_">this</span>.<span class="property">options</span>.<span class="property">protocalVersion</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Websocket-Key&#x27;</span>: key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> req = http.<span class="title function_">request</span>(options);</span><br><span class="line">    req.<span class="title function_">end</span>();</span><br><span class="line"></span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&#x27;upgrade&#x27;</span>, <span class="keyword">function</span> (<span class="params">res, socket, upgradeHead</span>) &#123;</span><br><span class="line">        <span class="comment">// 连接成功</span></span><br><span class="line">        that.<span class="title function_">setSocket</span>(socket)</span><br><span class="line">        <span class="comment">// 触发 open 事件</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onopen</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;tet/plain&#x27;</span> &#125;);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;Hello World\n&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">12010</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在收到 upgrade 请求后，告知客户端允许切换协议</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;upgrade&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, socket, upgradeHead</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> head = <span class="keyword">new</span> <span class="title class_">Buffer</span>(upgradeHead.<span class="property">length</span>)</span><br><span class="line">    upgradeHead.<span class="title function_">copy</span>(head)</span><br><span class="line">    <span class="keyword">var</span> key = req.<span class="property">headers</span>[<span class="string">&#x27;sec-websocket-key&#x27;</span>]</span><br><span class="line">    <span class="keyword">var</span> shasum = crypto.<span class="title function_">createHash</span>(<span class="string">&#x27;sha1&#x27;</span>)</span><br><span class="line">    key = shasum.<span class="title function_">update</span>(key + <span class="string">&#x27;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#x27;</span>).<span class="title function_">digest</span>(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line">    <span class="keyword">var</span> headers = [</span><br><span class="line">        <span class="string">&#x27;HTTP/1.1 101 Switching Protocols&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Upgrade: websocket&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Connection: Upgrade&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Sec-WebSocket-Accept: &#x27;</span> + key,</span><br><span class="line">        <span class="string">&#x27;Sec-WebSocket-Protocol: &#x27;</span> + protocol</span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// 让数据立即发送</span></span><br><span class="line">    socket.<span class="title function_">setNoDelay</span>(<span class="literal">true</span>)</span><br><span class="line">    socket.<span class="title function_">write</span>(headers.<span class="title function_">concat</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>).<span class="title function_">join</span>(<span class="string">&#x27;\r\n&#x27;</span>));</span><br><span class="line">    <span class="comment">// 建立服务器端 WebSocket 连接</span></span><br><span class="line">    <span class="keyword">var</span> websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>()</span><br><span class="line">    websocket.<span class="title function_">setSocket</span>(socket)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="2数据传输"><a class="markdownIt-Anchor" href="#2数据传输"></a> (2)数据传输</h4>
<p>在 WebSocket 协议中,数据传输阶段使用 frame（数据帧）进行通信，frame 分不同的类型，主要有：文本数据，二进制数据。出于安全考虑和避免网络截获，客户端发送的数据帧必须进行掩码处理后才能发送到服务器，不论是否是在 TLS 安全协议上都要进行掩码处理。服务器如果没有收到掩码处理的数据帧时应该关闭连接，发送一个 1002 的状态码。服务器不能将发送到客户端的数据进行掩码处理，如果客户端收到掩码处理的数据帧必须关闭连接。</p>
<p>那我们服务器端接收到的数据帧是怎样的呢？</p>
<img src="/assets/深入浅出NodeJS/14.png">
<p><strong>数据帧</strong></p>
<p>WebSocket 的数据传输是要遵循特定的数据格式-数据帧（frame）</p>
<img src="/assets/深入浅出NodeJS/15.png">
<p>每一列代表一个字节，一个字节8位，每一位又代表一个二进制数。</p>
<ul>
<li>fin: 标识这一帧数据是否是该分块的最后一帧。
<ul>
<li>1 为最后一帧</li>
<li>0 不是最后一帧。需要分为多个帧传输</li>
</ul>
</li>
<li>rsv1-3: 默认为0，接收协商扩展定义为非0设定。</li>
<li>opcode： 操作码，也就是定义了该数据是什么，如果不为定义内的值则连接中断。占四个位，可以表示0~15的十进制，或者一个十六进制。
<ul>
<li>%x0 表示一个继续帧</li>
<li>%x1 表示一个文本帧</li>
<li>%x2 表示一个二进制帧</li>
<li>%x3-7 为以后的非控制帧保留</li>
<li>%x8 表示一个连接关闭</li>
<li>%x9 表示一个ping</li>
<li>%x10 表示一个pong</li>
<li>%x11-15 为以后的控制帧保留</li>
</ul>
</li>
<li>masked： 占第二个字节的一位，定义了masking-key是否存在。并且使用masking-key掩码解析Payload data。
<ul>
<li>1 客户端发送数据到服务端</li>
<li>0 服务端发送数据到客户端</li>
</ul>
</li>
<li>payload length： 表示Payload data的总长度。占7位，或者7+2个字节、或者7+8个字节。
<ul>
<li>0-125，则是payload的真实长度</li>
<li>126，则后面2个字节形成的16位无符号整型数的值是payload的真实长度，125&lt;数据长度&lt;65535</li>
<li>127，则后面8个字节形成的64位无符号整型数的值是payload的真实长度，数据长度&gt;65535</li>
</ul>
</li>
<li>masking key： 0或4字节，当masked为1的时候才存在，为4个字节，否则为0，用于对我们需要的数据进行解密</li>
<li>payload data： 我们需要的数据，如果masked为1，该数据会被加密，要通过masking key进行异或运算解密才能获取到真实数据。</li>
</ul>
<p><strong>关于数据帧</strong></p>
<p>因为 WebSocket 服务端接收到的数据有可能是连续的数据帧，一个 message 可能分为多个帧发送。但如果使用 fin 来做消息边界是有问题的。</p>
<p>我发送了一个 27378 个字节的字符串，服务器端共接收到 2 帧，两帧的 fin 都为 1，而且根据规范计算出来的两帧的 payload data 的长度为 27372 少了 6 个字节。这缺少的 6 个字节其实刚好等于 2 个固有字节加上 maskingKey 的4个字节，也就是说第二帧就是一个纯粹的数据帧。这又是怎么回事呢？？</p>
<p>从结果推测实现，我们接收到的第 2 帧的数据格式不是帧格式，说明数据没有先分帧（分片）后再发送的。而是将一帧分包后发送的。</p>
<blockquote>
<p>分片<br />
分片的主要目的是允许当消息开始但不必缓冲该消息时发送一个未知大小的消息。如果消息不能被分片，那么端点将不得不缓冲整个消息以便在首字节发生之前统计出它的长度。对于分片，服务器或中间件可以选择一个合适大小的缓冲，当缓冲满时，写一个片段到网络。</p>
</blockquote>
<p>我们 27378 个字节的消息明显是知道 message 长度，那么就算这个 message 很大，根据规范 1 帧的数据长度理论上是 0 &lt; 数据长度 &lt; 65535 的，这种情况下应该 1 帧搞定，他也只是当做一帧来发送，但是由于传输限制，所以这一个帧（我们收到的像是好几帧一样）会被拆分成几块发送，除了第一块是带有 fin、opcode、masked 等标识符，之后收到的块都是纯粹的数据（也就是第一块的 payload data 的后续部分），这个就是 socket 的将 WebSocket 分好的一帧数据进行了分包发送。那么这种一帧被 socket 分包发送，导致像是分帧（分片）发送的情况（服务器端本应该只就收一帧），在服务器端我暂时还没有想到怎样获取状态来处理。</p>
<p>总结，客户端发送数据，在实现时还是需要手动进行分帧（分片）,不然就按照一帧发送，小数据量无所谓；如果是大数据量，就会被 socket 自动分包发送。这个与 WebSocket 协议规范所标榜的自动分帧（分片），存在的差异应该是各个浏览器在对 WebSocket 协议规范的实现上偷工减料所造成的。所以我们看见 <a target="_blank" rel="noopener" href="http://socket.io">socket.io</a> 等插件会有一个客户端接口，应该就是为了重新是实现 WebSocket 协议规范。从原理出发，我们接下来还是以小数据量（单帧）数据传输为例了。</p>
<p><strong>解析数据帧</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dataHandler.js</span></span><br><span class="line"><span class="comment">// 收集本次message的所有数据</span></span><br><span class="line"><span class="title function_">getData</span>(<span class="params">data, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getState</span>(data);</span><br><span class="line">    <span class="comment">// 如果状态码为8说明要关闭连接</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">opcode</span> == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">OPEN</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">closeSocket</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是心跳pong,回一个ping</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">opcode</span> == <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">OPEN</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">pingTimes</span> = <span class="number">0</span>;<span class="comment">// 回了pong就将次数清零</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集本次数据流数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dataList</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">payloadData</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度为0，说明当前帧位最后一帧。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">remains</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(<span class="variable language_">this</span>.<span class="property">dataList</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">payloadLength</span>);</span><br><span class="line">        <span class="comment">//使用掩码maskingKey解析所有数据</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>.<span class="title function_">parseData</span>(buf);</span><br><span class="line">        <span class="comment">// 数据接收完成后回调回业务函数</span></span><br><span class="line">        <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">socket</span>, result);</span><br><span class="line">        <span class="comment">//重置状态，表示当前message已经解析完成了</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">resetState</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 收集本次message的所有数据</span></span><br><span class="line"><span class="title function_">getData</span>(<span class="params">data, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getState</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集本次数据流数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dataList</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">payloadData</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度为0，说明当前帧位最后一帧。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">remains</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(<span class="variable language_">this</span>.<span class="property">dataList</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">payloadLength</span>);</span><br><span class="line">    <span class="comment">//使用掩码maskingKey解析所有数据</span></span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>.<span class="title function_">parseData</span>(buf);</span><br><span class="line">    <span class="comment">// 数据接收完成后回调回业务函数</span></span><br><span class="line">        <span class="title function_">callback</span>(<span class="variable language_">this</span>.<span class="property">socket</span>, result);</span><br><span class="line">    <span class="comment">//重置状态，表示当前message已经解析完成了</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">resetState</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析本次message所有数据</span></span><br><span class="line"><span class="title function_">parseData</span>(<span class="params">allData, callback</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> len = allData.<span class="property">length</span>,</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; len; i++)&#123;</span><br><span class="line">        allData[i] = allData[i] ^ <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">maskingKey</span>[ i % <span class="number">4</span> ];<span class="comment">// 异或运算，使用maskingKey四个字节轮流进行计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断数据类型，如果为文本类型</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">opcode</span> == <span class="number">1</span>) allData = allData.<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>组装需要发送的数据帧</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组装数据帧，发送是不需要掩码加密</span></span><br><span class="line"><span class="title function_">createData</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dataType = <span class="title class_">Buffer</span>.<span class="title function_">isBuffer</span>(data);<span class="comment">// 数据类型</span></span><br><span class="line">    <span class="keyword">let</span> dataBuf, <span class="comment">// 需要发送的二进制数据</span></span><br><span class="line">        dataLength,<span class="comment">// 数据真实长度</span></span><br><span class="line">        dataIndex = <span class="number">2</span>; <span class="comment">// 数据的起始长度</span></span><br><span class="line">    <span class="keyword">let</span> frame; <span class="comment">// 数据帧</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dataType) dataBuf = data;</span><br><span class="line">    <span class="keyword">else</span> dataBuf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(data); <span class="comment">// 也可以不做类型判断，直接Buffer.form(data)</span></span><br><span class="line">    dataLength = dataBuf.<span class="property">byteLength</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算payload data在frame中的起始位置</span></span><br><span class="line">    dataIndex = dataIndex + (dataLength &gt; <span class="number">65535</span> ? <span class="number">8</span> : (dataLength &gt; <span class="number">125</span> ? <span class="number">2</span> : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    frame = <span class="keyword">new</span> <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(dataIndex + dataLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个字节,fin = 1,opcode = 1</span></span><br><span class="line">    frame[<span class="number">0</span>] = <span class="built_in">parseInt</span>(<span class="number">10000001</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长度超过65535的则由8个字节表示，因为4个字节能表达的长度为4294967295，已经完全够用，因此直接将前面4个字节置0</span></span><br><span class="line">    <span class="keyword">if</span>(dataLength &gt; <span class="number">65535</span>)&#123;</span><br><span class="line">        frame[<span class="number">1</span>] = <span class="number">127</span>; <span class="comment">//第二个字节</span></span><br><span class="line">        frame.<span class="title function_">writeUInt32BE</span>(<span class="number">0</span>, <span class="number">2</span>); </span><br><span class="line">        frame.<span class="title function_">writeUInt32BE</span>(dataLength, <span class="number">6</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dataLength &gt; <span class="number">125</span>)&#123;</span><br><span class="line">        frame[<span class="number">1</span>] = <span class="number">126</span>;</span><br><span class="line">        frame.<span class="title function_">writeUInt16BE</span>(dataLength, <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        frame[<span class="number">1</span>] = dataLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端发送到客户端的数据</span></span><br><span class="line">    frame.<span class="title function_">write</span>(dataBuf.<span class="title function_">toString</span>(), dataIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>心跳检测</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 心跳检查</span></span><br><span class="line"><span class="title function_">sendCheckPing</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        <span class="keyword">if</span> (_this.<span class="property">pingTimes</span> &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            _this.<span class="title function_">closeSocket</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录心跳次数</span></span><br><span class="line">        _this.<span class="property">pingTimes</span>++;</span><br><span class="line">        <span class="keyword">if</span>(_this.<span class="property">pingTimes</span> == <span class="number">100000</span>) _this.<span class="property">pingTimes</span> = <span class="number">0</span>;</span><br><span class="line">        _this.<span class="title function_">sendCheckPing</span>();</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送心跳ping</span></span><br><span class="line"><span class="title function_">sendPing</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ping = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">2</span>);</span><br><span class="line">    ping[<span class="number">0</span>] = <span class="built_in">parseInt</span>(<span class="number">10001001</span>, <span class="number">2</span>);</span><br><span class="line">    ping[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">writeData</span>(ping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关闭连接</strong></p>
<p>客户端直接调用close方法，服务器端可以使用socket.end方法。</p>
<h2 id="八-构建-web应用"><a class="markdownIt-Anchor" href="#八-构建-web应用"></a> 八、构建 Web应用</h2>
<h3 id="1-基础功能"><a class="markdownIt-Anchor" href="#1-基础功能"></a> 1、基础功能</h3>
<h4 id="1请求方法"><a class="markdownIt-Anchor" href="#1请求方法"></a> (1)请求方法</h4>
<p>HTTP_Parser 在解析请求报文时会将报文头中的请求方法抽取出来设置为 req.method。</p>
<h4 id="2路径解析"><a class="markdownIt-Anchor" href="#2路径解析"></a> (2)路径解析</h4>
<p>HTTP_Parser 将其解析为 req.url。一般而言，完整的 URL 地址是如下这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://user:pass@host.com:8080/p/a/t/h?query=string#hash</span><br></pre></td></tr></table></figure>
<p>但是客户端代理（浏览器）会将这个地址解析成报文，将路径和查询报文放在报文第一行，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /p/a/t/h?query=string HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>因此最终得到的 req.url 的值为 ‘/p/a/t/h?query=string’。</p>
<h4 id="3查询字符串"><a class="markdownIt-Anchor" href="#3查询字符串"></a> (3)查询字符串</h4>
<p>查询字符串位于路径之后，形成请求报文首行的第二部分，Node 提供了 querystring 模块用于处理这部分数据。</p>
<h4 id="4cookie"><a class="markdownIt-Anchor" href="#4cookie"></a> (4)Cookie</h4>
<p>HTTP 是一个无状态的协议，但现实中的业务却是需要一定的状态的，这就催生了 Cookie 的诞生，客户端发送的 Cookie 在请求报文的 Cookie 字段中，HtTP_Parser 会将所有的报文字段解析到 req.headers 上，Cookie 是 req.headers.cookie。具体内容格式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;csrftoken=HpZuyoYbH_hOQWHUv-0bbb9H; Hm_lvt_f1621cb3fb0792bb294fce1b938d5eef=1632186900; Hm_lpvt_f1621cb3fb0792bb294fce1b938d5eef=1633872461&#x27;</span><br></pre></td></tr></table></figure>
<p>除此之外我们还可以在服务端通过 Set-Cookie 字段设置客户端 Cookie，除了 name=value 是必须包含的部分还有如下几个主要参数配置项：</p>
<ul>
<li>path：表示这个 Cookie 影响到的路径。</li>
<li>Expires 和 Max-Age 是用来告诉浏览器这个 Cookie 何时过期的，如果不设置这个该选项在关闭浏览器时会丢失掉这个 Cookie，如果设置了浏览器会把 Cookie 内容写入磁盘中并保存。</li>
<li>HttpOnly：告知浏览器不允许通过脚本 document.cookie 来更改 cookie</li>
<li>Secure：当 Secure 值为 true 时，在 HTTP 中是无效的，在 HTTPS 中才有效。</li>
</ul>
<h4 id="5session"><a class="markdownIt-Anchor" href="#5session"></a> (5)Session</h4>
<p>Session 的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次被传递，但是还需要将每个客户和服务器中的数据一一对应起来，这里主要有常见的两种实现方式：</p>
<ul>
<li>基于 Cookie 来实现用户和数据映射。</li>
<li>通过查询字符串来实现浏览器端和服务器端数据的对应。</li>
</ul>
<p>两种方法实现的思路主要是通过 Cookie 携带 Session 的口令或通过请求中的查询字符串来携带。</p>
<p>除此之外我们还需要注意如下亮点：</p>
<ul>
<li>Session 与内存：如果将 Session 数据存放在内存中一方面 Node 有内存大小限制，并且 Node 的进程与进程之间也无法共享内存，因此常用的方案是将 Session 集中化，转移到集中的数据存储中，常用的工具是 Redis、Memcached。</li>
<li>Session 与安全：Session 的口令依然保存在客户端，因此会存在口令被盗用的情况，有一种做法是将这个口令通过私钥加密进行签名，这样即使攻击者知道口令也无法伪造签名信息，但是如果攻击者通过某种方式获取了一个真实的口令和签名他就能实现身份的伪装。因此另一种方案是将客户端的某些独有信息与口令作为原值进行签名，这样攻击者一旦不在原始的客户端访问就会导致签名失败。</li>
</ul>
<h4 id="6缓存"><a class="markdownIt-Anchor" href="#6缓存"></a> (6)缓存</h4>
<p>HTTP 支持的缓存策略主要分为 “强制缓存” 和 “协商缓存”。“强制缓存“ 主要通过 Expires 和 Cache-Control 字段，而 “协商缓存” 主要通过 Last-Modified 和 If-Modified-Since、ETag 和 If-None-Match，更多详情可查看我的博客<a target="_blank" rel="noopener" href="https://kyleezhang.github.io/2021/03/16/client-cache/">浏览器缓存</a>。</p>
<p>除了设置缓存之外我们还需要服务端意外更新后通过客户端及时更新的能力，这使得我们在使用缓存时也要为其设定版本号，所幸浏览器是根据 URL 进行缓存，那么一旦内容有更新时，我们就让浏览器发起新的 URL 请求，使得新内容能够被客户端更新。一般的更新机制有如下两种：</p>
<ul>
<li>每次发布路径中跟随 Web 应用的版本号。</li>
<li>每次发布路径中跟随文件内容的 hash 值。</li>
</ul>
<h4 id="7basic-认证"><a class="markdownIt-Anchor" href="#7basic-认证"></a> (7)Basic 认证</h4>
<p>Basic 认证是当客户端与服务端进行请求时，允许通过用户名和密码实现的一种身份认证方式。如果一个页面需要 Basic 认证，它会检查请求报文头中的 Authorization 字段的内容，该字段的值由认证方式和加密值构成，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dXNlcjpwYXNz</span><br></pre></td></tr></table></figure>
<p>在 Basic 认证中，它会将用户和密码部分组合：username + “:” + password 。然后进行 base64 编码。</p>
<p>Basic 认证虽然经过 Base64 加密后在网络传送，但是这近乎明文十分危险，一般只有在 HTTPS 的情况下才会使用，不过 Basic 认证的支持范围十分广泛，几乎所有的浏览器都支持它。</p>
<h3 id="2-数据上传"><a class="markdownIt-Anchor" href="#2-数据上传"></a> 2、数据上传</h3>
<p>Node 的 http 模块只对 HTTP 报文的头部进行了解析，然后触发了 request 事件。如果请求中还带有内容部分，内容部分需要用户自行接收和解析。</p>
<p>我们可以通过报头中的 Transfer-Encoding 或 Content-Length 字段判断请求中是否带有内容。</p>
<p>在 HTTP_Parser 解析报头结束后，报文内容部分会通过 data 事件触发，我们只需要以流的方式处理即可，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">hasBody</span> = (<span class="params">req</span>) =&gt; <span class="string">&#x27;transfer-encoding&#x27;</span> <span class="keyword">in</span> req.<span class="property">headers</span> || <span class="string">&#x27;content-length&#x27;</span> <span class="keyword">in</span> req.<span class="property">headers</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasBody</span>(req)) &#123;</span><br><span class="line">        <span class="keyword">var</span> buffers = []</span><br><span class="line">        req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">chunk</span>) &#123;</span><br><span class="line">            buffers.<span class="title function_">push</span>(chunk)</span><br><span class="line">        &#125;)</span><br><span class="line">        req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            req.<span class="property">rawBody</span> = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(buffers).<span class="title function_">toString</span>()</span><br><span class="line">            <span class="title function_">handle</span>(req, res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">handle</span>(req, res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1表单数据"><a class="markdownIt-Anchor" href="#1表单数据"></a> (1)表单数据</h4>
<p>通过 form 标签默认的表单提交请求头中的 Content-Type 字段值为 application/x-www-form-urlencoded，而它的报文体内容与查询字符串相同：<code>foo=bar&amp;baz=val</code>，因此它的解析非常容易：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.<span class="property">header</span>[<span class="string">&#x27;content-type&#x27;</span>] === <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>) &#123;</span><br><span class="line">        req.<span class="property">body</span> = querystring.<span class="title function_">parse</span>(req.<span class="property">rawBody</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2其他格式"><a class="markdownIt-Anchor" href="#2其他格式"></a> (2)其他格式</h4>
<p>除了表单数据外常见的提交还有 JSON 和 XML 文件等，判断它们的方式也是通过 Content-Type 字段，值分别为 application/json 和 application/xml。</p>
<p>json 文件的解析是非常简单的，我们可以直接通过 JSON.parse 方法进行解析，XML 文件的解析稍微复杂一些但我们也可以采用 XML 文件到 JSON 对象转换的库，例如 xml2js 模块。</p>
<h4 id="3附件上传"><a class="markdownIt-Anchor" href="#3附件上传"></a> (3)附件上传</h4>
<p>通常的表单，其内容可以通过 urlencoded 的方式编码内容形成报文体，再发送给服务器端，但是业务场景往往需要用户直接提交文件。在前端 HTML 代码中，特殊表单与普通表单的差异在于该表单中可以含有 file 类型的控件，以及需要指定表单属性 enctype 为 multipart/form-data，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>浏览器在遇到 multipart/form-data 表单提交时，构造的请求报文与普通报文完全不同。首先它的报头中最为特殊的如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=AaB03x</span><br><span class="line">Content-Length: 18231</span><br></pre></td></tr></table></figure>
<p>它代表本次提交的内容是由多部分构成的，其中 boundary=AaB03x 是随机生成的一段字符串，制定每部分内容的分界符。报文的内容将通过在它前面添加 ‘–’ 进行分割，报文结束在它前后都加 ‘–’ 表示结束。另外 Content-Length 的值必须确保是报文体的长度。</p>
<p>在知晓了报问题是如何构成之后解析就变得非常容易，但是对于未知大小的数据量进行处理时依然需要小心，我们也可以采用一些第三方库比如 formidable 来协助我们处理。</p>
<h4 id="4数据上传与安全"><a class="markdownIt-Anchor" href="#4数据上传与安全"></a> (4)数据上传与安全</h4>
<p><strong>内存限制</strong></p>
<p>在我们通过 Node 解析表单、JSON 和 XML 部分时我们采取的策略往往是先保存用户提交的所有数据，然后再解析处理，最后再传递给业务逻辑。这种策略潜在的问题是它仅仅适合数据量小的提交请求，一旦数据量过大将发生内存被占光的情景。</p>
<p>要解决这个问题主要有两种方案：</p>
<ul>
<li>限制上传内容的大小，一旦超过限制，停止接受数据，并响应 400 状态码</li>
<li>通过流式解析，将数据流导向磁盘中，Node 只保留文件路径等小数据</li>
</ul>
<p><strong>CSRF</strong></p>
<p>服务器端与客户端通常通过 Cookie 来标识和认证用户，但是部分情况下会出现通过引诱用户点击恶意网站的链接来冒充用户的信息，除了通过配置 Cookie 的相关属性外我们还可以通过添加随机值的方式来解决。也就是说为每个请求的用户，在 Session 中赋予一个随机值，由于该值是一个随机值，攻击者构造出相同随机值的难度相当大，我们只需要在接收端做一次校验就能轻易地识别出该请求是否为伪造的。</p>
<h3 id="3-路由解析"><a class="markdownIt-Anchor" href="#3-路由解析"></a> 3、路由解析</h3>
<p>对于不同的业务我们希望有不同的处理方式，这就带来了路由的选择问题。</p>
<h4 id="1文件路径型"><a class="markdownIt-Anchor" href="#1文件路径型"></a> (1)文件路径型</h4>
<p><strong>静态文件</strong></p>
<p>这种路由的处理方式十分简单，将请求路径对应的文件发送到客户端即可。</p>
<p><strong>动态文件</strong></p>
<p>这种方式的实现原理是 Web 服务器根据 URL 路径找到对应的文件，如 index.asp。Web 服务器根据文件名的后缀去寻找脚本的解析器，并传入 HTTP 请求的上下文。</p>
<p>现今大多数服务器都能很智能地根据后缀同时服务动态文件和静态文件。但这种方式在 Node 中不太常见，主要原因是文件的后缀都是 js，分不清是后端脚本还是前端脚本。而且 Node 中 Web 服务器与应用业务脚本是一体的，也无须按照这种方式实现。</p>
<h4 id="2mvc"><a class="markdownIt-Anchor" href="#2mvc"></a> (2)MVC</h4>
<p>MVC 模型的主要思想是将业务逻辑按职责分离，主要分为以下几种：</p>
<ul>
<li>控制器 Controller，一组行为的集合</li>
<li>模型 Model，数据相关的操作和封装</li>
<li>视图 View，视图的渲染</li>
</ul>
<p>这是目前最经典的封层模式，其工作模式如下：</p>
<ul>
<li>路由解析，根据 URL 寻找到对应的控制器和行为。</li>
<li>行为调用相关的模型，进行数据操作。</li>
<li>数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。</li>
</ul>
<p>这里如何根据 URL 做路由映射主要有两种方法实现，一种是通过手工关联映射，一种是自然关联映射。前者会有一个对应的路由文件来将 URL 映射到对应的控制器，后者没有这样的文件。</p>
<p>手工映射主要是通过一个路由文件来将 URL 映射到对应的控制器，其对 URL 的要求十分灵活。不过这种映射关系的解析需要两大基本能力：正则匹配与参数解析，用于对 URL 中的携带参数进行提取与处理。</p>
<p>相较于手工关联，自然关联采用了按照一种约定的方式自然而然地实现路由而无须去维护路由映射文件的手段，例如我们可以对；路径进行如下的划分处理：</p>
<p><code>/controller/action/pararm1/param2/param3</code></p>
<p>以 ‘/user/setting/12/1987’ 为例，它会按照约定去找 controllers 目录下的 user 文件，将其 require 出来后，调用这个模块的 setting() 方法，而其余的值作为参数直接传递给这个方法。</p>
<p>总而言之，手工映射对 URL 的处理十分灵活，不过需要我们维护一份路由关系映射文件，而且依赖于正则匹配与参数解析的核心能力。而自然映射的设计十分简洁，但是如果 URL 变动，它的文件也需要发生变动，手工映射只需要改动路由映射即可。</p>
<h4 id="3restful"><a class="markdownIt-Anchor" href="#3restful"></a> (3)RESTful</h4>
<p>REST 的全称是 Representational State Transfer，中文含义是表现层状态转化。符合 REST 规范的设计，我们称为 RESTful 的设计。它的设计哲学主要是将服务端提供的内容实体看作是一个资源，并表现在 URL 上，然后通过请求方法定义资源的操作，通过 Accept 决定资源的表现形式。</p>
<p>RESTful 与 MVC 的设计并不冲突，而且是更好的改进。相比 MVC，RESTful 只是将 HTTP 请求方法也加入了路由的过程，以及在 URL 的路径上体现得更资源化。</p>
<h3 id="4-中间件"><a class="markdownIt-Anchor" href="#4-中间件"></a> 4、中间件</h3>
<p>中间件的主要用于简化和隔离基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。</p>
<p>Node 的 http 模块提供了应用层协议网络的封装，对具体业务并没有支持，因此通过中间件搭建开发框架对业务提供强力支撑是很有必要的。</p>
<p>中间件的编写需要注意如下两个点：</p>
<ul>
<li>编写高效的中间件</li>
<li>合理利用路由，避免不必要的中间件执行</li>
</ul>
<h4 id="1编写高效的中间件"><a class="markdownIt-Anchor" href="#1编写高效的中间件"></a> (1)编写高效的中间件</h4>
<p>编写高效的中间件其实就是提升单个单元的处理速度，以尽早调用 next() 执行后续逻辑。由于中间件一旦被匹配，那么每个请求都会使该中间件执行一次，哪怕它只浪费1毫秒的执行时间，都会让我们的 QPS 显著下降。常见的优化方法主要有：</p>
<ul>
<li>使用高效的方法，必要时通过 <a target="_blank" rel="noopener" href="http://jsperf.com">jsperf.com</a> 测试基准性能。</li>
<li>缓存需要重复计算的结果</li>
<li>避免不必要的计算</li>
</ul>
<h4 id="2合理使用路由"><a class="markdownIt-Anchor" href="#2合理使用路由"></a> (2)合理使用路由</h4>
<p>在拥有了一堆高效的中间件后我们还需要对每个中间件的合理使用做出判断，避免中间件参与不必要的请求处理处理过程。</p>
<h3 id="5-页面渲染"><a class="markdownIt-Anchor" href="#5-页面渲染"></a> 5、页面渲染</h3>
<h4 id="1内容响应"><a class="markdownIt-Anchor" href="#1内容响应"></a> (1)内容响应</h4>
<p>服务端的响应从一定程度上决定或指示了客户端该如何处理响应的内容。因此响应包头中的 Content-* 字段十分重要。</p>
<p><strong>MIME</strong></p>
<p>不同的文件类型有不同的 MIME 值，响应在在 Content-Type 字段中返回以便客户端进行对应的处理。</p>
<p>除了 MIME 值外，Content-Type 还可以包括一些参数，比如字符集。</p>
<p><strong>附件下载</strong></p>
<p>Content-Disposition 字段决定了客户端将相应报文数据当作即时浏览的内容，还是可下载的附件。当数据可以存为附件时，它的值为 attachemnt，如果只需即时查看时它的值为 inline。</p>
<p>除此之外 Content-Disposition 字段还能通过参数指定保存时应该使用的文件名。例如：</p>
<p><code>Content-Disposition: attachment; filename=&quot;filename.ext&quot;</code></p>
<p><strong>响应JSON</strong></p>
<p>我们可以通过指定 Content-Type 字段为 ‘application/json’ 快捷响应 JSON。</p>
<p><strong>响应跳转</strong></p>
<p>我们可以返回 302 状态码同时响应头添加 Location 字段来将用户跳转到别的 URL。</p>
<h4 id="2视图渲染"><a class="markdownIt-Anchor" href="#2视图渲染"></a> (2)视图渲染</h4>
<p>Web 应用最终呈现出来的内容都是通过一系列的视图渲染呈现出来的，在动态页面技术中，最终视图是由模板和数据共同生成出来的。</p>
<p>模板是带有特殊标签的 HTML 字段，通过与数据的渲染，将数据填充到这些特殊的标签中，最后生成普通的带数据的 HTML 片段。</p>
<h4 id="3模板"><a class="markdownIt-Anchor" href="#3模板"></a> (3)模板</h4>
<p>模板技术的实质上就是将模板文件和数据通过模版引擎生成最终的 HTML 代码，形成模板技术主要包括如下四个要素：</p>
<ul>
<li>模板语言</li>
<li>包含模板语言的模板文件</li>
<li>拥有动态数据的数据对象</li>
<li>模板引擎</li>
</ul>
<h5 id="模板引擎"><a class="markdownIt-Anchor" href="#模板引擎"></a> 模板引擎</h5>
<p>模板引擎的实现主要分为如下几个步骤：</p>
<ul>
<li>语法分解。提取出普通字符串和表达式，这个过程通常用正则表达式匹配出来。</li>
<li>处理表达式，将标签表达式转换成普通的语言表达式。</li>
<li>生成待执行的语句。</li>
<li>与数据一起执行，生成最终的字符串。</li>
</ul>
<p><strong>模板编译</strong></p>
<p>为了能够最终与数据一起执行生成字符串，我们需要将原始的模板字符串转换成一个函数对象，这个过程称为模板编译。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compile = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tpl = str.<span class="title function_">replace</span>(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="keyword">function</span> (<span class="params">match, code</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#x27; + obj.&quot;</span> + code + <span class="string">&quot;+ &#x27;&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    tpl = <span class="string">&quot;var tpl = &#x27;&quot;</span> + tpl + <span class="string">&quot;&#x27;\nreturn tpl;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;obj&#x27;</span>, tpl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compiled = <span class="title function_">compile</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> render = <span class="keyword">function</span> (<span class="params">compiled, data</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">compiled</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="with的应用"><a class="markdownIt-Anchor" href="#with的应用"></a> with的应用</h5>
<p>为了让模板引擎更加灵活，字符串能继续表达为字符串，变量能够自动寻找属于它的对象，我们需要引入关键字 with。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compile = <span class="keyword">function</span> (<span class="params">str, data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tpl = str.<span class="title function_">replace</span>(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="keyword">function</span> (<span class="params">match, code</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#x27; + &quot;</span> + code + <span class="string">&quot; + &#x27;&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    tpl = <span class="string">&quot;tpl = &#x27;&quot;</span> + tpl + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    tpl = <span class="string">&#x27;var tpl = &quot;&quot;;\nwith (obj) &#123;&#x27;</span> + tpl + <span class="string">&#x27;&#125;\nreturn tpl&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;obj&#x27;</span>, tpl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模板安全</strong></p>
<p>实际上 XSS 漏洞的产生大多数跟模板有关，如果数据传入的值为恶意字符串比如 <code>&lt;script&gt;slert(&quot;I am XSS&quot;)&lt;/script&gt;</code> 那么页面就会执行这个脚本。因此为了安全性，大多数模板都提供了转义的功能。转义就是将能形成 HTML 标签的字符转换成安全的字符，转义函数如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> excape = <span class="keyword">function</span> (<span class="params">html</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(html)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/&amp;(?!\w+;)/g</span>, <span class="string">&#x27;&amp;amp&#x27;</span>)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quot;&#x27;</span>)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#039;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让转义与非转义表现得更方便，我们可以使用不同的标签来表示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> render = <span class="keyword">function</span> (<span class="params">str, data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tpl = str</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/\n/g</span>, <span class="string">&#x27;\\n&#x27;</span>)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="keyword">function</span> (<span class="params">match, code</span>) &#123;</span><br><span class="line">            <span class="comment">// 转义</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#x27; + escope(&quot;</span> + code + <span class="string">&quot;) + &#x27;&quot;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/&lt;%-([\s\S]+?)%/g</span>, <span class="keyword">function</span> (<span class="params">match, code</span>) &#123;</span><br><span class="line">            <span class="comment">// 正常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#x27; + &quot;</span> + code + <span class="string">&quot; + &#x27;&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    tpl = <span class="string">&quot;tpl = &#x27;&quot;</span> + tpl + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    tpl = <span class="string">&#x27;var tpl = &quot;&quot;;\nwith(obj) &#123;&#x27;</span> + tpl + <span class="string">&#x27;&#125;\nreturn tpl;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;obj&#x27;</span>, <span class="string">&#x27;escape&#x27;</span>, tpl);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h5 id="模板逻辑"><a class="markdownIt-Anchor" href="#模板逻辑"></a> 模板逻辑</h5>
<p>为了让模板更强大一些我们为它添加逻辑代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compile = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tpl = str</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/\n/g</span>, <span class="string">&#x27;\\n&#x27;</span>) <span class="comment">// 将换行符替换</span></span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="keyword">function</span> (<span class="params">match, code</span>) &#123;</span><br><span class="line">            <span class="comment">// 转义</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#x27; + escope(&quot;</span> + code + <span class="string">&quot;)+ &#x27;&quot;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/&lt;%-([\s\S]+?)%&gt;/g</span>, <span class="keyword">function</span> (<span class="params">match, code</span>) &#123;</span><br><span class="line">            <span class="comment">// 正常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#x27; + &quot;</span> + code + <span class="string">&quot; + &#x27;&quot;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>, <span class="keyword">function</span> (<span class="params">match, code</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#x27;;\n&quot;</span> + code + <span class="string">&quot;\ntpl += &#x27;&quot;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/\&#x27;\n/g</span>, <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">        .<span class="title function_">replace</span>(<span class="regexp">/\n\&#x27;/gm</span>, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    tpl = <span class="string">&quot;tpl = &#x27;&quot;</span> + tpl + <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换空行</span></span><br><span class="line">    tpl = tpl.<span class="title function_">replace</span>(<span class="regexp">/&#x27;&#x27;/g</span>, <span class="string">&#x27;\&#x27;\\n\&#x27;&#x27;</span>);</span><br><span class="line">    tpl = <span class="string">&#x27;var tpl = &quot;&quot;;\nwith( obj || &#123;&#125;) &#123;\n&#x27;</span> + tpl + <span class="string">&#x27;\n&#125;\nreturn tpl;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;obj&#x27;</span>, <span class="string">&#x27;escape&#x27;</span>, tpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="集成文件系统"><a class="markdownIt-Anchor" href="#集成文件系统"></a> 集成文件系统</h5>
<p>结合我们之前实现的 compile() 与 render() 方法我们已经能够实现将输入的模板字符串进行编译替换的功能，但是通过模板编译生成的中间函数只与模板字符串相关，与具体的数据无关，因此我们可以采用模板预编译的方法，预编译缓存模板编译后的结果，以此实现一次编译多次执行。这里我们再集成文件系统：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">VIEW_FOLDER</span> = <span class="string">&#x27;/path/to/wwwroot/views&#x27;</span>;</span><br><span class="line"></span><br><span class="line">res.<span class="property">render</span> = <span class="keyword">function</span> (<span class="params">viewname, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cache[viewname]) &#123;</span><br><span class="line">        <span class="keyword">var</span> text;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            text = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">join</span>(<span class="variable constant_">VIEW_FOLDER</span>, viewname), <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            res.<span class="title function_">writeHead</span>(<span class="number">500</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">            res.<span class="title function_">end</span>(<span class="string">&#x27;模板文件错误&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cache[viewname] = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> compiled = cache[viewname];</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span> &#125;);</span><br><span class="line">    <span class="keyword">var</span> html = <span class="title function_">compiled</span>(data);</span><br><span class="line">    res.<span class="title function_">end</span>(html);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与文件系统集成后再引入缓存就可以很好的解决性能问题，接口也得到大大简化。</p>
<h5 id="子模板"><a class="markdownIt-Anchor" href="#子模板"></a> 子模板</h5>
<p>有的时候模板太大太过复杂，会增加维护上的困难，这就导致了子模板的诞生，子模板可以嵌套在别的模板中，多个模板可以嵌入同一个子模板中。我们可以采用 include 关键字实现模板的嵌套：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> files = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">preCompile</span>() = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> replaced = str.<span class="title function_">replace</span>(<span class="regexp">/&lt;%\s+(include.*)\s+%&gt;/g</span>, <span class="keyword">function</span> (<span class="params">match, data</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> partial = code.<span class="title function_">split</span>(<span class="regexp">/\s/</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!files[partial]) &#123;</span><br><span class="line">            files[partial] = fs.<span class="title function_">readFileSync</span>(path.<span class="title function_">join</span>(<span class="variable constant_">VIEW_FOLDER</span>, partial), <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> files[partial]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多层嵌套，继续替换</span></span><br><span class="line">    <span class="keyword">if</span> (str.<span class="title function_">match</span>(<span class="regexp">/&lt;%\s+(include.*)\s+%&gt;/</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">preCompile</span>(replaced);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> replaced</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 compile() 方法对字符串解析前先调用 preCompile 方法对数据进行预编译即可实现对子模板的支持。</p>
<h4 id="4bigpipe"><a class="markdownIt-Anchor" href="#4bigpipe"></a> (4)Bigpipe</h4>
<p>Bigpipe 是一个需要前后端配合实现的优化技术，它的主要思路是将页面分割成多个部分，先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，并最终渲染填充框架，完成整个网页的渲染，这个过程中需要前端 JavaScript 的参与，它负责将后续输出的数据渲染到页面上。</p>
<p>它比较重要的有如下几个点：</p>
<ul>
<li>页面布局框架</li>
<li>后端持续性数据输出</li>
<li>前端渲染</li>
</ul>
<h2 id="九-玩转进程"><a class="markdownIt-Anchor" href="#九-玩转进程"></a> 九、玩转进程</h2>
<h3 id="1-服务模型的变迁"><a class="markdownIt-Anchor" href="#1-服务模型的变迁"></a> 1、服务模型的变迁</h3>
<img src="/assets/深入浅出NodeJS/16.jpg" />
<h3 id="2-多进程架构"><a class="markdownIt-Anchor" href="#2-多进程架构"></a> 2、多进程架构</h3>
<p>Node 的多进程采用了著名的 Master-Worker 模式，即主从模式，主从模式是典型的分布式架构中用于并行处理业务的模式具备较好的可伸缩性和稳定性。主进程不负责具体的业务逻辑，而是负责调度或管理工作进程，工作进程负责具体的业务处理。</p>
<h4 id="1-创建子进程"><a class="markdownIt-Anchor" href="#1-创建子进程"></a> (1) 创建子进程</h4>
<p>child_process 模块给予了 Node 创建子进程的能力，它提供了 4 个方法用于创建子进程：</p>
<ul>
<li>spawn()：启动一个子进程来执行命令</li>
<li>exec()：启动一个子进程来执行命令，与 spawn() 不同的是其接口不同，它有一个回调函数获知子进程的状况</li>
<li>execFile()：启动一个子进程来执行可执行文件</li>
<li>fork()：与 spawn() 类似，不同点在于它创建 Node 的子进程只需要指定要执行的 JavaScript 文件模块即可</li>
</ul>
<p>注：</p>
<ol>
<li>spawn() 与 exec()、esecFile() 不同的是后两者创建时可以指定 timeout 属性设置超时时间，一旦创建的进程超过设定的时间将会被杀死。</li>
<li>exec() 与 execFile() 不同的是，exec() 适合执行已有的命令，execFile() 适合执行文件。</li>
</ol>
<p>举个🌰：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line">cp.<span class="title function_">spawn</span>(<span class="string">&#x27;node&#x27;</span>, [<span class="string">&#x27;worker.js&#x27;</span>])</span><br><span class="line">cp.<span class="title function_">exec</span>(<span class="string">&#x27;node worker.js&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, stdout, stderr</span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;)</span><br><span class="line">cp.<span class="title function_">execFile</span>(<span class="string">&#x27;worker.js&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, stdout, stderr</span>) &#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;)</span><br><span class="line">cp.<span class="title function_">fork</span>(<span class="string">&#x27;./worker.js&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/assets/深入浅出NodeJS/17.jpeg" />
<h4 id="2-进程间通信"><a class="markdownIt-Anchor" href="#2-进程间通信"></a> (2) 进程间通信</h4>
<p>在主从模式中要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信，进程间通信简称 IPC（Inter-Process Communication），其主要目的是为了让不同的进程能够相互的访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node 中实现 IPC 通道的方式如下所示：</p>
<img src="/assets/深入浅出NodeJS/18.jpeg" width="500" />
<p>Node 中 IPC 通道的具体细节实现由 libuv 提供，在 Windows 下由命名管道实现 (named pipe) 实现，*nix 系统则采用 Unix Domain Socket 实现。表现在应用层上的进程间通信只有简单的 message 事件和 send 方法，接口十分简洁和消息化。举个🌰：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_precess&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> n = cp.<span class="title function_">fork</span>(__dirname + <span class="string">&#x27;/sub.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line">n.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">m</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;PARENT got message:&#x27;</span>, m)</span><br><span class="line">&#125;)</span><br><span class="line">n.<span class="title function_">send</span>(&#123; <span class="attr">hello</span>: <span class="string">&#x27;world!&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sub.js</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">m</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;CHILD got message:&#x27;</span>, m)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">send</span>(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>那么 Node 创建 IPC 通道的具体实现是怎么样的呢？</p>
<p>父进程在实际创建子进程之前会创建 IPC 通道（在 Node 中 IPC 通道被抽象为 Stream 对象）并<strong>监听</strong>它，然后才真正创建出子进程，并通过环境变量 (Node_CHANNEL_FD) 告诉子进程这个 IPC 通道的文件描述符。子进程在启动的过程中，<strong>根据文件描述符去连接</strong>这个已存在的 IPC 通道，从而完成父子进程之间的连接。</p>
<p>注：只有启动的子进程是 Node 进程时，子进程才会根据环境变量去连接 IPC 通道，对于其他类型的子进程则无法实现进程间通信，除非其他进程也按约定去连接这个创建好的 IPC 通道。</p>
<h4 id="3-句柄传递"><a class="markdownIt-Anchor" href="#3-句柄传递"></a> (3) 句柄传递</h4>
<p>为了解决多个工作进程一个端口的问题通常的做法是<strong>代理模式</strong>，即主进程监听主端口、对外接收所有的网络请求，再将这些请求分别代理到不同的端口的进程上。其优点在于避免了端口不能重复监听的问题，而且我们可以在代理进程上做适当的负载均衡，但是由于<strong>进程每接收到一个连接将会用掉一个文件描述符</strong>，因此这种代理模式需要浪费一倍数量的文件描述符，这极大的影响了系统的扩展能力。</p>
<p>为了解决这个问题 Node 在版本 v0.5.9 引入了进程间发送句柄的功能。首先什么是句柄？</p>
<p><strong>句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符</strong>，因此句柄可以用来标识一个服务器端 socket 对象、一个客户端 socket 对象、一个套接字等。</p>
<p>接下来我们通过发送句柄来实现多进程监听同端口</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent.js</span></span><br><span class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> child1 = cp.<span class="title function_">fork</span>(<span class="string">&#x27;child.js&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> child2 = cp.<span class="title function_">fork</span>(<span class="string">&#x27;child.js&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>).<span class="title function_">createServer</span>();</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">1337</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    child1.<span class="title function_">send</span>(<span class="string">&#x27;server&#x27;</span>, server)</span><br><span class="line">    child2.<span class="title function_">send</span>(<span class="string">&#x27;server&#x27;</span>, server)</span><br><span class="line">    server.<span class="title function_">close</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// child.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;handed by child, pid is &#x27;</span> + process.<span class="property">pid</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">m, tcp</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="string">&#x27;server&#x27;</span>) &#123;</span><br><span class="line">        tcp.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="keyword">function</span> (<span class="params">socket</span>) &#123;</span><br><span class="line">            server.<span class="title function_">emit</span>(<span class="string">&#x27;connection&#x27;</span>, socket)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>那么我们为什么可以通过发送句柄来实现多进程监听同一端口呢？句柄发送的具体过程是什么样的呢？</p>
<p>目前子进程对象 send() 方法可以发送的句柄类型包括如下几种：</p>
<ul>
<li>net.Socket: TCP 套接字</li>
<li>net.Server: TCP 服务器</li>
<li>net.Native: C++ 层面的 TCP 套接字或 IPC 管道</li>
<li>dgram.Socket: UDP 套接字</li>
<li>dgram.Native: C++ 层面的 UDP 套接字</li>
</ul>
<p>send() 方法在将消息发送到 IPC 管道前，将消息组装成两个对象，一个参数是 handle，另一个是 message。message 的参数如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">cmd</span>: <span class="string">&#x27;NODE_HANDLE&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;net.Server&#x27;</span>,</span><br><span class="line">    <span class="attr">msg</span>: messsage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这儿的文件描述符 handle 实际上是一个整数值，而这个 message 对象在写入到 IPC 通道时也会通过 JSON.stringify() 进行序列化。所以最终发送到 IPC 通道中的信息都是字符串，<strong>send() 方法能发送消息和句柄并不意味着它能发送任意对象</strong>。</p>
<p><strong>连接了 IPC 通道的子进程可以读取到父进程发送的消息，将字符串通过 JSON.parse() 解析还原为对象后，才触发 message 事件将消息传递给应用层使用。在这个过程中消息对象还要被进行过滤处理，message.cmd 的值如果以 NODE_ 为前缀，它将响应一个内部事件 internalMessage。如果 message.cmd 的值为 NODE_HANDLE，它将取出 message.type 值和得到的文件描述符一起还原出一个对应的对象</strong>，以 TCP 服务器句柄为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params">message, handle, emit</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> server = <span class="keyword">new</span> net.<span class="title class_">Server</span>()</span><br><span class="line">    server.<span class="title function_">listen</span>(handle, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">emit</span>(server)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，子进程根据 message.type 创建对应 TCP 服务器对象，然后监听到文件描述符上。</p>
<p>我们独立启动的进程中 TCP 服务器端 socket 套接字的文件描述符并不相同，这也是导致监听相同端口时抛出异常的主要原因，但是对于 send() 发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引起异常。</p>
<h3 id="3-集群稳定之路"><a class="markdownIt-Anchor" href="#3-集群稳定之路"></a> 3、集群稳定之路</h3>
<h4 id="1-进程事件"><a class="markdownIt-Anchor" href="#1-进程事件"></a> (1) 进程事件</h4>
<img src="/assets/深入浅出NodeJS/19.jpg">
<h4 id="2-自动重启"><a class="markdownIt-Anchor" href="#2-自动重启"></a> (2) 自动重启</h4>
<p>在有了父子进程之间的相关事件之后，我们就可以在这些关系之间创建出需要的机制了，比如我们可以当监听到子进程退出后重新启动一个工作进程来继续服务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>).<span class="property">fork</span></span><br><span class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).<span class="title function_">cpus</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>).<span class="title function_">createServer</span>()</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> createWorker = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> worker = <span class="title function_">fork</span>(__dirname + <span class="string">&#x27;/worker.js&#x27;</span>)</span><br><span class="line">    worker.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Worker &#x27;</span> + worker.<span class="property">pid</span> + <span class="string">&#x27; exited.&#x27;</span>)</span><br><span class="line">        <span class="keyword">delete</span> workers[worker.<span class="property">pid</span>]</span><br><span class="line">        <span class="title function_">createWorker</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 句柄转发</span></span><br><span class="line">    worker.<span class="title function_">send</span>(<span class="string">&#x27;server&#x27;</span>, server)</span><br><span class="line">    workers[worker.<span class="property">pid</span>] = worker</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Create worker. pid: &#x27;</span> + worker.<span class="property">pid</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">createWorker</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> pid <span class="keyword">in</span> workers) &#123;</span><br><span class="line">        workers[pid].<span class="title function_">kill</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;)</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&#x27;handled by child, pid is &#x27;</span> + process.<span class="property">pid</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">m, tcp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="string">&#x27;server&#x27;</span>) &#123;</span><br><span class="line">        worker = tcp</span><br><span class="line">        tcp.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">            server.<span class="title function_">emit</span>(<span class="string">&#x27;connection&#x27;</span>, socket)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 停止接收新的连接</span></span><br><span class="line">    worker.<span class="title function_">close</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 所有连接断开后退出进程</span></span><br><span class="line">        process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>自杀信号</strong></p>
<p>上述代码的问题是要等到已有的所有连接断开后进程才退出，在极端的情况下，所有工作进程都停止接收新的连接，所有工作进程都停止接收新的连接，全处在等待退出的状态，但在等到进程完全退出才重启的过程中，所有新来的请求可能存在没有工作进程为新用户服务的情景，因此一个重要的优化手段就是<strong>自杀信号</strong>。</p>
<p>自杀信号的具体实现是工作进程在得知要退出时向主进程发送一个自杀信号，然后才停止接收新的连接，当所有连接断开后才退出。主进程在接收到自杀信号后，立即创建新的工作进程服务。这样可以大大提高应用的稳定性和健壮性。</p>
<p>除此之外我们的连接很有可能是长连接而不是 HTTP 服务的这种短连接，等待长连接断开可能需要较久的时间，因此为退出设置一个超时时间是有必要的，至此最终优化代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line">...</span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 记录日志</span></span><br><span class="line">    logger.<span class="title function_">error</span>(err)</span><br><span class="line">    <span class="comment">// 发送自杀信号</span></span><br><span class="line">    process.<span class="title function_">send</span>(&#123; <span class="attr">act</span>: <span class="string">&#x27;suicide&#x27;</span> &#125;)</span><br><span class="line">    <span class="comment">// 停止接收新的连接</span></span><br><span class="line">    worker.<span class="title function_">close</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 设置超时时间 5 s，超过强制退出</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// master.js</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> createWorker = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> worker = <span class="title function_">fork</span>(__dirname + <span class="string">&#x27;/worker.js&#x27;</span>)</span><br><span class="line">    worker.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">message</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.<span class="property">act</span> === <span class="string">&#x27;suicide&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">createWorker</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    worker.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Worker &#x27;</span> + worker.<span class="property">pid</span> + <span class="string">&#x27; exited.&#x27;</span>)</span><br><span class="line">        <span class="keyword">delete</span> workers[worker.<span class="property">pid</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 句柄转发</span></span><br><span class="line">    worker.<span class="title function_">send</span>(<span class="string">&#x27;server&#x27;</span>, server)</span><br><span class="line">    workers[worker.<span class="property">pid</span>] = worker</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Create worker. pid: &#x27;</span> + worker.<span class="property">pid</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>限量重启</strong></p>
<p>在通过自杀信号告知主进程可以使得新连接总是有进程服务，但是工作进程不能无限制地被重启，因为这种无意义的重启已经不符合预期的设置，极有可能是程序编写的错误。因此更好的解决方案是<strong>限量重启</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重启次数</span></span><br><span class="line"><span class="keyword">var</span> limit = <span class="number">10</span></span><br><span class="line"><span class="comment">// 时间单位</span></span><br><span class="line"><span class="keyword">var</span> during = <span class="number">6000</span></span><br><span class="line"><span class="keyword">var</span> restart = []</span><br><span class="line"><span class="keyword">var</span> isTooFrequently = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 记录重启时间</span></span><br><span class="line">    <span class="keyword">var</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">var</span> length = restart.<span class="title function_">push</span>(time)</span><br><span class="line">    <span class="keyword">if</span> (length &gt; limit) &#123;</span><br><span class="line">        <span class="comment">// 取出最后10个记录</span></span><br><span class="line">        restart = restart.<span class="title function_">slice</span>(limit * -<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一次重启到前10次重启之间的时间间隔</span></span><br><span class="line">    <span class="keyword">return</span> restart.<span class="property">length</span> &gt;= limit &amp;&amp; restart[restart.<span class="property">length</span> - <span class="number">1</span>] - restart[<span class="number">0</span>] &lt; during</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> createWorker = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 检查是否太过频繁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isTooFrequently</span>()) &#123;</span><br><span class="line">        <span class="comment">// 触发giveup事件后，不再重启</span></span><br><span class="line">        process.<span class="title function_">emit</span>(<span class="string">&#x27;giveup&#x27;</span>, length, during)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> worker = <span class="title function_">fork</span>(__dirname + <span class="string">&#x27;/worker.js&#x27;</span>)</span><br><span class="line">    worker.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Worker &#x27;</span> + worker.<span class="property">pid</span> + <span class="string">&#x27; existed.&#x27;</span>)</span><br><span class="line">        <span class="keyword">delete</span> workers[worker.<span class="property">pid</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 重新启动新的进程</span></span><br><span class="line">    worker.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">message</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.<span class="property">act</span> === <span class="string">&#x27;suicide&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">createWorker</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 句柄转发</span></span><br><span class="line">    worker.<span class="title function_">send</span>(<span class="string">&#x27;server&#x27;</span>, server)</span><br><span class="line">    workers[worker.<span class="property">pid</span>] = worker</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Create worker. pid：&#x27;</span> + worker.<span class="property">pid</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>giveup 事件是比 uncaughtException 更严重的异常事件。uncaughtException 只代表集群中某个工作进程退出，在整体保证下，不会出现用户得不到服务的情况，但是这个 giveup 事件则表示集群中没有任何进程服务了，十分危险。</p>
<h4 id="3-负载均衡"><a class="markdownIt-Anchor" href="#3-负载均衡"></a> (3) 负载均衡</h4>
<img src="/assets/深入浅出NodeJS/20.jpg">
<h4 id="4-状态共享"><a class="markdownIt-Anchor" href="#4-状态共享"></a> (4) 状态共享</h4>
<p>Node 进程中不宜存放过多数据，会加重垃圾回收的负担，同时 Node 也不允许在多个进程之间共享数据，解决数据共享问题最直接、简单的方式就是通过第三方来存储，比如数据库、磁盘文件、缓存服务等，所有工作进程启动时将其读取进内存中。但是这种方式还需要一种机制在数据一旦改变时通知到各个子进程使得他们的内部状态也得到更新。</p>
<p>实现这种同步机制的方式主要有两种：</p>
<ul>
<li>各个子进程向第三方进行定时轮询，但是这种方式如果轮训时间过短会形成并发处理，但如果轮训时间过长，数据发生改变时不能及时更新到子进程中，会有一定的延迟。</li>
<li>主动通知，我们可以通过通知进程来专门用来发送通知和查询状态，不处理任何业务逻辑，当数据发生变更时通知其他工作进程。</li>
</ul>
<h3 id="4-cluster-模块"><a class="markdownIt-Anchor" href="#4-cluster-模块"></a> 4、Cluster 模块</h3>
<img src="/assets/深入浅出NodeJS/21.jpg">
<h2 id="十-测试"><a class="markdownIt-Anchor" href="#十-测试"></a> 十、测试</h2>
<img src="/assets/深入浅出NodeJS/22.jpg">
<h2 id="十一-产品化"><a class="markdownIt-Anchor" href="#十一-产品化"></a> 十一、 产品化</h2>
<img src="/assets/深入浅出NodeJS/23.jpg">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/08/31/node-network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/31/node-network/" class="post-title-link" itemprop="url">Node中的网络编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-31 10:52:38" itemprop="dateCreated datePublished" datetime="2021-08-31T10:52:38+00:00">2021-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>网络编程的概念是&quot;使用套接字来达到进程间通信的目的&quot;。通常情况下，我们要使用网络提供的功能，可以有以下几种方式：</p>
<ul>
<li>使用应用软件提供的网络通信功能来获取网络服务，最著名的就是浏览器，它在应用层上使用 http 协议，在传输层基于 TCP 协议；</li>
<li>在命令行方式下使用 shell 命令获取系统提供的网络服务，如 telnet、ftp 等；</li>
<li>使用编程的方式通过系统调用获取操作系统提供给我们的网络服务。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/31/node-network/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/08/16/no-bundle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/16/no-bundle/" class="post-title-link" itemprop="url">无包构建方案解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-16 10:02:00" itemprop="dateCreated datePublished" datetime="2021-08-16T10:02:00+00:00">2021-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">前端工程化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>什么是无包构建呢？这是一个与基于模块化打包的构建方案相对的概念。</p>
<p>目前主流的构建工具，例如 Webpack、Rollup 等都是基于一个或多个入口点模块，通过依赖分析将有依赖关系的模块打包到一起，最后形成少数几个产物代码包，因此这些工具也被称为打包工具。只不过，这些工具的构建过程除了打包外，还包括了模块编译和代码优化等，因此称为打包式构建工具或许更恰当。</p>
<p>而无包构建是指这样一类构建方式：在构建时只需处理模块的编译而无须打包，把模块间的<strong>依赖关系完全交给浏览器来处理</strong>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/16/no-bundle/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/08/15/microservices/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/15/microservices/" class="post-title-link" itemprop="url">谈谈微服务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-15 21:41:42" itemprop="dateCreated datePublished" datetime="2021-08-15T21:41:42+00:00">2021-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">应用架构</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>早些年，各大互联网公司的应用技术栈大致可分为 LAMP（Linux + Apache + MySQL + PHP）和 MVC（Spring + iBatis/Hibernate + Tomcat）两大流派。无论是 LAMP 还是 MVC，都是为单体应用架构设计的，其优点是学习成本低，开发上手快，测试、部署、运维也比较方便，甚至一个人就可以完成一个网站的开发与部署。</p>
<p>以 MVC 架构为例，业务通常是通过部署一个 WAR 包到 Tomcat 中，然后启动 Tomcat，监听某个端口即可对外提供服务。早期在业务规模不大、开发团队人员规模较小的时候，采用单体应用架构，团队的开发和运维成本都可控。但是单体应用架构的设计存在如下问题：</p>
<ul>
<li>部署效率低下：当单体应用的代码越来越多，依赖的资源越来越多时，应用编译打包、部署测试的速度会越来越慢。</li>
<li>团队协作开发成本高</li>
<li>系统高可用性差。因为所有的功能开发最后都部署到同一个 WAR 包里，运行在同一个 Tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 WAR 包中部署的功能。</li>
<li>线上发布变慢。单体应用的代码越膨胀，服务启动的时间就会变长，因此我们需要一种方法能够将应用的不同模块的解耦，降低开发和部署成本。</li>
</ul>
<p>因此为了解决这些问题，服务化的思想随之而生。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/15/microservices/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/08/13/client-xmind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/13/client-xmind/" class="post-title-link" itemprop="url">浏览器应用基础思维导图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-13 21:45:51" itemprop="dateCreated datePublished" datetime="2021-08-13T21:45:51+00:00">2021-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">浏览器工作原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://gitmind.cn/app/doc/a6d2369264">GitMind链接</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/13/client-xmind/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/08/12/javascript-xmind/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/12/javascript-xmind/" class="post-title-link" itemprop="url">JavaScript思维导图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-12 21:45:51" itemprop="dateCreated datePublished" datetime="2021-08-12T21:45:51+00:00">2021-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/" itemprop="url" rel="index"><span itemprop="name">深入理解 JavaScript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://gitmind.cn/app/doc/03b2369347">GitMind链接</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/12/javascript-xmind/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/08/12/webpack-dependency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/12/webpack-dependency/" class="post-title-link" itemprop="url">Webpack Dependency Graph深度解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-12 11:31:12" itemprop="dateCreated datePublished" datetime="2021-08-12T11:31:12+00:00">2021-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">前端工程化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>非原创：原文地址<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kr73Epnn6wAx9DH7KRVUaA">有点难的 webpack 知识点：Dependency Graph 深度解析</a></p>
</blockquote>
<p>Dependency Graph 概念来自官网 Dependency Graph | webpack 一文，原文解释是这样的：</p>
<blockquote>
<p>Any time one file depends on another, webpack treats this as a dependency. This allows webpack to take non-code assets, such as images or web fonts, and also provide them as dependencies for your application.<br />
When webpack processes your application, it starts from a list of modules defined on the command line or in its configuration file. Starting from these entry points, webpack recursively builds a dependency graph that includes every module your application needs, then bundles all of those modules into a small number of bundles - often, just one - to be loaded by the browser.</p>
</blockquote>
<p>翻译过来核心意思是：webpack 处理应用代码时，会从开发者提供的 entry 开始递归地组建起包含所有模块的 dependency graph，之后再将这些 module 打包为 bundles 。</p>
<p>然而事实远不止官网描述的这么简单，Dependency Graph 贯穿 webpack 整个运行周期，从 make 阶段的模块解析，到 seal 阶段的 chunk 生成，以及 tree-shaking 功能都高度依赖于Dependency Graph ，是 webpack 资源构建的一个非常核心的数据结构</p>
<p>本文将围绕 webpack@v5.x 的 Dependency Graph 实现，展开讨论三个方面的内容：</p>
<ul>
<li>Dependency Graph 在 webpack 实现中以何种数据结构呈现</li>
<li>Webpack 运行过程中如何收集模块间依赖关系，进而构建出 Dependency Graph</li>
<li>Dependency Graph 构建完毕后，又是如何被消费的</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/12/webpack-dependency/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/08/05/webpack-optimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/05/webpack-optimize/" class="post-title-link" itemprop="url">Webpack构建打包优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-05 10:37:42" itemprop="dateCreated datePublished" datetime="2021-08-05T10:37:42+00:00">2021-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">前端工程化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在我的博客<a target="_blank" rel="noopener" href="https://kyleezhang.github.io/2020/12/16/webpack-runtime/">Webpack运行机制</a>中介绍了 Webpack 的基本工作流程，并介绍了 Compiler 和 Compilation 两个核心模块中的生命周期 Hooks，那么在 Compiler 和 Compilation 的工作流程里，最耗时的阶段分别是哪个呢？</p>
<p>对于 Compiler 实例而言，耗时最长的显然是生成编译过程实例后的 make 阶段，在这个阶段里，会执行模块编译到优化的完整过程。而对于 Compilation 实例的工作流程来说，不同的项目和配置各有不同，但总体而言，编译模块和后续优化阶段的生成产物并压缩代码的过程都是比较耗时的。</p>
<p>实际上不同项目的构建，在整个流程的前期初始化阶段与最后的产物生成阶段的构建时间区别不大。真正影响整个构建效率的还是 Compilation 实例的处理过程，这一过程又可分为两个阶段：编译模块和优化处理，下面针对这两个阶段我们分别介绍对应的优化手段。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/08/05/webpack-optimize/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/07/17/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS-01/" class="post-title-link" itemprop="url">《深入浅出NodeJS》读书笔记（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-17 16:53:05" itemprop="dateCreated datePublished" datetime="2021-07-17T16:53:05+00:00">2021-07-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Node/" itemprop="url" rel="index"><span itemprop="name">Node</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>之前在微信读书零零散散看了一些章节，这次特意买了实体书认真全部看一遍，希望能用这篇博客去做一个记录和思考。</p>
<h2 id="一-node-简介"><a class="markdownIt-Anchor" href="#一-node-简介"></a> 一、Node 简介</h2>
<h3 id="1-node-的特点"><a class="markdownIt-Anchor" href="#1-node-的特点"></a> 1、Node 的特点</h3>
<ul>
<li>异步IO: Node 在底层构建了很多异步 I/O 的 API，从文件的读取到网络请求等，这样的意义在于在 Node 中我们可以从语言层面很自然地进行并行 I/O 操作而无须等待之前的调用结束，在编程模型上可以极大的提升效率。</li>
<li>事件与回调函数: 事件的编程方式具有轻量级、松耦合、只关注事务点等优势，Node 将前端浏览器中应用广泛且成熟的事件引入后端，配合异步 I/O，将事件点暴露给业务逻辑，极大程度上方便了业务层的编码处理。但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是个主要的问题，Node 为此提供了回调函数，而且纵观下来回调函数也是最好的接受异步调用返回数据的方式。</li>
<li>单线程: Node 保持了 JavaScript 在浏览器中单线程的特点，而且在 Node 中 JavaScript 与其他线程是无法共享任何状态的，单线程最大的好处是不用在线线程间的状态同步问题，没有频繁切换线程上下文所带来的性能损耗，缺点在于无法利用多核 CPU、错误会引起整个应用退出、CPU 阻塞会导致无法继续调用异步 I/O。</li>
<li>跨平台: Node 借助 libuv 成功在操作系统与上层 Node 模块之间构建了一层平台层架构，因此借助 libuv 良好的架构设计 Node 实现了跨平台开发。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/17/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS-01/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/07/11/sourcemap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/sourcemap/" class="post-title-link" itemprop="url">深入解析 SourceMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-11 07:57:42" itemprop="dateCreated datePublished" datetime="2021-07-11T07:57:42+00:00">2021-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">前端工程化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是-sourcemap"><a class="markdownIt-Anchor" href="#什么是-sourcemap"></a> 什么是 SourceMap</h2>
<p>在前端开发过程中，通常我们编写的源代码会经过多重处理（编译、封装、压缩等），最后形成产物代码。于是在浏览器中调试产物代码时，我们往往会发现代码变得面目全非，因此，我们需要一种在调试时将产物代码显示回源代码的功能，SourceMap 就是实现这一目标的工具。</p>
<p>SourceMap 的基本原理是，在编译处理的过程中，在生成产物代码的同时生成产物代码中被转换的部分与源代码中相应部分的映射关系表。有了这样一张完整的映射表，我们就可以通过 Chrome 控制台中的&quot;Enable Javascript source map&quot;来实现调试时的显示与定位源代码功能。</p>
<p>注：我们在控制台的网络面板中通常看不到 source map 文件的请求，其原因是出于安全考虑 Chrome 隐藏了 source map 的请求，需要通过 <a href="chrome://net-export/">net-log</a> 来查询。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/07/11/sourcemap/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/06/03/css-scss/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/css-scss/" class="post-title-link" itemprop="url">SCSS 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-03 19:52:58" itemprop="dateCreated datePublished" datetime="2021-06-03T19:52:58+00:00">2021-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS-%E4%B8%96%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">CSS 世界</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="css-预处理器的由来"><a class="markdownIt-Anchor" href="#css-预处理器的由来"></a> CSS 预处理器的由来</h2>
<p>CSS 语言本身存在如下缺陷：</p>
<ul>
<li>语法不够强大，比如无法嵌套书写导致模块化开发中需要书写很多重复的选择器；</li>
<li>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护；</li>
</ul>
<h2 id="css-预处理器是什么"><a class="markdownIt-Anchor" href="#css-预处理器是什么"></a> CSS 预处理器是什么？</h2>
<p>CSS 预处理器用一种专门的编程语言，进行 Web 页面样式设计，然后再编译成正常的 CSS 文件，以供项目使用。CSS 预处理器为 CSS 增加一些编程的特性，无需考虑浏览器的兼容性问题。 比如说：Sass（SCSS）、LESS、Stylus、Turbine 等等都属于 CSS 预处理器。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/03/css-scss/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/06/02/javascript-array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/javascript-array/" class="post-title-link" itemprop="url">JavaScript 中的数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-02 16:29:07" itemprop="dateCreated datePublished" datetime="2021-06-02T16:29:07+00:00">2021-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/" itemprop="url" rel="index"><span itemprop="name">深入理解 JavaScript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数组在任何一门编程语言中都是一个最常见的词，它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。其作为数据结构的官方定义如下所示：</p>
<blockquote>
<p>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
</blockquote>
<p>这其中有几个关键词</p>
<ul>
<li>线性表：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。</li>
<li>连续的内存空间与相同的类型数据：这两个特点赋予了数组结构最为核心的特性：随机访问性。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/02/javascript-array/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/05/15/vue-cli-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/15/vue-cli-02/" class="post-title-link" itemprop="url">从vue-cli到Vue CLI（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-15 12:00:35" itemprop="dateCreated datePublished" datetime="2021-05-15T12:00:35+00:00">2021-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">前端工程化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>70k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:04</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="vue-cli"><a class="markdownIt-Anchor" href="#vue-cli"></a> Vue CLI</h2>
<p>vue-cli 在 3.0 版本进行了彻底的重构，为了区别也将其普遍称为 Vue CLI，是目前 Vue 官方推荐的 Vue 项目快速开发的完整系统，它基于 Webpack 实现，提供了终端命令行工具、零配置脚手架、插件体系、图形化管理界面等诸多功能，近乎提供了前端项目工程化的所有步骤的完整工具链，也是当前 Vue 项目构建的主流工具。</p>
<h3 id="一-整体架构"><a class="markdownIt-Anchor" href="#一-整体架构"></a> 一、整体架构</h3>
<p>vue-cli 为了尽可能覆盖项目工程化需求所以模版项目往往引入了大量第三方库，但实际开发过程中开发者可能并不需要这些功能模块，虽然可以通过在模版项目的 meta.js 或 meta.json 文件配置 prompts 在命令行交互然后在 filterFiles 函数中对生成项目的文件目录结构进行筛选，但是依然可配置性不强，会存在较多冗余依赖或功能，并且依赖项的升级极为痛苦，因此为了给开发者提供更灵活的配置能力 Vue CLI 实现了一种极为巧妙的架构设计：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/05/15/vue-cli-02/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/04/21/javascript-number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/javascript-number/" class="post-title-link" itemprop="url">JavaScript 中的 Number 类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-21 23:17:59" itemprop="dateCreated datePublished" datetime="2021-04-21T23:17:59+00:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/" itemprop="url" rel="index"><span itemprop="name">深入理解 JavaScript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 JavaScript 中数值只有一种，即 Number 类型，内部表示为双精度浮点型，即其他语言中的 double 类型，所以在 JavaScript 中实际上是没有整数类型的，数值都是按浮点数来处理的，存储方法相同，遵循 IEEE 754 国际标准，因此在 JavaScript 中 3 和 3.0 被视为同一个值，示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.0</span> === <span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/21/javascript-number/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/04/20/javascript-proto/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/20/javascript-proto/" class="post-title-link" itemprop="url">JavaScript 中基于原型的继承</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-20 12:37:42" itemprop="dateCreated datePublished" datetime="2021-04-20T12:37:42+00:00">2021-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/" itemprop="url" rel="index"><span itemprop="name">深入理解 JavaScript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>继承是面向对象语言最为重要的概念之一，许多面向对象语言都支持两种继承方式：接口继承和实现继承，接口继承只继承方法签名，而实现继承则继承实际的方法，由于JavaScript中函数没有签名，因此JavaScript中无法实现接口继承，只支持实现继承。<br />
在传统的基于类面向对象的语言如Java、C++中，继承的本质是扩展一个已有的类，并生成新的子类。由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript其实现继承主要是依靠原型链来实现的，本文主要介绍JavaScript中基于原型实现继承的几种主要方式：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/20/javascript-proto/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/04/18/javascript-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/javascript-type/" class="post-title-link" itemprop="url">JavaScript 中的类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-18 09:51:21" itemprop="dateCreated datePublished" datetime="2021-04-18T09:51:21+00:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/" itemprop="url" rel="index"><span itemprop="name">深入理解 JavaScript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-javascript-中的类型"><a class="markdownIt-Anchor" href="#一-javascript-中的类型"></a> 一、JavaScript 中的类型</h2>
<p>JavaScript中的类型可以分为基本数据类型和引用类型两种：</p>
<ul>
<li>基本类型值：指的是保存在栈内存中的简单数据段；</li>
<li>引用类型值：指的是那些保存在堆内存中的对象，意思是，栈内存中保存的实际上只是一个指针，这个指针指向内存堆中实际的值；</li>
</ul>
<p>JavaScript 中的的每一个值都属于某一种数据类型。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/04/18/javascript-type/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/03/17/client-security/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/17/client-security/" class="post-title-link" itemprop="url">浏览器安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-17 20:06:09" itemprop="dateCreated datePublished" datetime="2021-03-17T20:06:09+00:00">2021-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">浏览器工作原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>WEB 世界出现的最初目的就是开放与共享，任何资源都可以接入其中，我们的网站可以加载并执行别人网站的脚本文件、图片、音频、视频等资源，甚至可以下载其他站点的可执行文件。但是如果这种自由没有任何限制反而会引起彻底的混乱和无序，我们的数据与隐私将被肆意窃取。随着 WEB2.0 的时代来临，互联网从C/S架构（客服端/服务端结构）转变为 B/S 架构(浏览器/服务器结构），后者相比于前者更加方便快捷，因此浏览器便成为了我们访问网站的窗口，浏览器安全也随之变得越来越重要。</p>
<p>浏览器安全主要可以分为<strong>Web页面安全</strong>、<strong>浏览器网络安全</strong>和<strong>浏览器系统安全</strong>，接下来我们按照这三个方面分别进行介绍：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/03/17/client-security/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/03/16/client-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/16/client-cache/" class="post-title-link" itemprop="url">浏览器缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-16 19:36:17" itemprop="dateCreated datePublished" datetime="2021-03-16T19:36:17+00:00">2021-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">浏览器工作原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Web 缓存按存储位置来区分，包括数据库缓存、服务端缓存、CDN 缓存和浏览器缓存，浏览器缓存的实现方式主要有两种：HTTP 和 ServiceWorker 。</p>
<h2 id="http-缓存"><a class="markdownIt-Anchor" href="#http-缓存"></a> HTTP 缓存</h2>
<p>使用缓存最大的问题往往不在于将资源缓存在什么位置或者如何读写资源，而在于如何保证缓存与实际资源一致的同时，提高缓存的命中率。也就是说尽可能地让浏览器从缓存中获取资源，但同时又要保证被使用的缓存与服务端最新的资源保持一致。</p>
<p>为了达到这个目的，需要制定合适的缓存过期策略（简称“缓存策略”），HTTP 支持的缓存策略有两种：<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/03/16/client-cache/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/01/28/vue-cli-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/28/vue-cli-01/" class="post-title-link" itemprop="url">从vue-cli到Vue CLI（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-28 21:03:53" itemprop="dateCreated datePublished" datetime="2021-01-28T21:03:53+00:00">2021-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">前端工程化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>到底什么才是前端工程化呢？我们知道一个前端项目的开发往往要经历如下步骤：</p>
<ul>
<li>创建项目，主要工程化内容是创建项目结构、特定类型文件</li>
<li>编码，主要工程化内容是编译/构建/打包</li>
<li>预览/测试，主要工程化内容有Web Server / Mock，Live Reloading / HMR，Source Map等等</li>
<li>提交，主要工程化内容有Git Hooks / Husky， Lint-staged等等</li>
<li>部署，主要工程化内容有持续集成（CI）、持续部署（CD）</li>
</ul>
<p>实际上在这个过程中一切以提高效率、降低成本、质量保证为目的的手段都属于前端工程化，前端工程化从早期的脚手架到现在流行的主流工具链的演变主要是因为什么呢？本篇博客希望通过对 vue-cli 和 Vue CLI 架构思想和实现分析其演变的主要原因及设计动机，也是笔者对于前端工程化的一些阶段性理解。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/01/28/vue-cli-01/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/01/26/css-grid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/26/css-grid/" class="post-title-link" itemprop="url">CSS Grid网格布局详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-26 11:40:48" itemprop="dateCreated datePublished" datetime="2021-01-26T11:40:48+00:00">2021-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS-%E4%B8%96%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">CSS 世界</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Grid 布局又称网格布局，是W3C提出的一个二维布局系统，它与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。Flex 布局是轴线布局，只能指定&quot;项目&quot;针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成&quot;行&quot;和&quot;列&quot;，产生单元格，然后指定&quot;项目所在&quot;的单元格，可以看作是二维布局。目前为止Grid布局是CSS中最为强大的布局方案。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/01/26/css-grid/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/01/22/client-render-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/22/client-render-flow/" class="post-title-link" itemprop="url">浏览器如何渲染页面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-22 10:34:23" itemprop="dateCreated datePublished" datetime="2021-01-22T10:34:23+00:00">2021-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">浏览器工作原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从用户在浏览器中输入一个网址或关键字到浏览器成功渲染目标页面过程中到底发生了什么？浏览器端如何从远程服务器拉取目标页面？又如何完成完整页面的渲染？本篇文章将尽可能详细的展开描述这个过程。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/01/22/client-render-flow/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/01/11/javascript-meta/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/11/javascript-meta/" class="post-title-link" itemprop="url">JavaScript中的元编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-11 10:44:29" itemprop="dateCreated datePublished" datetime="2021-01-11T10:44:29+00:00">2021-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/" itemprop="url" rel="index"><span itemprop="name">深入理解 JavaScript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>什么是元编程？</p>
<p>维基百科对其的定义如下：</p>
<blockquote>
<p>元编程（英语：Metaprogramming），又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的资料，或者在运行时完成部分本应在编译时完成的工作。多数情况下，与手工编写全部代码相比，程序员可以获得更高的工作效率，或者给与程序更大的灵活度去处理新的情形而无需重新编译。<br />
编写元程序的语言称之为元语言。被操纵的程序的语言称之为“目标语言”。一门编程语言同时也是自身的元语言的能力称之为“反射”或者“自反”。<br />
反射是促进元编程的一种很有价值的语言特性。把编程语言自身作为一级资料类型（如LISP、Forth或Rebol）也很有用。支持泛型编程的语言也使用元编程能力。<br />
元编程通常通过两种方式实现。一种是通过应用程序编程接口（APIs）将运行时引擎的内部信息暴露于编程代码。另一种是动态执行包含编程命令的字符串表达式。因此，“程序能够编写程序”。虽然两种方式都能用于同一种语言，但大多数语言趋向于偏向其中一种。</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/01/11/javascript-meta/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/01/06/typescript-08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/06/typescript-08/" class="post-title-link" itemprop="url">TypeScript工程化实践笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-06 23:41:06" itemprop="dateCreated datePublished" datetime="2021-01-06T23:41:06+00:00">2021-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">TypeScript 学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TypeScript 作为 JavaScript 的超集，由于其静态类型系统的引入，使得前端开发大型项目更容易实现团队内代码规范限制及接口数据约定，同时使得代码更容易阅读和理解，但是当我们在基于 TypeScript 实现大型项目的过程中同样要注意如下内容：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/01/06/typescript-08/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/01/03/webpack-codesplitting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/03/webpack-codesplitting/" class="post-title-link" itemprop="url">Webpack中的CodeSplitting</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-03 10:42:50" itemprop="dateCreated datePublished" datetime="2021-01-03T10:42:50+00:00">2021-01-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">前端工程化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>通过 Webpack 实现前端项目整体模块化的优势固然明显，但是它也会存在一些弊端：如果我们的应用非常复杂，这种 All in One 的打包方式就会导致打包的结果过大，然后在绝大多数情形下应用刚开始工作时并不是所有模块都是必须的，更为合理的方案是<strong>把打包的结果按照一定的规则分离到多个 bundle 中，然后根据应用的运行按需加载</strong>。这样就可以降低启动成本，提高响应速度。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/01/03/webpack-codesplitting/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/12/16/webpack-runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/16/webpack-runtime/" class="post-title-link" itemprop="url">Webpack运行机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-16 15:20:42" itemprop="dateCreated datePublished" datetime="2020-12-16T15:20:42+00:00">2020-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">前端工程化</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>其实 Webpack 官网首屏的英雄区就已经很清楚地描述了它的工作原理，如下图所示：<br />
<img src="/assets/webpack-runtime/01.png" width="760" /></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/12/16/webpack-runtime/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/11/28/typescript-07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/28/typescript-07/" class="post-title-link" itemprop="url">TypeScript学习笔记（七）——高级类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-28 18:44:45" itemprop="dateCreated datePublished" datetime="2020-11-28T18:44:45+00:00">2020-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">TypeScript 学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="高级类型"><a class="markdownIt-Anchor" href="#高级类型"></a> 高级类型</h2>
<h3 id="一-交叉类型"><a class="markdownIt-Anchor" href="#一-交叉类型"></a> 一、交叉类型</h3>
<p>交叉类型写法类似于<code>T &amp; U</code>，用于将多个类型合并为一个类型。交叉类型要求同时满足所有指定的类型的要求。也就是所有类型的并集（包含所有属性）。如果函数的返回值是交叉类型，必须做显式类型转换（类型断言）。如果几个类型中有同名属性，后面的属性值会覆盖前面的属性值。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/28/typescript-07/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/11/26/typescript-06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/26/typescript-06/" class="post-title-link" itemprop="url">TypeScript学习笔记（六）——类型检查机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-26 10:41:45" itemprop="dateCreated datePublished" datetime="2020-11-26T10:41:45+00:00">2020-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">TypeScript 学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类型检查机制"><a class="markdownIt-Anchor" href="#类型检查机制"></a> 类型检查机制</h2>
<p>类型检查机制是指TypeScript在做类型检查时所秉承的一些原则，以及表现出的一些行为，其作用主要是辅助开发，提升开发效率。TypeScript的类型检查机制主要包括如下三个部分：</p>
<ul>
<li>类型推断</li>
<li>类型兼容性</li>
<li>类型保护</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/26/typescript-06/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/11/25/typescript-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/25/typescript-05/" class="post-title-link" itemprop="url">TypeScript学习笔记（五）——装饰器及相关应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-25 10:27:57" itemprop="dateCreated datePublished" datetime="2020-11-25T10:27:57+00:00">2020-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">TypeScript 学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h2>
<p>在 ES6 中增加了对类对象的相关定义和操作（比如class和extends），与此同时如何更加优雅地在多个不同类之间共享或者扩展一些方法或者行为也开始被提上日程，我们需要一种更优雅的方法来帮助我们完成这些事情，这个方法就是<strong>装饰器</strong>。</p>
<p>装饰器（decorators）这一特性的提出来源于python之类的语言，如果你熟悉python的话，对它一定不会陌生。那么我们先来看一下python里的装饰器是什么样子的吧：</p>
<blockquote>
<p>A Python decorator is a function that takes another function, extending the behavior of the latter function without explicitly modifying it.</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/25/typescript-05/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/11/23/typescript-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/typescript-04/" class="post-title-link" itemprop="url">TypeScript学习笔记（四）——泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-23 10:27:51" itemprop="dateCreated datePublished" datetime="2020-11-23T10:27:51+00:00">2020-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">TypeScript 学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2>
<p>泛型（Generics）在编程语言中是一个较为普遍的概念，在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。这给软件工程带来了极高的灵活性，进一步提高了组件或函数的可重用性。那么泛型具体的定义是什么呢？<br />
泛型是指不预先确定的数据类型，具体的类型在使用的时候才能确定，它允许同一个函数可以接受不同类型参数的一个模板。设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/23/typescript-04/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/11/18/typescript-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/18/typescript-03/" class="post-title-link" itemprop="url">TypeScript学习笔记（三）——接口与类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-18 11:06:03" itemprop="dateCreated datePublished" datetime="2020-11-18T11:06:03+00:00">2020-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">TypeScript 学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="接口与类"><a class="markdownIt-Anchor" href="#接口与类"></a> 接口与类</h1>
<h2 id="一-接口"><a class="markdownIt-Anchor" href="#一-接口"></a> 一、接口</h2>
<p>在面向对象的语言中“接口”是个很重要的概念，它是对行为的抽象，而具体内容需要通过类实现，TypeScript 中的接口是一个非常灵活的概念，可以用来约束对象、函数以及类的结构和类型，是一种代码协作的契约，我们必须遵守而且不能改变。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/18/typescript-03/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/11/17/typescript-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/17/typescript-02/" class="post-title-link" itemprop="url">TypeScript学习笔记（二）——断言、类型别名与函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-17 10:05:53" itemprop="dateCreated datePublished" datetime="2020-11-17T10:05:53+00:00">2020-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">TypeScript 学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h1>
<h2 id="一-类型断言"><a class="markdownIt-Anchor" href="#一-类型断言"></a> 一、类型断言</h2>
<p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。<br />
通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。<br />
类型断言有两种形式：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/17/typescript-02/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/11/15/typescript-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/15/typescript-01/" class="post-title-link" itemprop="url">TypeScript学习笔记（一）——基本类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-15 16:30:03" itemprop="dateCreated datePublished" datetime="2020-11-15T16:30:03+00:00">2020-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TypeScript-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">TypeScript 学习笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TypeScript 是一种由微软开发的自由和开源的编程语言，是 JavaScript 的一个超集，其为 JavaScript 引入了可选的静态类型，相比于 JavaScript 它的特点主要有以下三点：</p>
<ul>
<li>类型检查：使我们可以在编译阶段发现问题而不是运行时</li>
<li>语言扩展：TypeScript 不仅仅包括了 ES6 及未来提案中的一些特性，还从其他语言借鉴了一些特性，比如接口和抽象类</li>
<li>工具属性：TypeScript 会编译生成 JavaScript 运行在浏览器及不同操作系统上，无其他运行时开销</li>
</ul>
<p>那么为什么我们需要 TypeScript 帮我们引入静态类型呢？</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/15/typescript-01/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/10/30/javascript-scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/javascript-scope/" class="post-title-link" itemprop="url">关于作用域和作用域链的一些想法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-30 19:45:51" itemprop="dateCreated datePublished" datetime="2020-10-30T19:45:51+00:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript/" itemprop="url" rel="index"><span itemprop="name">深入理解 JavaScript</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作用域和作用域链在我学习 JavaScript 过程中曾经带给我很长时间的困惑，也曾经在CSDN总结过一篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44196299/article/details/105492212?spm=1001.2014.3001.5501">博客</a>，但当时好多想法在现在看来依然过于浅薄，所以想用这篇博客来梳理一下自己对于作用域和作用域链的一些全新认识和想法，也希望能帮助和我当初一样对此感到困惑的同学，知识浅薄，希望大家不吝指教。</p>
<h2 id="作用域到底是什么"><a class="markdownIt-Anchor" href="#作用域到底是什么"></a> 作用域到底是什么</h2>
<p>我认为对于作用域认识的关键在于跳出 JavaScript 以一种更高的维度去看它，几乎所有编程语言最基本的功能之一就是能够储存变量当中的值，并且能够在之后对这个变量进行访问和修改，事实上正是这种储存和访问变量值的能力将状态带给了程序，因此程序语言需要制定这样一套规则来存储变量，同时能够方便在日后访问和修改这些变量，而这套规则就是<strong>作用域</strong>，我们由根据这套规则在何时生成将其分为<strong>词法作用域</strong>与<strong>动态作用域</strong>。</p>
<p>在详细介绍两者之前我们先需要了解编程语言的编译过程：</p>
<ol>
<li>分词/词法分析</li>
<li>解析/语法分析</li>
<li>代码生成</li>
</ol>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/10/30/javascript-scope/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/10/29/css-float/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/29/css-float/" class="post-title-link" itemprop="url">浮动与清除浮动</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-29 10:31:49" itemprop="dateCreated datePublished" datetime="2020-10-29T10:31:49+00:00">2020-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS-%E4%B8%96%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">CSS 世界</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>浮动属性最早提出是在CSS1中，其最初的主要目的就是为了允许其他内容（如文本）“围绕”图像，因此浮动属性也只允许作用于图像（有些浏览器还支持表格），后来随着不断发展，浮动属性也允许作用于任何元素，但是文本环绕这一页面样式目前仍然只有利用float属性可以实现，具有唯一性，以下面代码为例：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/10/29/css-float/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/10/26/css-flex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/26/css-flex/" class="post-title-link" itemprop="url">CSS Flex 弹性盒布局</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-26 21:20:48" itemprop="dateCreated datePublished" datetime="2020-10-26T21:20:48+00:00">2020-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS-%E4%B8%96%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">CSS 世界</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Flex布局又称弹性盒布局，是在CSS3中的一种新布局方式，可以简洁、方便、响应式地实现各种页面布局，因此自一提出受到了极大地追捧，目前也得到了各大主流浏览器的支持，因此迅速替代了之前的“display+float+position”的布局形式。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/10/26/css-flex/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/10/26/css-bfc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/26/css-bfc/" class="post-title-link" itemprop="url">BFC-块状格式化上下文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-26 20:56:53" itemprop="dateCreated datePublished" datetime="2020-10-26T20:56:53+00:00">2020-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS-%E4%B8%96%E7%95%8C/" itemprop="url" rel="index"><span itemprop="name">CSS 世界</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>BFC的全称是块状格式化上下文，MDN中对于对于BFC的定义如下：</p>
<blockquote>
<p>一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。</p>
</blockquote>
<p>BFC是一个独立的布局环境，按照块级盒子进行布局，其中的元素布局是不受外界的影响，并且在一个 BFC 中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/10/26/css-bfc/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2020/10/25/client-v8-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/25/client-v8-01/" class="post-title-link" itemprop="url">V8是怎么提升对象属性访问速度的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-25 22:12:57" itemprop="dateCreated datePublished" datetime="2020-10-25T22:12:57+00:00">2020-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-23 16:01:49" itemprop="dateModified" datetime="2022-06-23T16:01:49+00:00">2022-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">浏览器工作原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>尽管有很多关于JavaScript到底是一门面向对象还是基于对象语言的争议，但是无可否认JavaScript中对象扮演着一个举足轻重的关键角色，因此甚至有说法认为“JavaScript中万物皆对象”，当然毫无疑问这个说法是错误的，JavaScript在运行时的数据类型还包括Number、Boolean等基本类型，但是从中我们也可以感受到对象对于JavaScript中的重要意义。从语言的角度上看JavaScript中的对象更像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。但是在V8中实现对象存储时并没有完全采取字典的存储方式，而是采用了一套更为复杂和高效的存储策略。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/10/25/client-v8-01/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kyleezhang"
      src="/assets/config/avatar.png">
  <p class="site-author-name" itemprop="name">kyleezhang</p>
  <div class="site-description" itemprop="description">学源于思</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kyleezhang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kyleezhang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2942181559@qq.com" title="E-Mail → 2942181559@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6998903195" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6998903195" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kyleezhang</span>
</div>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">576k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:43</span>
</div>



        
<div class="busuanzi-count footer-inner">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  


  <!-- 背景动画 -->
<script src="/js/particle.js"></script>

</body>
</html>
