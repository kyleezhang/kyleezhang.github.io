<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/config/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/config/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/config/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kyleezhang.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"enable":true,"style":"tabs","active":false,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文的内容主要分为两部分：  NodeJS 的基础和架构 NodeJS 核心模块的实现   NodeJS 的基础和架构  一、NodeJS 的组成 Node.js 主要由 V8、Libuv 和第三方库组成。">
<meta property="og:type" content="article">
<meta property="og:title" content="NodeJS的底层原理">
<meta property="og:url" content="http://kyleezhang.com/2021/12/28/node-principle/index.html">
<meta property="og:site_name" content="kyleezhang&#96;s Blog">
<meta property="og:description" content="本文的内容主要分为两部分：  NodeJS 的基础和架构 NodeJS 核心模块的实现   NodeJS 的基础和架构  一、NodeJS 的组成 Node.js 主要由 V8、Libuv 和第三方库组成。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://kyleezhang.com/assets/node-principle/01.png">
<meta property="og:image" content="http://kyleezhang.com/assets/node-principle/08.png">
<meta property="og:image" content="http://kyleezhang.com/assets/node-principle/02.png">
<meta property="og:image" content="http://kyleezhang.com/assets/node-principle/03.png">
<meta property="og:image" content="http://kyleezhang.com/assets/node-principle/04.png">
<meta property="og:image" content="http://kyleezhang.com/assets/node-principle/05.png">
<meta property="og:image" content="http://kyleezhang.com/assets/node-principle/06.png">
<meta property="og:image" content="http://kyleezhang.com/assets/node-principle/07.png">
<meta property="article:published_time" content="2021-12-27T16:08:45.000Z">
<meta property="article:modified_time" content="2022-02-26T15:24:04.028Z">
<meta property="article:author" content="kyleezhang">
<meta property="article:tag" content="Node">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://kyleezhang.com/assets/node-principle/01.png">

<link rel="canonical" href="http://kyleezhang.com/2021/12/28/node-principle/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>NodeJS的底层原理 | kyleezhang`s Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2KR3NK700N"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-2KR3NK700N');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f1621cb3fb0792bb294fce1b938d5eef";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="kyleezhang`s Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
    <a target="_blank" rel="noopener" href="https://github.com/kyleezhang " class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kyleezhang`s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/12/28/node-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          NodeJS的底层原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-28 00:08:45" itemprop="dateCreated datePublished" datetime="2021-12-28T00:08:45+08:00">2021-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-26 23:24:04" itemprop="dateModified" datetime="2022-02-26T23:24:04+08:00">2022-02-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文的内容主要分为两部分：</p>
<ul>
<li>NodeJS 的基础和架构</li>
<li>NodeJS 核心模块的实现</li>
</ul>
<h2 id="nodejs-的基础和架构"><a class="markdownIt-Anchor" href="#nodejs-的基础和架构"></a> NodeJS 的基础和架构</h2>
<h3 id="一-nodejs-的组成"><a class="markdownIt-Anchor" href="#一-nodejs-的组成"></a> 一、NodeJS 的组成</h3>
<p>Node.js 主要由 V8、Libuv 和第三方库组成。</p>
<a id="more"></a>
<h4 id="1-libuv"><a class="markdownIt-Anchor" href="#1-libuv"></a> 1、Libuv</h4>
<p>Libuv 是 Node.js 底层的异步 IO 库，但它提供的功能不仅仅是 IO，还包括进程、线程、信号、定时器、进程间通信等，而且 Libuv 抹平了各个操作系统之间的差异。Libuv 提供的功能大概如下：</p>
<ul>
<li>Full-featured event loop backed by epoll, kqueue, IOCP, event ports.</li>
<li>Asynchronous TCP and UDP sockets</li>
<li>Asynchronous DNS resolution</li>
<li>Asynchronous file and file system operations</li>
<li>File system events</li>
<li>ANSI escape code controlled TTY</li>
<li>IPC with socket sharing, using Unix domain sockets or named pipes (Windows)</li>
<li>Child processes</li>
<li>Thread pool</li>
<li>Signal handling</li>
<li>High resolution clock</li>
<li>Threading and synchronization primitives</li>
</ul>
<h4 id="2-v8"><a class="markdownIt-Anchor" href="#2-v8"></a> 2、V8</h4>
<p>Node.js 是基于 V8 的 JS 运行时，它利用 V8 提供的能力，极大地拓展了 JS 的能力。这种拓展不是为 JS 增加了新的语言特性，而是拓展了功能模块，比如在前端，我们可以使用 Date 这个函数，但是我们不能使用 TCP 这个函数，因为 JS 中并没有内置这个函数。而在 Node.js 中，我们可以使用 TCP，这就是 Node.js 做的事情，让用户可以使用 JS 中本来不存在的功能，比如文件、网络。Node.js 中最核心的部分是 Libuv 和 V8，V8 不仅负责执行 JS，还支持自定义的拓展，实现了 JS 调用 C++ 和 C++ 调用 JS 的能力。比如我们可以写一个 C++ 模块，然后在 JS 调用，Node.js 正是利用了这个能力，完成了功能的拓展。JS 层调用的所有 C、C++ 模块都是通过 V8 来完成的。可以说得益于 V8 支持自定义扩展这才有了 Node.js</p>
<h4 id="3-第三方库"><a class="markdownIt-Anchor" href="#3-第三方库"></a> 3、第三方库</h4>
<p>Node.js 中的第三方库主要包括异步 DNS 解析（ cares ）、HTTP 解析器（旧版使用 http_parser，新版使用 llhttp）、HTTP2 解析器（ nghttp2 ）、 解压压缩库( zlib )、加密解密库( openssl )等等。</p>
<h3 id="二-nodejs-代码架构"><a class="markdownIt-Anchor" href="#二-nodejs-代码架构"></a> 二、NodeJS 代码架构</h3>
<img src="/assets/node-principle/01.png" width="600" />
<p>上图是 Node.js 的代码架构，Node.js的代码主要分为 JS、C++、C 三种。</p>
<ol>
<li>JS 是我们平时使用的那些模块(http/fs)。</li>
<li>C++ 代码分为三个部分，第一部分是封装了 Libuv 的功能，第二部分则是不依赖于 Libuv ( crypto 部分 API 使用了 Libuv 线程池)，比如 Buffer 模块，第三部分是 V8 的代码。</li>
<li>C 语言层的代码主要是封装了操作系统的功能，比如 TCP、UDP。</li>
</ol>
<p>了解了 Node.js 的组成和代码架构后，我们看看 Node.js 启动的过程都做了什么。</p>
<h3 id="三-nodejs-启动过程"><a class="markdownIt-Anchor" href="#三-nodejs-启动过程"></a> 三、NodeJS 启动过程</h3>
<p>Node.js启动的主流程图如下所示：</p>
<img src="/assets/node-principle/08.png" width="700" />
<p>涉及到的文件也包括</p>
<ul>
<li>src/node_main.cc</li>
<li>src/node.cc</li>
<li>src/env.cc</li>
<li>lib/internal/bootstrap/loader.js</li>
<li>lib/internal/bootstrap/node.js</li>
</ul>
<p>接下来我们详细分析每个过程：</p>
<h4 id="1-启动"><a class="markdownIt-Anchor" href="#1-启动"></a> 1、启动</h4>
<p>node 的启动函数在 src/node_main.cc 文件当中，这个文件主要是根据操作系统的不同运行了对应的变量设置。然后会调用 <a target="_blank" rel="noopener" href="http://node.cc">node.cc</a> 中的 <code>__Start()__</code> 函数。<a target="_blank" rel="noopener" href="http://node.cc">node.cc</a> 中有三个 Start 函数现在我们依次来看看，</p>
<h4 id="1-注册-c-模块"><a class="markdownIt-Anchor" href="#1-注册-c-模块"></a> 1、注册 C++ 模块</h4>
<img src="/assets/node-principle/02.png" width="600" />
<p>首先 Node.js 会调用 RegisterBuiltinModules 函数注册 C++ 模块，这个函数会调用一系列 registerxxx 的函数，我们发现在 Node.js 源码里找不到这些函数，因为这些函数是在各个 C++ 模块中，通过宏定义实现的，宏展开后就是上图黄色框的内容，每个 registerxxx 函数的作用就是往 C++ 模块的链表了插入一个节点，最后会形成一个链表。</p>
<p>这儿我们以 _register_tcp_wrap 函数为例详细分析一下在函数中具体做了什么，在这之前我们要先了解一下 Node.js 中表示 C++ 模块的数据结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_module</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> nm_version;  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nm_flags;  </span><br><span class="line">    <span class="keyword">void</span>* nm_dso_handle;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* nm_filename;  </span><br><span class="line">    node::addon_register_func nm_register_func;  </span><br><span class="line">    node::addon_context_register_func nm_context_register_func;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* nm_modname;  </span><br><span class="line">    <span class="keyword">void</span>* nm_priv;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">nm_link</span>;</span>  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>_register_tcp_wrap 函数调了 node_module_register，并传入一个node_module数据结构，这里我们看一下 node_module_register 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">node_module_register</span><span class="params">(<span class="keyword">void</span>* m)</span> </span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>* <span class="title">mp</span> =</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="class"><span class="keyword">struct</span> <span class="title">node_module</span>*&gt;</span>(m);  </span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;nm_flags &amp; NM_F_INTERNAL) &#123;  </span><br><span class="line">        mp-&gt;nm_link = modlist_internal;  </span><br><span class="line">        modlist_internal = mp;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!node_is_initialized) &#123; </span><br><span class="line">        mp-&gt;nm_flags = NM_F_LINKED;  </span><br><span class="line">        mp-&gt;nm_link = modlist_linked;  </span><br><span class="line">        modlist_linked = mp;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        thread_local_modpending = mp;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>C++ 内置模块的 flag 是 NM_F_INTERNAL，所以会执行第一个 if 的逻辑，modlist_internal 类似一个头指针。if 里的逻辑就是头插法建立一个单链表。</p>
<p>那么 Node.js 里是如何访问这些 C++ 模块的呢？在 Node.js 中，是通过 internalBinding 访问 C++ 模块的，internalBinding 的逻辑很简单，就是根据模块名从模块队列中找到对应模块。但是这个函数只能在 Node.js 内部使用，不能在用户 JS 模块使用，用户可以通过 process.binding 访问 C++ 模块。</p>
<h4 id="2-创建-environment-对象并绑定到-context"><a class="markdownIt-Anchor" href="#2-创建-environment-对象并绑定到-context"></a> 2、创建 Environment 对象，并绑定到 Context</h4>
<p>注册完 C++ 模块后就开始创建 Environment 对象，Environment 是 Node.js 执行时的环境对象，类似一个全局变量的作用，他记录了 Node.js 在运行时的一些公共数据。创建完 Environment 后，Node.js<br />
会把该对象绑定到 V8 的 Context 中，为什么要这样做呢？</p>
<p>主要是为了在 V8 的执行上下文里拿到 env 对象，因为 V8 中只有 Isolate、Context 这些对象，Isolate用于隔离实例间的环境，Context用于提供JS执行时的上下文，如果我们想在 V8 的执行环境中获取 Environment 对象的内容，就可以通过 Context 获取 Environment 对象。</p>
<img src="/assets/node-principle/03.png" width="400" />
<img src="/assets/node-principle/04.png" width="500" />
<p>实际上这一步骤 Node.js 主要做了如下4件工作：</p>
<ol>
<li>进入当前 Context</li>
<li>保存环境变量</li>
<li>关联 context 和 env</li>
<li>创建其他对象</li>
</ol>
<p>具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Environment::Environment(IsolateData* isolate_data,  </span><br><span class="line">                            Local&lt;Context&gt; context,  </span><br><span class="line">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args,  </span><br><span class="line">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; exec_args,  </span><br><span class="line">                            Flags flags,  </span><br><span class="line">                            <span class="keyword">uint64_t</span> thread_id)  </span><br><span class="line">    : isolate_(context-&gt;GetIsolate()),  </span><br><span class="line">        isolate_data_(isolate_data),  </span><br><span class="line">        immediate_info_(context-&gt;GetIsolate()),  </span><br><span class="line">        tick_info_(context-&gt;GetIsolate()),  </span><br><span class="line">        timer_base_(uv_now(isolate_data-&gt;event_loop())),  </span><br><span class="line">        exec_argv_(exec_args),  </span><br><span class="line">        argv_(args),  </span><br><span class="line">        exec_path_(GetExecPath(args)),  </span><br><span class="line">        should_abort_on_uncaught_toggle_(isolate_, <span class="number">1</span>),  </span><br><span class="line">        stream_base_state_(isolate_, StreamBase::kNumStreamBaseStateFields),  </span><br><span class="line">        flags_(flags),  </span><br><span class="line">        thread_id_(thread_id == kNoThreadId ? AllocateThreadId() : thread_id),  </span><br><span class="line">        fs_stats_field_array_(isolate_, kFsStatsBufferLength),  </span><br><span class="line">        fs_stats_field_bigint_array_(isolate_, kFsStatsBufferLength),  </span><br><span class="line">        context_(context-&gt;GetIsolate(), context) &#123;  </span><br><span class="line">    <span class="comment">// 进入当前的context  </span></span><br><span class="line">    <span class="function">HandleScope <span class="title">handle_scope</span><span class="params">(isolate())</span></span>;  </span><br><span class="line">    <span class="function">Context::Scope <span class="title">context_scope</span><span class="params">(context)</span></span>;  </span><br><span class="line">    <span class="comment">// 保存环境变量  </span></span><br><span class="line">    set_env_vars(per_process::system_environment);  </span><br><span class="line">    <span class="comment">// 关联context和env  </span></span><br><span class="line">    AssignToContext(context, ContextInfo(<span class="string">&quot;&quot;</span>));  </span><br><span class="line">    <span class="comment">// 创建其它对象  </span></span><br><span class="line">    CreateProperties();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 CreateProperties 主要是用于创建诸如 process 等对象，创建之后也会保存到 Environment 对象中。</p>
<h4 id="3-初始化-libuv-任务"><a class="markdownIt-Anchor" href="#3-初始化-libuv-任务"></a> 3、初始化 Libuv 任务</h4>
<p>InitializeLibuv 函数中的逻辑是往 Libuv 中提交任务，在 InitializeLibuv 函数中会调用 uv_idle_init、uv_prepare_init、uv_async_init 等 Libuv 提供的方法向 Libuv 不同阶段插入任务节点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Environment::InitializeLibuv</span><span class="params">(<span class="keyword">bool</span> start_profiler_idle_notifier)</span> </span>&#123;  </span><br><span class="line">    <span class="function">HandleScope <span class="title">handle_scope</span><span class="params">(isolate())</span></span>;  </span><br><span class="line">    <span class="function">Context::Scope <span class="title">context_scope</span><span class="params">(context())</span></span>;  </span><br><span class="line">    CHECK_EQ(<span class="number">0</span>, uv_timer_init(event_loop(), timer_handle()));  </span><br><span class="line">    uv_unref(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_handle_t</span>*&gt;(timer_handle()));  </span><br><span class="line">    uv_check_init(event_loop(), immediate_check_handle());  </span><br><span class="line">    uv_unref(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_handle_t</span>*&gt;(immediate_check_handle()));</span><br><span class="line">    uv_idle_init(event_loop(), immediate_idle_handle());  </span><br><span class="line">    uv_check_start(immediate_check_handle(), CheckImmediate);  </span><br><span class="line">    uv_prepare_init(event_loop(), &amp;idle_prepare_handle_);  </span><br><span class="line">    uv_check_init(event_loop(), &amp;idle_check_handle_);  </span><br><span class="line">    uv_async_init(  </span><br><span class="line">        event_loop(),  </span><br><span class="line">        &amp;task_queues_async_,  </span><br><span class="line">        [](<span class="keyword">uv_async_t</span>* async) &#123;  </span><br><span class="line">        Environment* env = ContainerOf(  </span><br><span class="line">            &amp;Environment::task_queues_async_, async);  </span><br><span class="line">        env-&gt;CleanupFinalizationGroups();  </span><br><span class="line">        env-&gt;RunAndClearNativeImmediates();  </span><br><span class="line">        &#125;);  </span><br><span class="line">    uv_unref(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_handle_t</span>*&gt;(&amp;idle_prepare_handle_));  </span><br><span class="line">    uv_unref(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_handle_t</span>*&gt;(&amp;idle_check_handle_));  </span><br><span class="line">    uv_unref(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uv_handle_t</span>*&gt;(&amp;task_queues_async_));  </span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li>timer_handle 是实现 Node.js 中定时器的数据结构，对应 Libuv 的 time 阶段</li>
<li>immediate_check_handle 是实现 Node.js 中setImmediate的数据结构，对应Libuv的check阶段</li>
<li>task_queues_async_用于子线程和主线程通信</li>
<li>。。。</li>
</ul>
<h4 id="3-初始化模块加载器和执行上下文"><a class="markdownIt-Anchor" href="#3-初始化模块加载器和执行上下文"></a> 3、初始化模块加载器和执行上下文</h4>
<p>RunBootstrapping 里调用了 BootstrapInternalLoaders 和 BootstrapNode 函数，我们一个个进行分析</p>
<p><strong>初始化loader</strong></p>
<p>BootstrapInternalLoaders 用于执行 <code>internal/bootstrap/loaders.js</code>,对应的逻辑转成 JS 如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">process, getLinkedBinding, getInternalBinding, primordials</span>) </span>&#123;  </span><br><span class="line">    <span class="comment">// internal/bootstrap/loaders.js 的代码  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">const</span> process = &#123;&#125;;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLinkedBinding</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInternalBinding</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">const</span> primordials = &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">export</span> = demo(process, getLinkedBinding, getInternalBinding, primordials);  </span><br></pre></td></tr></table></figure>
<p>V8 把 <code>internal/bootstrap/loaders.js</code> 用一个函数包裹起来，参数是 process, getLinkedBinding, getInternalBinding, primordials，而其将会导出一个对象。这儿我们先看一下 getLinkedBinding, getInternalBinding 这两个函数，Node.js 在 C++ 层对外暴露了 AddLinkedBinding 方法注册模块，Node.js 针对这种类型的模块，维护了一个单独的链表。getLinkedBinding 就是根据模块名从这个链表中找到对应的模块。而对于对于 C++ 内置模块，Node.js 同样维护了一个链表，getInternalBinding 就是根据模块名从这个链表中找到对应的模块。</p>
<p>而执行完 <code>internal/bootstrap/loaders.js</code> 将会返回三个变量给 C++ 层：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;  </span><br><span class="line">    internalBinding,  </span><br><span class="line">    NativeModule,  </span><br><span class="line">    <span class="built_in">require</span>: nativeModuleRequire  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
<p>其中 internalBinding 的生成方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> internalBinding;  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">const</span> bindingObj = ObjectCreate(<span class="literal">null</span>);  </span><br><span class="line">    internalBinding = <span class="function"><span class="keyword">function</span> <span class="title">internalBinding</span>(<span class="params"><span class="built_in">module</span></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> mod = bindingObj[<span class="built_in">module</span>];  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> mod !== <span class="string">&#x27;object&#x27;</span>) &#123;  </span><br><span class="line">        mod = bindingObj[<span class="built_in">module</span>] = getInternalBinding(<span class="built_in">module</span>);</span><br><span class="line">        moduleLoadList.push(<span class="string">`Internal Binding <span class="subst">$&#123;<span class="built_in">module</span>&#125;</span>`</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> mod;  </span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这儿 Node.js 在 JS 对 getInternalBinding 进行了一个封装，主要是加了缓存处理。</p>
<p>然后我们再看 NativeModule，Node.js 中除了 C++ 模块还有原生 JS 模块，对于加载原生 JS 模块的处理。Node.js 专门定义了一个 NativeModule 类负责原生 JS 模块的加载，还定义了一个变量保存了原生JS模块的名称列表：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(moduleIds.map(<span class="function">(<span class="params">id</span>) =&gt;</span> [id, <span class="keyword">new</span> NativeModule(id)]));  </span><br></pre></td></tr></table></figure>
<p>NativeModule主要的逻辑如下</p>
<ol>
<li>原生 JS 模块的代码是转成字符存在 node_javascript.cc 文件的，NativeModule 负责原生 JS 模块的加载，即编译和执行。</li>
<li>提供一个 require 函数，加载原生 JS 模块，对于文件路径以 internal 开头的模块，是不能被用户 require 使用的。</li>
</ol>
<p>而这些原生 JS 模块内部往往还需要调用 C++ 模块进行处理，因此 <code>internal/bootstrap/loaders.js</code> 中还封装了 process.binding 方法来方便 JS 层根据模块名查找对应的 C++ 模块，其具体的实现方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> internalBindingWhitelist = <span class="keyword">new</span> SafeSet([,  </span><br><span class="line">    <span class="string">&#x27;tcp_wrap&#x27;</span>,  </span><br><span class="line">    <span class="comment">// 一系列C++内置模块名  </span></span><br><span class="line">]);  </span><br><span class="line">    </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">const</span> bindingObj = ObjectCreate(<span class="literal">null</span>);  </span><br><span class="line">    process.binding = <span class="function"><span class="keyword">function</span> <span class="title">binding</span>(<span class="params"><span class="built_in">module</span></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">module</span> = <span class="built_in">String</span>(<span class="built_in">module</span>);  </span><br><span class="line">        <span class="keyword">if</span> (internalBindingWhitelist.has(<span class="built_in">module</span>)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> internalBinding(<span class="built_in">module</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`No such module: <span class="subst">$&#123;<span class="built_in">module</span>&#125;</span>`</span>);  </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><code>internal/bootstrap/loaders.js</code> 在返回后 C++ 层会保存其中两个函数，分别用于加载内置 C++ 模块和原生 JS 模块的函数。</p>
<p><strong>初始化执行上下文</strong></p>
<ol>
<li>Node.js 首先传入 C++ 模块加载器，执行 loader.js，loader.js 主要是封装了 C++ 模块加载器和原生 JS 模块加载器，并保存到 env 对象中。</li>
<li>接着传入 C++ 和原生 JS 模块加载器，执行 run_main_module.js。</li>
<li>在 run_main_module.js 中传入普通 JS 和原生 JS 模块加载器，执行用户的 JS。</li>
</ol>
<p>假设用户 JS 代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./myModule&#x27;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>代码中分别加载了一个用户模块和原生 JS 模块，我们看看加载过程，执行 require 的时候。</p>
<ol>
<li>Node.js 首先会判断是否是原生 JS 模块，如果不是则直接加载用户模块，否则，会使用原生模块加载器加载原生 JS 模块。</li>
<li>加载原生 JS 模块的时候，如果用到了 C++ 模块，则使用 internalBinding 去加载。</li>
</ol>
<img src="/assets/node-principle/05.png"  />
<h4 id="4-执行用户-js-代码然后进入-libuv-事件循环"><a class="markdownIt-Anchor" href="#4-执行用户-js-代码然后进入-libuv-事件循环"></a> 4、执行用户 JS 代码，然后进入 Libuv 事件循环</h4>
<p>接着 Node.js 就会执行用户的 JS，通常用户的 JS 会给事件循环生产任务，然后就进入了事件循环系统，比如我们 listen 一个服务器的时候，就会在事件循环中新建一个 TCP handle。Node.js 就会在这个事件<br />
循环中一直运行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.createServer(<span class="function">() =&gt;</span> &#123;&#125;).listen(<span class="number">80</span>)</span><br></pre></td></tr></table></figure>
<img src="/assets/node-principle/06.png"  />
<h3 id="四-事件循环"><a class="markdownIt-Anchor" href="#四-事件循环"></a> 四、事件循环</h3>
<p>下面我们看一下事件循环的实现。事件循环主要分为 7 个阶段，timer 阶段主要是处理定时器相关的任务，pending 阶段主要是处理 Poll IO 阶段回调里产生的回调，check、prepare、idle 阶段是自定义的阶段，这三个阶段的任务每次<br />
事件序循环都会被执行，Poll IO 阶段主要是处理网络 IO、信号、线程池等等任务，closing 阶段主要是处理关闭的 handle，比如关闭服务器。</p>
<img src="/assets/node-principle/07.png" width="500" />
<ol>
<li>timer 阶段: 用二叉堆实现，最快过期的在根节点。</li>
<li>pending 阶段：处理 Poll IO 阶段回调里产生的回调</li>
<li>check、prepare、idle 阶段：每次事件循环都会被执行。</li>
<li>Poll IO 阶段：处理文件描述符相关事件。</li>
<li>closing 阶段：执行调用 uv_close 函数时传入的回调。</li>
</ol>
<p>下面我们详细看一下每个阶段的实现。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/375276722">Node.js的底层原理</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/theanarkh/understand-nodejs">通过源码分析nodejs原理</a></p>
<p><a target="_blank" rel="noopener" href="http://localhost:4000/2021/12/28/node-principle/">[NodeJS源码探秘]之启动全流程</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/assets/config/weixin.png" alt="kyleezhang 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/assets/config/alipay.png" alt="kyleezhang 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>kyleezhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://kyleezhang.com/2021/12/28/node-principle/" title="NodeJS的底层原理">http://kyleezhang.com/2021/12/28/node-principle/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/assets/config/wechat.png">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Node/" rel="tag"><i class="fa fa-tag"></i>Node</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/13/graphql-01/" rel="prev" title="GraphQL原理浅析">
      <i class="fa fa-chevron-left"></i> GraphQL原理浅析
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#nodejs-%E7%9A%84%E5%9F%BA%E7%A1%80%E5%92%8C%E6%9E%B6%E6%9E%84"><span class="nav-text"> NodeJS 的基础和架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-nodejs-%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text"> 一、NodeJS 的组成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-libuv"><span class="nav-text"> 1、Libuv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-v8"><span class="nav-text"> 2、V8</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="nav-text"> 3、第三方库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-nodejs-%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84"><span class="nav-text"> 二、NodeJS 代码架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-nodejs-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-text"> 三、NodeJS 启动过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%90%AF%E5%8A%A8"><span class="nav-text"> 1、启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B3%A8%E5%86%8C-c-%E6%A8%A1%E5%9D%97"><span class="nav-text"> 1、注册 C++ 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA-environment-%E5%AF%B9%E8%B1%A1%E5%B9%B6%E7%BB%91%E5%AE%9A%E5%88%B0-context"><span class="nav-text"> 2、创建 Environment 对象，并绑定到 Context</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96-libuv-%E4%BB%BB%E5%8A%A1"><span class="nav-text"> 3、初始化 Libuv 任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-text"> 3、初始化模块加载器和执行上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%89%A7%E8%A1%8C%E7%94%A8%E6%88%B7-js-%E4%BB%A3%E7%A0%81%E7%84%B6%E5%90%8E%E8%BF%9B%E5%85%A5-libuv-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-text"> 4、执行用户 JS 代码，然后进入 Libuv 事件循环</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-text"> 四、事件循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text"> 参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kyleezhang"
      src="/assets/config/avatar.png">
  <p class="site-author-name" itemprop="name">kyleezhang</p>
  <div class="site-description" itemprop="description">学源于思</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kyleezhang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kyleezhang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2942181559@qq.com" title="E-Mail → 2942181559@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6998903195" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6998903195" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kyleezhang</span>
</div>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">563k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:32</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5cb74a324ff7b0f7b544',
      clientSecret: 'cd372db5bb46f07eda7fae4b615fd27371c80dc7',
      repo        : 'kyleezhang.github.io',
      owner       : 'kyleezhang',
      admin       : ['kyleezhang'],
      id          : '2fc429a661b73fab353414e2cf47aaa8',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

  <!-- 背景动画 -->
<script src="/js/particle.js"></script>

</body>
</html>
