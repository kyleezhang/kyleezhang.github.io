<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/config/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/config/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/config/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kyleezhang.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"enable":true,"style":"tabs","active":false,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="网络编程的概念是&quot;使用套接字来达到进程间通信的目的&quot;。通常情况下，我们要使用网络提供的功能，可以有以下几种方式：  使用应用软件提供的网络通信功能来获取网络服务，最著名的就是浏览器，它在应用层上使用 http 协议，在传输层基于 TCP 协议； 在命令行方式下使用 shell 命令获取系统提供的网络服务，如 telnet、ftp 等； 使用编程的方式通过系统调用获取操作系统提供">
<meta property="og:type" content="article">
<meta property="og:title" content="Node中的网络编程">
<meta property="og:url" content="http://kyleezhang.com/2021/08/31/node-network/index.html">
<meta property="og:site_name" content="kyleezhang&#96;s Blog">
<meta property="og:description" content="网络编程的概念是&quot;使用套接字来达到进程间通信的目的&quot;。通常情况下，我们要使用网络提供的功能，可以有以下几种方式：  使用应用软件提供的网络通信功能来获取网络服务，最著名的就是浏览器，它在应用层上使用 http 协议，在传输层基于 TCP 协议； 在命令行方式下使用 shell 命令获取系统提供的网络服务，如 telnet、ftp 等； 使用编程的方式通过系统调用获取操作系统提供">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://kyleezhang.com/assets/node-network/01.jpeg">
<meta property="og:image" content="http://kyleezhang.com/assets/node-network/02.png">
<meta property="article:published_time" content="2021-08-31T02:52:38.000Z">
<meta property="article:modified_time" content="2022-02-19T15:17:55.237Z">
<meta property="article:author" content="kyleezhang">
<meta property="article:tag" content="Node">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://kyleezhang.com/assets/node-network/01.jpeg">

<link rel="canonical" href="http://kyleezhang.com/2021/08/31/node-network/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Node中的网络编程 | kyleezhang`s Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2KR3NK700N"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-2KR3NK700N');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f1621cb3fb0792bb294fce1b938d5eef";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="kyleezhang`s Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
    <a target="_blank" rel="noopener" href="https://github.com/kyleezhang " class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kyleezhang`s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kyleezhang.com/2021/08/31/node-network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/config/avatar.png">
      <meta itemprop="name" content="kyleezhang">
      <meta itemprop="description" content="学源于思">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kyleezhang`s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Node中的网络编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-31 10:52:38" itemprop="dateCreated datePublished" datetime="2021-08-31T10:52:38+08:00">2021-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-19 23:17:55" itemprop="dateModified" datetime="2022-02-19T23:17:55+08:00">2022-02-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>网络编程的概念是&quot;使用套接字来达到进程间通信的目的&quot;。通常情况下，我们要使用网络提供的功能，可以有以下几种方式：</p>
<ul>
<li>使用应用软件提供的网络通信功能来获取网络服务，最著名的就是浏览器，它在应用层上使用 http 协议，在传输层基于 TCP 协议；</li>
<li>在命令行方式下使用 shell 命令获取系统提供的网络服务，如 telnet、ftp 等；</li>
<li>使用编程的方式通过系统调用获取操作系统提供给我们的网络服务。</li>
</ul>
<a id="more"></a>
<p>网络编程涉及到一个套接字（socket）的概念，所谓套接字，实际上是两个不同进程间进行通信的端口（这里的端口有别于IP地址中常用的端口），它是对网络层次模型中网络层及其下面各层操作的一个封装，为了让开发者能够使用各种语言调用操作系统提供的网络服务，在不同服务端语言中都使用了套接字这个概念，开发者只要获得一个套接字（socket），就可以使用套接字（socket）中各种方法来创建不同进程之间的连接进而达到通信目的。</p>
<p>Socket 源于 Unix，而 Unix 的基本哲学是『一些皆文件』，都可以用『打开open ==&gt; 读/写(read/write) ==&gt; 关闭(close)』模式来操作，Socket 也可以采用这种方法进行理解。关于 Socket，可以总结如下几点:</p>
<ul>
<li>可以实现底层通信，几乎所有的应用层都是通过 socket 进行通信的，因此『一切且socket』</li>
<li>对 TCP/IP 协议进行封装，便于应用层协议调用，属于二者之间的中间抽象层</li>
<li>各个语言都有相关实现，例如 C、C++、node</li>
<li>TCP/IP 协议族中，传输层存在两种通用协议: TCP、UDP，两种协议不同，因此 Socket 的参数不同，实现过程也不一样</li>
</ul>
<img src="/assets/node-network/01.jpeg" />
<h2 id="node-中网络通信的架构实现"><a class="markdownIt-Anchor" href="#node-中网络通信的架构实现"></a> Node 中网络通信的架构实现</h2>
<p>Node 中的模块，从两种语言实现角度来说，存在 javscript、c++ 两部分，通过 process.binding 来建立关系。具体分析如下:</p>
<ul>
<li>标准的 Node 模块有 net、udp、dns、http、tls、https 等</li>
<li>V8 是 Chrome 的内核，提供了 JavaScript 解释运行功能，里面包含 tcp_wrap.h、udp_wrap.h、tls_wrap.h 等</li>
<li>OpenSSL 是基本的密码库，包括了 MD5、SHA1、RSA 等加密算法，构成了 Node 标准模块中的 crypto</li>
<li>cares 模块用于 DNS 的解析</li>
<li>libuv 实现了跨平台的异步编程</li>
<li>http_parser 用于 http 的解析</li>
</ul>
<img src="/assets/node-network/02.png" />
<h2 id="net-模块"><a class="markdownIt-Anchor" href="#net-模块"></a> net 模块</h2>
<p>net 模块是基于 TCP 协议的 socket 网路编程模块，http 模块就是建立在该模块的基础上实现的，先来看看基本使用方法:</p>
<h3 id="1-创建-tcp-服务端"><a class="markdownIt-Anchor" href="#1-创建-tcp-服务端"></a> 1、创建 TCP 服务端</h3>
<p>创建一个TCP服务器，可以通过使用构造函数 <code>new net.Server</code> 或者使用工厂方法 <code>net.createServer</code>，这两个方法都会返回一个 net.Server 类，可接收两个可选参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line">server.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">  socket.pipe(process.stdout);</span><br><span class="line">  socket.write(<span class="string">&#x27;data from server&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`server is on <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(server.address())&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>或者也可以采用另一种写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net=<span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server=net.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;客户端和服务端建立连接&#x27;</span>);</span><br><span class="line">  server.getConnections(<span class="function"><span class="keyword">function</span>(<span class="params">err,count</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;当前连接数为%d&quot;</span>,count);</span><br><span class="line">  &#125;);</span><br><span class="line">  server.maxConnections=<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;tcp最大连接数为%d&#x27;</span>,server.maxConnections);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&#x27;error&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">e.code==<span class="string">&#x27;EADDRINUSE&#x27;</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;地址和端口被占用&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="string">&#x27;localhost&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//console.log(&#x27;服务器端开始监听...&#x27;);</span></span><br><span class="line">  <span class="keyword">var</span> address=server.address();</span><br><span class="line">  <span class="built_in">console</span>.log(address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在终端使用tenlent 0.0.0.0 3000 即可与之通信。</p>
<p>示例中我们使用 <code>const server = net.createServer();</code> 创建了 server 对象，那 server 对象有哪些特点:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net.js</span></span><br><span class="line"><span class="built_in">exports</span>.createServer = <span class="function"><span class="keyword">function</span>(<span class="params">options, connectionListener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Server(options, connectionListener);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Server</span>(<span class="params">options, connectionListener</span>) </span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="built_in">this</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> connectionListener === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.on(<span class="string">&#x27;connection&#x27;</span>, connectionListener);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">this</span>._handle = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Server, EventEmitter);</span><br></pre></td></tr></table></figure>
<p>首先我们看到 server 对象是一个 EventEmitter 实例，它的自定义事件有如下几种:</p>
<ul>
<li>listening：在调用 server.listen() 绑定端口或 Domain Socket 后触发，可以写作 server.listen(port, listeningListener)。</li>
<li>connection：每个客户端 socket 连接到服务器时触发，可以写作 net.createServer(options, connectionListener)。</li>
<li>close：服务器关闭时触发。server.close() 会停止接受新的 socket，但是保存已有的连接，等待所有的连接断开后触发。</li>
<li>error：服务器发生异常时触发。</li>
</ul>
<p>其次我们在 server 对象中发现了 _handle 属性，_handle 是 server 处理的句柄，属性值最终由 C++ 部分的 TCP、Pipe 类创建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createServerHandle</span>(<span class="params">address, port, addressType, fd</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fd === <span class="string">&#x27;number&#x27;</span> &amp;&amp; fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    handle = createHandle(fd);</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">port === -<span class="number">1</span> &amp;&amp; addressType === -<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    handle = <span class="keyword">new</span> Pipe();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handle = <span class="keyword">new</span> TCP();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHandle</span>(<span class="params">fd</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = TTYWrap.guessHandleType(fd);</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;PIPE&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> Pipe();</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;TCP&#x27;</span>) <span class="keyword">return</span> <span class="keyword">new</span> TCP();</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Unsupported fd type: &#x27;</span> + type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_handle 由 C++ 中的 Pipe、TCP 实现，主要用于 Node 进程通信中 socket 句柄传递，具体可查看<a target="_blank" rel="noopener" href="https://cnodejs.org/topic/572b8a2c8783d212174bd72b">通过源码解析 Node.js 中进程间通信中的 socket 句柄传递</a>。</p>
<p>再来看看 connectionListener 事件的回调函数，里面包含一个 socket 对象，该对象是一个连接套接字，是个五元组 (server_host、server_ip、protocol、client_host、client_ip)，相关实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onconnection</span>(<span class="params">err, clientHandle</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> socket = <span class="keyword">new</span> Socket(&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">  self.emit(<span class="string">&#x27;connection&#x27;</span>, socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 Socket 是继承了 stream.Duplex，所以 Socket 也是一个可读可写流，可以使用流的方法进行数据的处理。</p>
<p>接下来就是很关键的端口监听(port)，这是 server 与 client 的主要区别，代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Server.prototype.listen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  listen(self, ip, port, addressType, backlog, fd, exclusive);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params">self, address, port, addressType, backlog, fd, exclusive</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!cluster) cluster = <span class="built_in">require</span>(<span class="string">&#x27;cluster&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cluster.isMaster || exclusive) &#123;</span><br><span class="line">    self._listen2(address, port, addressType, backlog, fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cluster._getServer(self, &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;, cb);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">err, handle</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    self._handle = handle;</span><br><span class="line">    self._listen2(address, port, addressType, backlog, fd);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Server.prototype._listen2 = <span class="function"><span class="keyword">function</span>(<span class="params">address, port, addressType, backlog, fd</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>._handle) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    rval = createServerHandle(address, port, addressType, fd);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>._handle = rval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._handle.onconnection = onconnection;</span><br><span class="line">  <span class="keyword">var</span> err = _listen(<span class="built_in">this</span>._handle, backlog);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_listen</span>(<span class="params">handle, backlog</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> handle.listen(backlog || <span class="number">511</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码有几个点需要注意:</p>
<ul>
<li>监听的对象可以是端口、路径、定义好的 server 句柄、文件描述符</li>
<li>当通过 cluster 创建工作进程(worker)时，exclusive 判断是否进行 socket 连接的共享</li>
<li>事件监听最终还是通过 TCP/Pipe 的 listen 来实现</li>
<li>backlog 规定了 socket 连接的限制，默认最多为 511</li>
</ul>
<h3 id="2-创建-tcp-客户端"><a class="markdownIt-Anchor" href="#2-创建-tcp-客户端"></a> 2、创建 TCP 客户端</h3>
<p>创建一个 TCP 客户端链接可以使用构造函数 <code>new net.Socket</code> 或者其工厂方法 <code>net.createConnection</code>，创建成功后都会返回一个 net.Socket 实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">&#x27;net&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = net.createConnection(&#123;<span class="attr">port</span>:<span class="number">3000</span>, <span class="attr">host</span>:<span class="string">&#x27;localhost&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;connect&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;client connect&#x27;</span>);</span><br><span class="line">  client.write(<span class="string">&#x27;hello world!&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    client.end(<span class="string">&#x27;bye bye&#x27;</span>);</span><br><span class="line">  &#125;,<span class="number">10000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;data&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;client data&#x27;</span>, data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;error&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> error;</span><br><span class="line">  client.destroy();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;close&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;client close&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>服务器可以与多个客户端保存连接，每个连接都是典型的可读可写的 Stream 对象。它的自定义事件有如下几种:</p>
<ul>
<li>data：当一端调用 write() 发送数据，另外一端触发 data 事件。</li>
<li>end：当连接中的任一端发送 FIN 数据时，触发该事件。</li>
<li>connect：客户端 socket 与服务器连接成功适触发。</li>
<li>drain：rain 和 socket.write() 的返回值强关联，当任意一端调用 write()，当前这端会触发该事件。</li>
<li>error：异常时触发。</li>
<li>close：socket 关闭时触发。</li>
<li>timeout：一定时间连接不再活跃时，该事件触发，通知用户当前连接已经闲置。</li>
</ul>
<p>从上面可以看出基于TCP连接的通信具有的特点:</p>
<ul>
<li>面向连接，必须建立连接后才能够互相通信</li>
<li>TCP 连接是一对一的，就是说在 TCP 中，一个客户端 socket 连接一个服务端 socket，并且两者可以相互通信，通信是双向的</li>
<li>TCP 连接关闭的时候是可以只关闭一方的连接而保留单向通信</li>
<li>一个特定的 IP 加端口可以连接多个 TCP 客户端，也可以通过编程指定连接上限</li>
</ul>
<h2 id="dgram模块"><a class="markdownIt-Anchor" href="#dgram模块"></a> dgram模块</h2>
<p>跟 net 模块相比，基于 UDP 通信的 dgram 模块就简单了很多，因为不需要通过三次握手建立连接，所以整个通信的过程就简单了很多，对于数据准确性要求不太高的业务场景，可以使用该模块完成数据的通信。</p>
<h3 id="1-创建-udp-服务端"><a class="markdownIt-Anchor" href="#1-创建-udp-服务端"></a> 1、创建 UDP 服务端</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram=<span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server=dgram.createSocket(<span class="string">&#x27;udp4&#x27;</span>);</span><br><span class="line">server.on(<span class="string">&quot;message&quot;</span>,<span class="function">(<span class="params">msg,rinfo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;已接收到客户端发送的数据为&#x27;</span> + msg);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;客户端地址新信息为%j&quot;</span>, rinfo);</span><br><span class="line">  <span class="keyword">var</span> buff=<span class="keyword">new</span> Buffer(<span class="string">&quot;确认信息&quot;</span>+msg);</span><br><span class="line">  server.send(buff,<span class="number">0</span>,buff.length,rinfo.port,rinfo.address);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    server.unref();</span><br><span class="line">  &#125;,<span class="number">10000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&quot;listening&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> address = server.address();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器开始监听，地址信息为%j&quot;</span>,address);</span><br><span class="line">&#125;);</span><br><span class="line">server.bind(<span class="number">3000</span>,<span class="string">&#x27;localhost&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>从源码层面分析上述代码的原理实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.createSocket = <span class="function"><span class="keyword">function</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Socket(type, listener);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Socket</span>(<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> handle = newHandle(type);</span><br><span class="line">  <span class="built_in">this</span>._handle = handle;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">this</span>.on(<span class="string">&#x27;message&#x27;</span>, listener);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Socket, EventEmitter);</span><br><span class="line"><span class="keyword">const</span> UDP = process.binding(<span class="string">&#x27;udp_wrap&#x27;</span>).UDP;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newHandle</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type == <span class="string">&#x27;udp4&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="keyword">new</span> UDP();</span><br><span class="line">    handle.lookup = lookup4;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type == <span class="string">&#x27;udp6&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="keyword">new</span> UDP();</span><br><span class="line">    handle.lookup = lookup6;</span><br><span class="line">    handle.bind = handle.bind6;</span><br><span class="line">    handle.send = handle.send6;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Socket.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">port_ <span class="comment">/*, address, callback*/</span></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  startListening(self);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startListening</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  socket._handle.onmessage = onMessage;</span><br><span class="line">  socket._handle.recvStart();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMessage</span>(<span class="params">nread, handle, buf, rinfo</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  self.emit(<span class="string">&#x27;message&#x27;</span>, buf, rinfo);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Socket.prototype.send = <span class="function"><span class="keyword">function</span>(<span class="params">buffer, offset, length, port, address, callback</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  self._handle.lookup(address, <span class="function"><span class="keyword">function</span> <span class="title">afterDns</span>(<span class="params">ex, ip</span>) </span>&#123;</span><br><span class="line">    doSend(ex, self, ip, list, address, port, callback);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> SendWrap = process.binding(<span class="string">&#x27;udp_wrap&#x27;</span>).SendWrap;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSend</span>(<span class="params">ex, self, ip, list, address, port, callback</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> req = <span class="keyword">new</span> SendWrap();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> err = self._handle.send(req, list, list.length, port, ip, !!callback);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码存在几个点需要注意:</p>
<ul>
<li>UDP 模块没有继承 stream，仅仅继承了 EventEmit，后续的所有操作都是基于事件的方式，它的自定义事件如下：
<ul>
<li>message：当 UDP socket 侦听网卡端口后，接收到消息时触发该事件。</li>
<li>listening：当 UDP 开始侦听时触发该事件。</li>
<li>close：调用 close() 方法时触发该事件，并不再触发 message 事件。</li>
<li>error：发生异常时触发该事件。</li>
</ul>
</li>
<li>UDP 在创建的时候需要注意 ipv4 和 ipv6</li>
<li>UDP 的 _handle 是由 UDP 类创建的</li>
<li>通信过程中可能需要进行 DNS 查询，解析出 ip 地址，然后再进行其他操作</li>
</ul>
<h3 id="2-创建-udp-客户端"><a class="markdownIt-Anchor" href="#2-创建-udp-客户端"></a> 2、创建 UDP 客户端</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram=<span class="built_in">require</span>(<span class="string">&#x27;dgram&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> message= Buffer.from(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> client=dgram.createSocket(<span class="string">&#x27;udp4&#x27;</span>);</span><br><span class="line">client.send(message,<span class="number">0</span>,message.length, <span class="number">3000</span>,<span class="string">&quot;localhost&quot;</span>, <span class="function">(<span class="params">err,bytes</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(<span class="string">&#x27;数据发送失败&#x27;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">&quot;已发送%d字节数据&quot;</span>,bytes);</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg,rinfo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;已接收到服务端发送的数据%s&quot;</span>,msg);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器地址信息为%j&quot;</span>,rinfo);</span><br><span class="line">  client.close();</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">&quot;close&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;socket端口被关闭&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-unix-domain-socket-ipc"><a class="markdownIt-Anchor" href="#3-unix-domain-socket-ipc"></a> 3、UNIX Domain Socket IPC</h3>
<p>socket API 原本是为网络通讯设计的，但后来在 socket 的框架上发展出一种 IPC 机制，就是 UNIX Domain Socket。虽然网络 socket 也可用于同一台主机的进程间通讯（通过 loopback 地址 127.0.0.1），但是 UNIX Domain Socket 用于 IPC 更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC 机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。UNIX Domain Socket 也提供面向流和面向数据包两种 API 接口，类似于 TCP 和 UDP，但是面向消息的 UNIX Domain Socket 也是可靠的，消息既不会丢失也不会顺序错乱。<br />
UNIX Domain Socket 与网络 socket 编程最明显的不同在于地址格式不同，用结构体 sockaddr_un 表示，网络编程的 socket 地址是IP地址加端口号，而 UNIX Domain Socket 的地址是一个 socket 类型的文件在文件系统中的路径，这个 socket 文件由 bind() 调用创建，如果调用 bind() 时该文件已存在，则 bind() 错误返回。</p>
<p><strong>创建一个 UNIX 域套接字服务器</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> server = net.createServer(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">  c.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;client disconnected&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  c.write(<span class="string">&quot;hello\r\n&quot;</span>);</span><br><span class="line">  c.pipe(c);</span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// server.listen(path[, backlog][, callback]) for IPC servers</span></span><br><span class="line">server.listen(<span class="string">&quot;/tmp/echo.sock&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;server bound&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>连接UNIX 域套接字服务器</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -U /tmp/echo.sock <span class="comment"># -U — Use UNIX domain socket</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>nc（netcat）可以用于涉及 TCP 或 UDP 的相关内容，比如通过它我们可以打开 TCP 连接，发送 UDP 数据包，监听任意的 TCP 和 UDP 端口，执行端口扫描和处理 IPv4 和 IPv6 等。</p>
</blockquote>
<h2 id="dns-模块"><a class="markdownIt-Anchor" href="#dns-模块"></a> dns 模块</h2>
<p>DNS(Domain Name System) 用于域名解析，也就是找到 host 对应的 ip 地址，在计算机网络中，这个工作是由网络层的 ARP 协议实现。在 node 中存在 net 模块来完成相应功能，其中 dns 里面的函数分为两类:</p>
<ul>
<li>第一类函数，使用底层操作系统工具进行域名解析，且无需进行网络通信。 这类函数只有一个：dns.lookup()。</li>
<li>第二类函数，连接到一个真实的 DNS 服务器进行域名解析，且始终使用网络进行 DNS 查询。 这类函数包含了 dns 模块中除 dns.lookup() 以外的所有函数。 这些函数使用与 dns.lookup() 不同的配置文件（例如 /etc/hosts）。 这类函数适合于那些不想使用底层操作系统工具进行域名解析、而是想使用网络进行 DNS 查询的开发者。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">&#x27;dns&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&#x27;bj.meituan.com&#x27;</span>;</span><br><span class="line">dns.lookup(host, <span class="function">(<span class="params">err, address, family</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;by net.lookup, address is: %s, family is: %s&#x27;</span>, address, family);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dns.resolve(host, <span class="function">(<span class="params">err, address</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;by net.resolve, address is: %s&#x27;</span>, address);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// by net.resolve, address is: 103.37.152.41</span></span><br><span class="line"><span class="comment">// by net.lookup, address is: 103.37.152.41, family is: 4</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，二者解析的结果是一样的，但是假如我们修改本地的/etc/hosts文件呢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在&#x2F;etc&#x2F;host文件中，增加:</span><br><span class="line">10.10.10.0 bj.meituan.com</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后再执行上述文件，结果是:</span><br><span class="line">by net.resolve, address is: 103.37.152.41</span><br><span class="line">by net.lookup, address is: 10.10.10.0, family is: 4</span><br></pre></td></tr></table></figure>
<p>接下来分析下dns的内部实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cares = process.binding(<span class="string">&#x27;cares_wrap&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> GetAddrInfoReqWrap = cares.GetAddrInfoReqWrap;</span><br><span class="line"><span class="built_in">exports</span>.lookup = <span class="function"><span class="keyword">function</span> <span class="title">lookup</span>(<span class="params">hostname, options, callback</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  callback = makeAsync(callback);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> req = <span class="keyword">new</span> GetAddrInfoReqWrap();</span><br><span class="line">  req.callback = callback;</span><br><span class="line">  <span class="keyword">var</span> err = cares.getaddrinfo(req, hostname, family, hints);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolver</span>(<span class="params">bindingName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> binding = cares[bindingName];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">name, callback</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    callback = makeAsync(callback);</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> QueryReqWrap();</span><br><span class="line">    req.callback = callback;</span><br><span class="line">    <span class="keyword">var</span> err = binding(req, name);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> resolveMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">exports</span>.resolve4 = resolveMap.A = resolver(<span class="string">&#x27;queryA&#x27;</span>);</span><br><span class="line"><span class="built_in">exports</span>.resolve6 = resolveMap.AAAA = resolver(<span class="string">&#x27;queryAaaa&#x27;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">exports</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">hostname, type_, callback_</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  resolver = resolveMap[type_];</span><br><span class="line">  <span class="keyword">return</span> resolver(hostname, callback);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的源码有几个点需要关注:</p>
<ul>
<li>lookup 与 resolve 存在差异，使用的时候需要注意</li>
<li>不管是 lookup 还是 resolve，均依赖于 cares 库</li>
<li>域名解析的 type 很多: resolve4、resolve6、resolveCname、resolveMx、resolveNs、resolveTxt、resolveSrv、resolvePtr、resolveNaptr、resolveSoa、reverse</li>
</ul>
<h2 id="http-模块"><a class="markdownIt-Anchor" href="#http-模块"></a> http 模块</h2>
<p>在WEB开发中，HTTP作为最流行、最重要的应用层，是每个开发人员应该熟知的基础知识，我面试的时候必问的一块内容。同时，大多数同学接触node时，首先使用的恐怕就是http模块。先来一个简单的demo看看:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.setHeader(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  res.write(<span class="string">&#x27;&lt;!doctype&gt;&#x27;</span>);</span><br><span class="line">  res.end(<span class="string">`&lt;html&gt;&lt;/html&gt;`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;server is on &#x27;</span>, server.address());</span><br><span class="line">  <span class="keyword">var</span> req = http.request(&#123; <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="attr">port</span>: <span class="number">3000</span>&#125;);</span><br><span class="line">  req.on(<span class="string">&#x27;response&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;data from server &#x27;</span>, chunk.toString()) );</span><br><span class="line">    res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> server.close() );</span><br><span class="line">  &#125;);</span><br><span class="line">  req.end();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出结果如下:</span></span><br><span class="line"><span class="comment">// server is on  &#123; address: &#x27;::&#x27;, family: &#x27;IPv6&#x27;, port: 3000 &#125;</span></span><br><span class="line"><span class="comment">// data from server  &lt;!doctype&gt;</span></span><br><span class="line"><span class="comment">// data from server  &lt;html&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-httpagent"><a class="markdownIt-Anchor" href="#1-httpagent"></a> 1、http.Agent</h3>
<p>因为HTTP协议是无状态协议，每个请求均需通过三次握手建立连接进行通信，众所周知三次握手、慢启动算法、四次挥手等过程很消耗时间，因此HTTP1.1协议引入了keep-alive来避免频繁的连接。那么对于tcp连接该如何管理呢？http.Agent就是做这个工作的。先看看源码中的关键部分:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Agent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  EventEmitter.call(<span class="built_in">this</span>);</span><br><span class="line">  ...</span><br><span class="line">  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;</span><br><span class="line">  self.maxFreeSockets = self.options.maxFreeSockets || <span class="number">256</span>;</span><br><span class="line">  ...</span><br><span class="line">  self.requests = &#123;&#125;; <span class="comment">// 请求队列</span></span><br><span class="line">  self.sockets = &#123;&#125;; <span class="comment">// 正在使用的tcp连接池</span></span><br><span class="line">  self.freeSockets = &#123;&#125;; <span class="comment">// 空闲的连接池</span></span><br><span class="line">  self.on(<span class="string">&#x27;free&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket, options</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// requests、sockets、freeSockets的读写操作</span></span><br><span class="line">    self.requests[name].shift().onSocket(socket);</span><br><span class="line">    freeSockets.push(socket);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Agent.defaultMaxSockets = <span class="literal">Infinity</span>;</span><br><span class="line">util.inherits(Agent, EventEmitter);</span><br><span class="line"><span class="comment">// 关于socket的相关增删改查操作</span></span><br><span class="line">Agent.prototype.addRequest = <span class="function"><span class="keyword">function</span>(<span class="params">req, options</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (freeLen) &#123;</span><br><span class="line">    <span class="keyword">var</span> socket = <span class="built_in">this</span>.freeSockets[name].shift();</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.sockets[name].push(socket);</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockLen &lt; <span class="built_in">this</span>.maxSockets) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.requests[name].push(req);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Agent.prototype.createSocket = <span class="function"><span class="keyword">function</span>(<span class="params">req, options, cb</span>) </span>&#123; ... &#125;</span><br><span class="line">Agent.prototype.removeSocket = <span class="function"><span class="keyword">function</span>(<span class="params">s, options</span>) </span>&#123; ... &#125;</span><br><span class="line"><span class="built_in">exports</span>.globalAgent = <span class="keyword">new</span> Agent();</span><br></pre></td></tr></table></figure>
<p>上述代码有几个点需要注意:</p>
<ul>
<li>maxSockets默认情况下，没有tcp连接数量的上限(Infinity)</li>
<li>连接池管理的核心是对sockets、freeSockets的增删查</li>
<li>globalAgent会作为http.ClientRequest的默认agent</li>
</ul>
<p>下面可以测试下agent对请求本身的限制:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// req.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">&#x27;ok &#x27;</span>, i++);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> max = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>; i&lt;max; i++</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req = http.request(&#123; <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="attr">port</span>: <span class="number">3000</span>&#125;);</span><br><span class="line">    req.on(<span class="string">&#x27;response&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;data from server &#x27;</span>, chunk.toString()) );</span><br><span class="line">      res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> server.close() );</span><br><span class="line">    &#125;);</span><br><span class="line">    req.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在终端中执行time node ./req.js，结果为:</span></span><br><span class="line"><span class="comment">// real  0m1.123s</span></span><br><span class="line"><span class="comment">// user  0m0.102s</span></span><br><span class="line"><span class="comment">// sys 0m0.024s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在req.js中添加下面代码</span></span><br><span class="line">http.globalAgent.maxSockets = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 然后同样time node ./req.js，结果为:</span></span><br><span class="line">real  <span class="number">0</span>m4<span class="number">.141</span>s</span><br><span class="line">user  <span class="number">0</span>m0<span class="number">.103</span>s</span><br><span class="line">sys <span class="number">0</span>m0<span class="number">.024</span>s</span><br></pre></td></tr></table></figure>
<p>当设置maxSockets为某个值时，tcp的连接就会被限制在某个值，剩余的请求就会进入requests队列里面，等有空余的socket连接后，从request队列中出栈，发送请求。</p>
<h3 id="2-httpclientrequest"><a class="markdownIt-Anchor" href="#2-httpclientrequest"></a> 2、http.ClientRequest</h3>
<p>当执行http.request时，会生成ClientRequest对象，该对象虽然没有直接继承Stream.Writable，但是继承了http.OutgoingMessage，而http.OutgoingMessage实现了write、end方法，因为可以当跟stream.Writable一样的使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = http.request(&#123; <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="attr">port</span>: <span class="number">3000</span>, <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>&#125;);</span><br><span class="line">req.on(<span class="string">&#x27;response&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;data from server &#x27;</span>, chunk.toString()) );</span><br><span class="line">  res.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> server.close() );</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 直接使用pipe，在request请求中添加数据</span></span><br><span class="line">fs.createReadStream(<span class="string">&#x27;./data.json&#x27;</span>).pipe(req);</span><br></pre></td></tr></table></figure>
<p>接下来，看看http.ClientRequest的实现, ClientRequest继承了OutgoingMessage:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> OutgoingMessage = <span class="built_in">require</span>(<span class="string">&#x27;_http_outgoing&#x27;</span>).OutgoingMessage;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClientRequest</span>(<span class="params">options, cb</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  OutgoingMessage.call(self);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(ClientRequest, OutgoingMessage);</span><br></pre></td></tr></table></figure>
<h3 id="3-httpserver"><a class="markdownIt-Anchor" href="#3-httpserver"></a> 3、http.Server</h3>
<p>http.createServer其实就是创建了一个http.Server对象，关键源码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.createServer = <span class="function"><span class="keyword">function</span>(<span class="params">requestListener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Server(requestListener);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Server</span>(<span class="params">requestListener</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  net.Server.call(<span class="built_in">this</span>, &#123; <span class="attr">allowHalfOpen</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  <span class="keyword">if</span> (requestListener) &#123;</span><br><span class="line">    <span class="built_in">this</span>.addListener(<span class="string">&#x27;request&#x27;</span>, requestListener);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">this</span>.addListener(<span class="string">&#x27;connection&#x27;</span>, connectionListener);</span><br><span class="line">  <span class="built_in">this</span>.timeout = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Server, net.Server);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectionListener</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  socket.on(<span class="string">&#x27;end&#x27;</span>, socketOnEnd);</span><br><span class="line">  socket.on(<span class="string">&#x27;data&#x27;</span>, socketOnData)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几个需要要关注的点:</p>
<ul>
<li>服务的创建依赖于net.server，通过net.server在底层实现服务的创建</li>
<li>默认情况下，服务的超时时间为2分钟</li>
<li>connectionListener处理tcp连接后的行为，跟net保持一致</li>
</ul>
<h3 id="4-httpserverresponse"><a class="markdownIt-Anchor" href="#4-httpserverresponse"></a> 4、http.ServerResponse</h3>
<p>看node.org官方是如何介绍server端的response对象的:</p>
<blockquote>
<p>This object is created internally by an HTTP server–not by the user. It is passed as the second parameter to the ‘request’ event.</p>
</blockquote>
<blockquote>
<p>The response implements, but does not inherit from, the Writable Stream interface.</p>
</blockquote>
<p>跟http.ClientRequest很像，继承了OutgoingMessage，没有继承Stream.Writable，但是实现了Stream的功能，可以跟Stream.Writable一样灵活使用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ServerResponse</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  OutgoingMessage.call(<span class="built_in">this</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(ServerResponse, OutgoingMessage);</span><br></pre></td></tr></table></figure>
<h3 id="5-httpincomingmessage"><a class="markdownIt-Anchor" href="#5-httpincomingmessage"></a> 5、http.IncomingMessage</h3>
<blockquote>
<p>An IncomingMessage object is created by http.Server or http.ClientRequest and passed as the first argument to the ‘request’ and ‘response’ event respectively. It may be used to access response status, headers and data.</p>
</blockquote>
<p>http.IncomingMessage有两个地方时被内部创建，一个是作为server端的request，另外一个是作为client请求中的response，同时该类显示地继承了Stream.Readable。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IncomingMessage</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  Stream.Readable.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.socket = socket;</span><br><span class="line">  <span class="built_in">this</span>.connection = socket;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(IncomingMessage, Stream.Readable);</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<p><a target="_blank" rel="noopener" href="http://zhenhua-lee.github.io/node/socket.html">初步研究node中的网络通信模块</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/kekobin/blog/issues/32">node基础篇之网络编程</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/assets/config/weixin.png" alt="kyleezhang 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/assets/config/alipay.png" alt="kyleezhang 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>kyleezhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://kyleezhang.com/2021/08/31/node-network/" title="Node中的网络编程">http://kyleezhang.com/2021/08/31/node-network/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/assets/config/wechat.png">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Node/" rel="tag"><i class="fa fa-tag"></i>Node</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/16/no-bundle/" rel="prev" title="无包构建方案解析">
      <i class="fa fa-chevron-left"></i> 无包构建方案解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/10/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANodeJS-02/" rel="next" title="《深入浅出NodeJS》读书笔记（二）">
      《深入浅出NodeJS》读书笔记（二） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#node-%E4%B8%AD%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0"><span class="nav-text"> Node 中网络通信的架构实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#net-%E6%A8%A1%E5%9D%97"><span class="nav-text"> net 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA-tcp-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-text"> 1、创建 TCP 服务端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA-tcp-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text"> 2、创建 TCP 客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dgram%E6%A8%A1%E5%9D%97"><span class="nav-text"> dgram模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA-udp-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-text"> 1、创建 UDP 服务端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9B%E5%BB%BA-udp-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-text"> 2、创建 UDP 客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-unix-domain-socket-ipc"><span class="nav-text"> 3、UNIX Domain Socket IPC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dns-%E6%A8%A1%E5%9D%97"><span class="nav-text"> dns 模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http-%E6%A8%A1%E5%9D%97"><span class="nav-text"> http 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-httpagent"><span class="nav-text"> 1、http.Agent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-httpclientrequest"><span class="nav-text"> 2、http.ClientRequest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-httpserver"><span class="nav-text"> 3、http.Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-httpserverresponse"><span class="nav-text"> 4、http.ServerResponse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-httpincomingmessage"><span class="nav-text"> 5、http.IncomingMessage</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-text"> 参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kyleezhang"
      src="/assets/config/avatar.png">
  <p class="site-author-name" itemprop="name">kyleezhang</p>
  <div class="site-description" itemprop="description">学源于思</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kyleezhang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kyleezhang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2942181559@qq.com" title="E-Mail → 2942181559@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/6998903195" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;6998903195" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kyleezhang</span>
</div>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">563k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:32</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5cb74a324ff7b0f7b544',
      clientSecret: 'cd372db5bb46f07eda7fae4b615fd27371c80dc7',
      repo        : 'kyleezhang.github.io',
      owner       : 'kyleezhang',
      admin       : ['kyleezhang'],
      id          : '248a3d94b12b6b4c12d194be6b9afed4',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

  <!-- 背景动画 -->
<script src="/js/particle.js"></script>

</body>
</html>
